/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/xmlhttprequest-ssl";
exports.ids = ["vendor-chunks/xmlhttprequest-ssl"];
exports.modules = {

/***/ "(ssr)/../node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js":
/*!****************************************************************!*\
  !*** ../node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\r\n * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.\r\n *\r\n * This can be used with JS designed for browsers to improve reuse of code and\r\n * allow the use of existing libraries.\r\n *\r\n * Usage: include(\"XMLHttpRequest.js\") and use XMLHttpRequest per W3C specs.\r\n *\r\n * @author Dan DeFelippi <dan@driverdan.com>\r\n * @contributor David Ellis <d.f.ellis@ieee.org>\r\n * @license MIT\r\n */ var fs = __webpack_require__(/*! fs */ \"fs\");\nvar Url = __webpack_require__(/*! url */ \"url\");\nvar spawn = (__webpack_require__(/*! child_process */ \"child_process\").spawn);\n/**\r\n * Module exports.\r\n */ module.exports = XMLHttpRequest;\n// backwards-compat\nXMLHttpRequest.XMLHttpRequest = XMLHttpRequest;\n/**\r\n * `XMLHttpRequest` constructor.\r\n *\r\n * Supported options for the `opts` object are:\r\n *\r\n *  - `agent`: An http.Agent instance; http.globalAgent may be used; if 'undefined', agent usage is disabled\r\n *\r\n * @param {Object} opts optional \"options\" object\r\n */ function XMLHttpRequest(opts) {\n    \"use strict\";\n    opts = opts || {};\n    /**\r\n   * Private variables\r\n   */ var self = this;\n    var http = __webpack_require__(/*! http */ \"http\");\n    var https = __webpack_require__(/*! https */ \"https\");\n    // Holds http.js objects\n    var request;\n    var response;\n    // Request settings\n    var settings = {};\n    // Disable header blacklist.\n    // Not part of XHR specs.\n    var disableHeaderCheck = false;\n    // Set some default headers\n    var defaultHeaders = {\n        \"User-Agent\": \"node-XMLHttpRequest\",\n        \"Accept\": \"*/*\"\n    };\n    var headers = Object.assign({}, defaultHeaders);\n    // These headers are not user setable.\n    // The following are allowed but banned in the spec:\n    // * user-agent\n    var forbiddenRequestHeaders = [\n        \"accept-charset\",\n        \"accept-encoding\",\n        \"access-control-request-headers\",\n        \"access-control-request-method\",\n        \"connection\",\n        \"content-length\",\n        \"content-transfer-encoding\",\n        \"cookie\",\n        \"cookie2\",\n        \"date\",\n        \"expect\",\n        \"host\",\n        \"keep-alive\",\n        \"origin\",\n        \"referer\",\n        \"te\",\n        \"trailer\",\n        \"transfer-encoding\",\n        \"upgrade\",\n        \"via\"\n    ];\n    // These request methods are not allowed\n    var forbiddenRequestMethods = [\n        \"TRACE\",\n        \"TRACK\",\n        \"CONNECT\"\n    ];\n    // Send flag\n    var sendFlag = false;\n    // Error flag, used when errors occur or abort is called\n    var errorFlag = false;\n    var abortedFlag = false;\n    // Event listeners\n    var listeners = {};\n    /**\r\n   * Constants\r\n   */ this.UNSENT = 0;\n    this.OPENED = 1;\n    this.HEADERS_RECEIVED = 2;\n    this.LOADING = 3;\n    this.DONE = 4;\n    /**\r\n   * Public vars\r\n   */ // Current state\n    this.readyState = this.UNSENT;\n    // default ready state change handler in case one is not set or is set late\n    this.onreadystatechange = null;\n    // Result & response\n    this.responseText = \"\";\n    this.responseXML = \"\";\n    this.status = null;\n    this.statusText = null;\n    /**\r\n   * Private methods\r\n   */ /**\r\n   * Check if the specified header is allowed.\r\n   *\r\n   * @param string header Header to validate\r\n   * @return boolean False if not allowed, otherwise true\r\n   */ var isAllowedHttpHeader = function(header) {\n        return disableHeaderCheck || header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1;\n    };\n    /**\r\n   * Check if the specified method is allowed.\r\n   *\r\n   * @param string method Request method to validate\r\n   * @return boolean False if not allowed, otherwise true\r\n   */ var isAllowedHttpMethod = function(method) {\n        return method && forbiddenRequestMethods.indexOf(method) === -1;\n    };\n    /**\r\n   * Public methods\r\n   */ /**\r\n   * Open the connection. Currently supports local server requests.\r\n   *\r\n   * @param string method Connection method (eg GET, POST)\r\n   * @param string url URL for the connection.\r\n   * @param boolean async Asynchronous connection. Default is true.\r\n   * @param string user Username for basic authentication (optional)\r\n   * @param string password Password for basic authentication (optional)\r\n   */ this.open = function(method, url, async, user, password) {\n        this.abort();\n        errorFlag = false;\n        abortedFlag = false;\n        // Check for valid request method\n        if (!isAllowedHttpMethod(method)) {\n            throw new Error(\"SecurityError: Request method not allowed\");\n        }\n        settings = {\n            \"method\": method,\n            \"url\": url.toString(),\n            \"async\": typeof async !== \"boolean\" ? true : async,\n            \"user\": user || null,\n            \"password\": password || null\n        };\n        setState(this.OPENED);\n    };\n    /**\r\n   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.\r\n   * This does not conform to the W3C spec.\r\n   *\r\n   * @param boolean state Enable or disable header checking.\r\n   */ this.setDisableHeaderCheck = function(state) {\n        disableHeaderCheck = state;\n    };\n    /**\r\n   * Sets a header for the request.\r\n   *\r\n   * @param string header Header name\r\n   * @param string value Header value\r\n   * @return boolean Header added\r\n   */ this.setRequestHeader = function(header, value) {\n        if (this.readyState != this.OPENED) {\n            throw new Error(\"INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN\");\n        }\n        if (!isAllowedHttpHeader(header)) {\n            console.warn('Refused to set unsafe header \"' + header + '\"');\n            return false;\n        }\n        if (sendFlag) {\n            throw new Error(\"INVALID_STATE_ERR: send flag is true\");\n        }\n        headers[header] = value;\n        return true;\n    };\n    /**\r\n   * Gets a header from the server response.\r\n   *\r\n   * @param string header Name of header to get.\r\n   * @return string Text of the header or null if it doesn't exist.\r\n   */ this.getResponseHeader = function(header) {\n        if (typeof header === \"string\" && this.readyState > this.OPENED && response.headers[header.toLowerCase()] && !errorFlag) {\n            return response.headers[header.toLowerCase()];\n        }\n        return null;\n    };\n    /**\r\n   * Gets all the response headers.\r\n   *\r\n   * @return string A string with all response headers separated by CR+LF\r\n   */ this.getAllResponseHeaders = function() {\n        if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {\n            return \"\";\n        }\n        var result = \"\";\n        for(var i in response.headers){\n            // Cookie headers are excluded\n            if (i !== \"set-cookie\" && i !== \"set-cookie2\") {\n                result += i + \": \" + response.headers[i] + \"\\r\\n\";\n            }\n        }\n        return result.substr(0, result.length - 2);\n    };\n    /**\r\n   * Gets a request header\r\n   *\r\n   * @param string name Name of header to get\r\n   * @return string Returns the request header or empty string if not set\r\n   */ this.getRequestHeader = function(name) {\n        // @TODO Make this case insensitive\n        if (typeof name === \"string\" && headers[name]) {\n            return headers[name];\n        }\n        return \"\";\n    };\n    /**\r\n   * Sends the request to the server.\r\n   *\r\n   * @param string data Optional data to send as request body.\r\n   */ this.send = function(data) {\n        if (this.readyState != this.OPENED) {\n            throw new Error(\"INVALID_STATE_ERR: connection must be opened before send() is called\");\n        }\n        if (sendFlag) {\n            throw new Error(\"INVALID_STATE_ERR: send has already been called\");\n        }\n        var ssl = false, local = false;\n        var url = Url.parse(settings.url);\n        var host;\n        // Determine the server\n        switch(url.protocol){\n            case \"https:\":\n                ssl = true;\n            // SSL & non-SSL both need host, no break here.\n            case \"http:\":\n                host = url.hostname;\n                break;\n            case \"file:\":\n                local = true;\n                break;\n            case undefined:\n            case \"\":\n                host = \"localhost\";\n                break;\n            default:\n                throw new Error(\"Protocol not supported.\");\n        }\n        // Load files off the local filesystem (file://)\n        if (local) {\n            if (settings.method !== \"GET\") {\n                throw new Error(\"XMLHttpRequest: Only GET method is supported\");\n            }\n            if (settings.async) {\n                fs.readFile(unescape(url.pathname), \"utf8\", function(error, data) {\n                    if (error) {\n                        self.handleError(error, error.errno || -1);\n                    } else {\n                        self.status = 200;\n                        self.responseText = data;\n                        setState(self.DONE);\n                    }\n                });\n            } else {\n                try {\n                    this.responseText = fs.readFileSync(unescape(url.pathname), \"utf8\");\n                    this.status = 200;\n                    setState(self.DONE);\n                } catch (e) {\n                    this.handleError(e, e.errno || -1);\n                }\n            }\n            return;\n        }\n        // Default to port 80. If accessing localhost on another port be sure\n        // to use http://localhost:port/path\n        var port = url.port || (ssl ? 443 : 80);\n        // Add query string if one is used\n        var uri = url.pathname + (url.search ? url.search : \"\");\n        // Set the Host header or the server may reject the request\n        headers[\"Host\"] = host;\n        if (!(ssl && port === 443 || port === 80)) {\n            headers[\"Host\"] += \":\" + url.port;\n        }\n        // Set Basic Auth if necessary\n        if (settings.user) {\n            if (typeof settings.password == \"undefined\") {\n                settings.password = \"\";\n            }\n            var authBuf = new Buffer(settings.user + \":\" + settings.password);\n            headers[\"Authorization\"] = \"Basic \" + authBuf.toString(\"base64\");\n        }\n        // Set content length header\n        if (settings.method === \"GET\" || settings.method === \"HEAD\") {\n            data = null;\n        } else if (data) {\n            headers[\"Content-Length\"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);\n            if (!headers[\"Content-Type\"]) {\n                headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n            }\n        } else if (settings.method === \"POST\") {\n            // For a post with no data set Content-Length: 0.\n            // This is required by buggy servers that don't meet the specs.\n            headers[\"Content-Length\"] = 0;\n        }\n        var agent = opts.agent || false;\n        var options = {\n            host: host,\n            port: port,\n            path: uri,\n            method: settings.method,\n            headers: headers,\n            agent: agent\n        };\n        if (ssl) {\n            options.pfx = opts.pfx;\n            options.key = opts.key;\n            options.passphrase = opts.passphrase;\n            options.cert = opts.cert;\n            options.ca = opts.ca;\n            options.ciphers = opts.ciphers;\n            options.rejectUnauthorized = opts.rejectUnauthorized === false ? false : true;\n        }\n        // Reset error flag\n        errorFlag = false;\n        // Handle async requests\n        if (settings.async) {\n            // Use the proper protocol\n            var doRequest = ssl ? https.request : http.request;\n            // Request is being sent, set send flag\n            sendFlag = true;\n            // As per spec, this is called here for historical reasons.\n            self.dispatchEvent(\"readystatechange\");\n            // Handler for the response\n            var responseHandler = function(resp) {\n                // Set response var to the response we got back\n                // This is so it remains accessable outside this scope\n                response = resp;\n                // Check for redirect\n                // @TODO Prevent looped redirects\n                if (response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {\n                    // Change URL to the redirect location\n                    settings.url = response.headers.location;\n                    var url = Url.parse(settings.url);\n                    // Set host var in case it's used later\n                    host = url.hostname;\n                    // Options for the new request\n                    var newOptions = {\n                        hostname: url.hostname,\n                        port: url.port,\n                        path: url.path,\n                        method: response.statusCode === 303 ? \"GET\" : settings.method,\n                        headers: headers\n                    };\n                    if (ssl) {\n                        newOptions.pfx = opts.pfx;\n                        newOptions.key = opts.key;\n                        newOptions.passphrase = opts.passphrase;\n                        newOptions.cert = opts.cert;\n                        newOptions.ca = opts.ca;\n                        newOptions.ciphers = opts.ciphers;\n                        newOptions.rejectUnauthorized = opts.rejectUnauthorized === false ? false : true;\n                    }\n                    // Issue the new request\n                    request = doRequest(newOptions, responseHandler).on(\"error\", errorHandler);\n                    request.end();\n                    // @TODO Check if an XHR event needs to be fired here\n                    return;\n                }\n                if (response && response.setEncoding) {\n                    response.setEncoding(\"utf8\");\n                }\n                setState(self.HEADERS_RECEIVED);\n                self.status = response.statusCode;\n                response.on(\"data\", function(chunk) {\n                    // Make sure there's some data\n                    if (chunk) {\n                        self.responseText += chunk;\n                    }\n                    // Don't emit state changes if the connection has been aborted.\n                    if (sendFlag) {\n                        setState(self.LOADING);\n                    }\n                });\n                response.on(\"end\", function() {\n                    if (sendFlag) {\n                        // The sendFlag needs to be set before setState is called.  Otherwise if we are chaining callbacks\n                        // there can be a timing issue (the callback is called and a new call is made before the flag is reset).\n                        sendFlag = false;\n                        // Discard the 'end' event if the connection has been aborted\n                        setState(self.DONE);\n                    }\n                });\n                response.on(\"error\", function(error) {\n                    self.handleError(error);\n                });\n            };\n            // Error handler for the request\n            var errorHandler = function(error) {\n                self.handleError(error);\n            };\n            // Create the request\n            request = doRequest(options, responseHandler).on(\"error\", errorHandler);\n            if (opts.autoUnref) {\n                request.on(\"socket\", (socket)=>{\n                    socket.unref();\n                });\n            }\n            // Node 0.4 and later won't accept empty data. Make sure it's needed.\n            if (data) {\n                request.write(data);\n            }\n            request.end();\n            self.dispatchEvent(\"loadstart\");\n        } else {\n            // Create a temporary file for communication with the other Node process\n            var contentFile = \".node-xmlhttprequest-content-\" + process.pid;\n            var syncFile = \".node-xmlhttprequest-sync-\" + process.pid;\n            fs.writeFileSync(syncFile, \"\", \"utf8\");\n            // The async request the other Node process executes\n            var execString = \"var http = require('http'), https = require('https'), fs = require('fs');\" + \"var doRequest = http\" + (ssl ? \"s\" : \"\") + \".request;\" + \"var options = \" + JSON.stringify(options) + \";\" + \"var responseText = '';\" + \"var req = doRequest(options, function(response) {\" + \"response.setEncoding('utf8');\" + \"response.on('data', function(chunk) {\" + \"  responseText += chunk;\" + \"});\" + \"response.on('end', function() {\" + \"fs.writeFileSync('\" + contentFile + \"', 'NODE-XMLHTTPREQUEST-STATUS:' + response.statusCode + ',' + responseText, 'utf8');\" + \"fs.unlinkSync('\" + syncFile + \"');\" + \"});\" + \"response.on('error', function(error) {\" + \"fs.writeFileSync('\" + contentFile + \"', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');\" + \"fs.unlinkSync('\" + syncFile + \"');\" + \"});\" + \"}).on('error', function(error) {\" + \"fs.writeFileSync('\" + contentFile + \"', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');\" + \"fs.unlinkSync('\" + syncFile + \"');\" + \"});\" + (data ? \"req.write('\" + JSON.stringify(data).slice(1, -1).replace(/'/g, \"\\\\'\") + \"');\" : \"\") + \"req.end();\";\n            // Start the other Node Process, executing this string\n            var syncProc = spawn(process.argv[0], [\n                \"-e\",\n                execString\n            ]);\n            var statusText;\n            while(fs.existsSync(syncFile)){\n            // Wait while the sync file is empty\n            }\n            self.responseText = fs.readFileSync(contentFile, \"utf8\");\n            // Kill the child process once the file has data\n            syncProc.stdin.end();\n            // Remove the temporary file\n            fs.unlinkSync(contentFile);\n            if (self.responseText.match(/^NODE-XMLHTTPREQUEST-ERROR:/)) {\n                // If the file returned an error, handle it\n                var errorObj = self.responseText.replace(/^NODE-XMLHTTPREQUEST-ERROR:/, \"\");\n                self.handleError(errorObj, 503);\n            } else {\n                // If the file returned okay, parse its data and move to the DONE state\n                self.status = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:([0-9]*),.*/, \"$1\");\n                self.responseText = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:[0-9]*,(.*)/, \"$1\");\n                setState(self.DONE);\n            }\n        }\n    };\n    /**\r\n   * Called when an error is encountered to deal with it.\r\n   * @param  status  {number}    HTTP status code to use rather than the default (0) for XHR errors.\r\n   */ this.handleError = function(error, status) {\n        this.status = status || 0;\n        this.statusText = error;\n        this.responseText = error.stack;\n        errorFlag = true;\n        setState(this.DONE);\n    };\n    /**\r\n   * Aborts a request.\r\n   */ this.abort = function() {\n        if (request) {\n            request.abort();\n            request = null;\n        }\n        headers = Object.assign({}, defaultHeaders);\n        this.responseText = \"\";\n        this.responseXML = \"\";\n        errorFlag = abortedFlag = true;\n        if (this.readyState !== this.UNSENT && (this.readyState !== this.OPENED || sendFlag) && this.readyState !== this.DONE) {\n            sendFlag = false;\n            setState(this.DONE);\n        }\n        this.readyState = this.UNSENT;\n    };\n    /**\r\n   * Adds an event listener. Preferred method of binding to events.\r\n   */ this.addEventListener = function(event, callback) {\n        if (!(event in listeners)) {\n            listeners[event] = [];\n        }\n        // Currently allows duplicate callbacks. Should it?\n        listeners[event].push(callback);\n    };\n    /**\r\n   * Remove an event callback that has already been bound.\r\n   * Only works on the matching funciton, cannot be a copy.\r\n   */ this.removeEventListener = function(event, callback) {\n        if (event in listeners) {\n            // Filter will return a new array with the callback removed\n            listeners[event] = listeners[event].filter(function(ev) {\n                return ev !== callback;\n            });\n        }\n    };\n    /**\r\n   * Dispatch any events, including both \"on\" methods and events attached using addEventListener.\r\n   */ this.dispatchEvent = function(event) {\n        if (typeof self[\"on\" + event] === \"function\") {\n            if (this.readyState === this.DONE) setImmediate(function() {\n                self[\"on\" + event]();\n            });\n            else self[\"on\" + event]();\n        }\n        if (event in listeners) {\n            for(let i = 0, len = listeners[event].length; i < len; i++){\n                if (this.readyState === this.DONE) setImmediate(function() {\n                    listeners[event][i].call(self);\n                });\n                else listeners[event][i].call(self);\n            }\n        }\n    };\n    /**\r\n   * Changes readyState and calls onreadystatechange.\r\n   *\r\n   * @param int state New state\r\n   */ var setState = function(state) {\n        if (self.readyState === state || self.readyState === self.UNSENT && abortedFlag) return;\n        self.readyState = state;\n        if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {\n            self.dispatchEvent(\"readystatechange\");\n        }\n        if (self.readyState === self.DONE) {\n            let fire;\n            if (abortedFlag) fire = \"abort\";\n            else if (errorFlag) fire = \"error\";\n            else fire = \"load\";\n            self.dispatchEvent(fire);\n            // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)\n            self.dispatchEvent(\"loadend\");\n        }\n    };\n}\n;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3htbGh0dHByZXF1ZXN0LXNzbC9saWIvWE1MSHR0cFJlcXVlc3QuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7O0NBV0MsR0FFRCxJQUFJQSxLQUFLQyxtQkFBT0EsQ0FBQztBQUNqQixJQUFJQyxNQUFNRCxtQkFBT0EsQ0FBQztBQUNsQixJQUFJRSxRQUFRRixpRUFBOEI7QUFFMUM7O0NBRUMsR0FFREcsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixtQkFBbUI7QUFDbkJBLGVBQWVBLGNBQWMsR0FBR0E7QUFFaEM7Ozs7Ozs7O0NBUUMsR0FFRCxTQUFTQSxlQUFlQyxJQUFJO0lBQzFCO0lBRUFBLE9BQU9BLFFBQVEsQ0FBQztJQUVoQjs7R0FFQyxHQUNELElBQUlDLE9BQU8sSUFBSTtJQUNmLElBQUlDLE9BQU9SLG1CQUFPQSxDQUFDO0lBQ25CLElBQUlTLFFBQVFULG1CQUFPQSxDQUFDO0lBRXBCLHdCQUF3QjtJQUN4QixJQUFJVTtJQUNKLElBQUlDO0lBRUosbUJBQW1CO0lBQ25CLElBQUlDLFdBQVcsQ0FBQztJQUVoQiw0QkFBNEI7SUFDNUIseUJBQXlCO0lBQ3pCLElBQUlDLHFCQUFxQjtJQUV6QiwyQkFBMkI7SUFDM0IsSUFBSUMsaUJBQWlCO1FBQ25CLGNBQWM7UUFDZCxVQUFVO0lBQ1o7SUFFQSxJQUFJQyxVQUFVQyxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHSDtJQUVoQyxzQ0FBc0M7SUFDdEMsb0RBQW9EO0lBQ3BELGVBQWU7SUFDZixJQUFJSSwwQkFBMEI7UUFDNUI7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0lBRUQsd0NBQXdDO0lBQ3hDLElBQUlDLDBCQUEwQjtRQUM1QjtRQUNBO1FBQ0E7S0FDRDtJQUVELFlBQVk7SUFDWixJQUFJQyxXQUFXO0lBQ2Ysd0RBQXdE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LE9BQU87aUJBQ0osSUFBSXpILFdBQ1B5SCxPQUFPO2lCQUVQQSxPQUFPO1lBRVR2SSxLQUFLNEYsYUFBYSxDQUFDMkM7WUFFbkIsZ0VBQWdFO1lBQ2hFdkksS0FBSzRGLGFBQWEsQ0FBQztRQUNyQjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMveG1saHR0cHJlcXVlc3Qtc3NsL2xpYi9YTUxIdHRwUmVxdWVzdC5qcz85MjFmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBXcmFwcGVyIGZvciBidWlsdC1pbiBodHRwLmpzIHRvIGVtdWxhdGUgdGhlIGJyb3dzZXIgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0LlxyXG4gKlxyXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHdpdGggSlMgZGVzaWduZWQgZm9yIGJyb3dzZXJzIHRvIGltcHJvdmUgcmV1c2Ugb2YgY29kZSBhbmRcclxuICogYWxsb3cgdGhlIHVzZSBvZiBleGlzdGluZyBsaWJyYXJpZXMuXHJcbiAqXHJcbiAqIFVzYWdlOiBpbmNsdWRlKFwiWE1MSHR0cFJlcXVlc3QuanNcIikgYW5kIHVzZSBYTUxIdHRwUmVxdWVzdCBwZXIgVzNDIHNwZWNzLlxyXG4gKlxyXG4gKiBAYXV0aG9yIERhbiBEZUZlbGlwcGkgPGRhbkBkcml2ZXJkYW4uY29tPlxyXG4gKiBAY29udHJpYnV0b3IgRGF2aWQgRWxsaXMgPGQuZi5lbGxpc0BpZWVlLm9yZz5cclxuICogQGxpY2Vuc2UgTUlUXHJcbiAqL1xyXG5cclxudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcclxudmFyIFVybCA9IHJlcXVpcmUoJ3VybCcpO1xyXG52YXIgc3Bhd24gPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuc3Bhd247XHJcblxyXG4vKipcclxuICogTW9kdWxlIGV4cG9ydHMuXHJcbiAqL1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBYTUxIdHRwUmVxdWVzdDtcclxuXHJcbi8vIGJhY2t3YXJkcy1jb21wYXRcclxuWE1MSHR0cFJlcXVlc3QuWE1MSHR0cFJlcXVlc3QgPSBYTUxIdHRwUmVxdWVzdDtcclxuXHJcbi8qKlxyXG4gKiBgWE1MSHR0cFJlcXVlc3RgIGNvbnN0cnVjdG9yLlxyXG4gKlxyXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBmb3IgdGhlIGBvcHRzYCBvYmplY3QgYXJlOlxyXG4gKlxyXG4gKiAgLSBgYWdlbnRgOiBBbiBodHRwLkFnZW50IGluc3RhbmNlOyBodHRwLmdsb2JhbEFnZW50IG1heSBiZSB1c2VkOyBpZiAndW5kZWZpbmVkJywgYWdlbnQgdXNhZ2UgaXMgZGlzYWJsZWRcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgb3B0aW9uYWwgXCJvcHRpb25zXCIgb2JqZWN0XHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gWE1MSHR0cFJlcXVlc3Qob3B0cykge1xyXG4gIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICBvcHRzID0gb3B0cyB8fCB7fTtcclxuXHJcbiAgLyoqXHJcbiAgICogUHJpdmF0ZSB2YXJpYWJsZXNcclxuICAgKi9cclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgdmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XHJcbiAgdmFyIGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcclxuXHJcbiAgLy8gSG9sZHMgaHR0cC5qcyBvYmplY3RzXHJcbiAgdmFyIHJlcXVlc3Q7XHJcbiAgdmFyIHJlc3BvbnNlO1xyXG5cclxuICAvLyBSZXF1ZXN0IHNldHRpbmdzXHJcbiAgdmFyIHNldHRpbmdzID0ge307XHJcblxyXG4gIC8vIERpc2FibGUgaGVhZGVyIGJsYWNrbGlzdC5cclxuICAvLyBOb3QgcGFydCBvZiBYSFIgc3BlY3MuXHJcbiAgdmFyIGRpc2FibGVIZWFkZXJDaGVjayA9IGZhbHNlO1xyXG5cclxuICAvLyBTZXQgc29tZSBkZWZhdWx0IGhlYWRlcnNcclxuICB2YXIgZGVmYXVsdEhlYWRlcnMgPSB7XHJcbiAgICBcIlVzZXItQWdlbnRcIjogXCJub2RlLVhNTEh0dHBSZXF1ZXN0XCIsXHJcbiAgICBcIkFjY2VwdFwiOiBcIiovKlwiXHJcbiAgfTtcclxuXHJcbiAgdmFyIGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0SGVhZGVycyk7XHJcblxyXG4gIC8vIFRoZXNlIGhlYWRlcnMgYXJlIG5vdCB1c2VyIHNldGFibGUuXHJcbiAgLy8gVGhlIGZvbGxvd2luZyBhcmUgYWxsb3dlZCBidXQgYmFubmVkIGluIHRoZSBzcGVjOlxyXG4gIC8vICogdXNlci1hZ2VudFxyXG4gIHZhciBmb3JiaWRkZW5SZXF1ZXN0SGVhZGVycyA9IFtcclxuICAgIFwiYWNjZXB0LWNoYXJzZXRcIixcclxuICAgIFwiYWNjZXB0LWVuY29kaW5nXCIsXHJcbiAgICBcImFjY2Vzcy1jb250cm9sLXJlcXVlc3QtaGVhZGVyc1wiLFxyXG4gICAgXCJhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LW1ldGhvZFwiLFxyXG4gICAgXCJjb25uZWN0aW9uXCIsXHJcbiAgICBcImNvbnRlbnQtbGVuZ3RoXCIsXHJcbiAgICBcImNvbnRlbnQtdHJhbnNmZXItZW5jb2RpbmdcIixcclxuICAgIFwiY29va2llXCIsXHJcbiAgICBcImNvb2tpZTJcIixcclxuICAgIFwiZGF0ZVwiLFxyXG4gICAgXCJleHBlY3RcIixcclxuICAgIFwiaG9zdFwiLFxyXG4gICAgXCJrZWVwLWFsaXZlXCIsXHJcbiAgICBcIm9yaWdpblwiLFxyXG4gICAgXCJyZWZlcmVyXCIsXHJcbiAgICBcInRlXCIsXHJcbiAgICBcInRyYWlsZXJcIixcclxuICAgIFwidHJhbnNmZXItZW5jb2RpbmdcIixcclxuICAgIFwidXBncmFkZVwiLFxyXG4gICAgXCJ2aWFcIlxyXG4gIF07XHJcblxyXG4gIC8vIFRoZXNlIHJlcXVlc3QgbWV0aG9kcyBhcmUgbm90IGFsbG93ZWRcclxuICB2YXIgZm9yYmlkZGVuUmVxdWVzdE1ldGhvZHMgPSBbXHJcbiAgICBcIlRSQUNFXCIsXHJcbiAgICBcIlRSQUNLXCIsXHJcbiAgICBcIkNPTk5FQ1RcIlxyXG4gIF07XHJcblxyXG4gIC8vIFNlbmQgZmxhZ1xyXG4gIHZhciBzZW5kRmxhZyA9IGZhbHNlO1xyXG4gIC8vIEVycm9yIGZsYWcsIHVzZWQgd2hlbiBlcnJvcnMgb2NjdXIgb3IgYWJvcnQgaXMgY2FsbGVkXHJcbiAgdmFyIGVycm9yRmxhZyA9IGZhbHNlO1xyXG4gIHZhciBhYm9ydGVkRmxhZyA9IGZhbHNlO1xyXG5cclxuICAvLyBFdmVudCBsaXN0ZW5lcnNcclxuICB2YXIgbGlzdGVuZXJzID0ge307XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0YW50c1xyXG4gICAqL1xyXG5cclxuICB0aGlzLlVOU0VOVCA9IDA7XHJcbiAgdGhpcy5PUEVORUQgPSAxO1xyXG4gIHRoaXMuSEVBREVSU19SRUNFSVZFRCA9IDI7XHJcbiAgdGhpcy5MT0FESU5HID0gMztcclxuICB0aGlzLkRPTkUgPSA0O1xyXG5cclxuICAvKipcclxuICAgKiBQdWJsaWMgdmFyc1xyXG4gICAqL1xyXG5cclxuICAvLyBDdXJyZW50IHN0YXRlXHJcbiAgdGhpcy5yZWFkeVN0YXRlID0gdGhpcy5VTlNFTlQ7XHJcblxyXG4gIC8vIGRlZmF1bHQgcmVhZHkgc3RhdGUgY2hhbmdlIGhhbmRsZXIgaW4gY2FzZSBvbmUgaXMgbm90IHNldCBvciBpcyBzZXQgbGF0ZVxyXG4gIHRoaXMub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcclxuXHJcbiAgLy8gUmVzdWx0ICYgcmVzcG9uc2VcclxuICB0aGlzLnJlc3BvbnNlVGV4dCA9IFwiXCI7XHJcbiAgdGhpcy5yZXNwb25zZVhNTCA9IFwiXCI7XHJcbiAgdGhpcy5zdGF0dXMgPSBudWxsO1xyXG4gIHRoaXMuc3RhdHVzVGV4dCA9IG51bGw7XHJcblxyXG4gIC8qKlxyXG4gICAqIFByaXZhdGUgbWV0aG9kc1xyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgc3BlY2lmaWVkIGhlYWRlciBpcyBhbGxvd2VkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHN0cmluZyBoZWFkZXIgSGVhZGVyIHRvIHZhbGlkYXRlXHJcbiAgICogQHJldHVybiBib29sZWFuIEZhbHNlIGlmIG5vdCBhbGxvd2VkLCBvdGhlcndpc2UgdHJ1ZVxyXG4gICAqL1xyXG4gIHZhciBpc0FsbG93ZWRIdHRwSGVhZGVyID0gZnVuY3Rpb24oaGVhZGVyKSB7XHJcbiAgICByZXR1cm4gZGlzYWJsZUhlYWRlckNoZWNrIHx8IChoZWFkZXIgJiYgZm9yYmlkZGVuUmVxdWVzdEhlYWRlcnMuaW5kZXhPZihoZWFkZXIudG9Mb3dlckNhc2UoKSkgPT09IC0xKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgc3BlY2lmaWVkIG1ldGhvZCBpcyBhbGxvd2VkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHN0cmluZyBtZXRob2QgUmVxdWVzdCBtZXRob2QgdG8gdmFsaWRhdGVcclxuICAgKiBAcmV0dXJuIGJvb2xlYW4gRmFsc2UgaWYgbm90IGFsbG93ZWQsIG90aGVyd2lzZSB0cnVlXHJcbiAgICovXHJcbiAgdmFyIGlzQWxsb3dlZEh0dHBNZXRob2QgPSBmdW5jdGlvbihtZXRob2QpIHtcclxuICAgIHJldHVybiAobWV0aG9kICYmIGZvcmJpZGRlblJlcXVlc3RNZXRob2RzLmluZGV4T2YobWV0aG9kKSA9PT0gLTEpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFB1YmxpYyBtZXRob2RzXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIE9wZW4gdGhlIGNvbm5lY3Rpb24uIEN1cnJlbnRseSBzdXBwb3J0cyBsb2NhbCBzZXJ2ZXIgcmVxdWVzdHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gc3RyaW5nIG1ldGhvZCBDb25uZWN0aW9uIG1ldGhvZCAoZWcgR0VULCBQT1NUKVxyXG4gICAqIEBwYXJhbSBzdHJpbmcgdXJsIFVSTCBmb3IgdGhlIGNvbm5lY3Rpb24uXHJcbiAgICogQHBhcmFtIGJvb2xlYW4gYXN5bmMgQXN5bmNocm9ub3VzIGNvbm5lY3Rpb24uIERlZmF1bHQgaXMgdHJ1ZS5cclxuICAgKiBAcGFyYW0gc3RyaW5nIHVzZXIgVXNlcm5hbWUgZm9yIGJhc2ljIGF1dGhlbnRpY2F0aW9uIChvcHRpb25hbClcclxuICAgKiBAcGFyYW0gc3RyaW5nIHBhc3N3b3JkIFBhc3N3b3JkIGZvciBiYXNpYyBhdXRoZW50aWNhdGlvbiAob3B0aW9uYWwpXHJcbiAgICovXHJcbiAgdGhpcy5vcGVuID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIGFzeW5jLCB1c2VyLCBwYXNzd29yZCkge1xyXG4gICAgdGhpcy5hYm9ydCgpO1xyXG4gICAgZXJyb3JGbGFnID0gZmFsc2U7XHJcbiAgICBhYm9ydGVkRmxhZyA9IGZhbHNlO1xyXG5cclxuICAgIC8vIENoZWNrIGZvciB2YWxpZCByZXF1ZXN0IG1ldGhvZFxyXG4gICAgaWYgKCFpc0FsbG93ZWRIdHRwTWV0aG9kKG1ldGhvZCkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VjdXJpdHlFcnJvcjogUmVxdWVzdCBtZXRob2Qgbm90IGFsbG93ZWRcIik7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0dGluZ3MgPSB7XHJcbiAgICAgIFwibWV0aG9kXCI6IG1ldGhvZCxcclxuICAgICAgXCJ1cmxcIjogdXJsLnRvU3RyaW5nKCksXHJcbiAgICAgIFwiYXN5bmNcIjogKHR5cGVvZiBhc3luYyAhPT0gXCJib29sZWFuXCIgPyB0cnVlIDogYXN5bmMpLFxyXG4gICAgICBcInVzZXJcIjogdXNlciB8fCBudWxsLFxyXG4gICAgICBcInBhc3N3b3JkXCI6IHBhc3N3b3JkIHx8IG51bGxcclxuICAgIH07XHJcblxyXG4gICAgc2V0U3RhdGUodGhpcy5PUEVORUQpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc2FibGVzIG9yIGVuYWJsZXMgaXNBbGxvd2VkSHR0cEhlYWRlcigpIGNoZWNrIHRoZSByZXF1ZXN0LiBFbmFibGVkIGJ5IGRlZmF1bHQuXHJcbiAgICogVGhpcyBkb2VzIG5vdCBjb25mb3JtIHRvIHRoZSBXM0Mgc3BlYy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBib29sZWFuIHN0YXRlIEVuYWJsZSBvciBkaXNhYmxlIGhlYWRlciBjaGVja2luZy5cclxuICAgKi9cclxuICB0aGlzLnNldERpc2FibGVIZWFkZXJDaGVjayA9IGZ1bmN0aW9uKHN0YXRlKSB7XHJcbiAgICBkaXNhYmxlSGVhZGVyQ2hlY2sgPSBzdGF0ZTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBTZXRzIGEgaGVhZGVyIGZvciB0aGUgcmVxdWVzdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBzdHJpbmcgaGVhZGVyIEhlYWRlciBuYW1lXHJcbiAgICogQHBhcmFtIHN0cmluZyB2YWx1ZSBIZWFkZXIgdmFsdWVcclxuICAgKiBAcmV0dXJuIGJvb2xlYW4gSGVhZGVyIGFkZGVkXHJcbiAgICovXHJcbiAgdGhpcy5zZXRSZXF1ZXN0SGVhZGVyID0gZnVuY3Rpb24oaGVhZGVyLCB2YWx1ZSkge1xyXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPSB0aGlzLk9QRU5FRCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJTlZBTElEX1NUQVRFX0VSUjogc2V0UmVxdWVzdEhlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgd2hlbiBzdGF0ZSBpcyBPUEVOXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0FsbG93ZWRIdHRwSGVhZGVyKGhlYWRlcikpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdSZWZ1c2VkIHRvIHNldCB1bnNhZmUgaGVhZGVyIFwiJyArIGhlYWRlciArICdcIicpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoc2VuZEZsYWcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSU5WQUxJRF9TVEFURV9FUlI6IHNlbmQgZmxhZyBpcyB0cnVlXCIpO1xyXG4gICAgfVxyXG4gICAgaGVhZGVyc1toZWFkZXJdID0gdmFsdWU7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGEgaGVhZGVyIGZyb20gdGhlIHNlcnZlciByZXNwb25zZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBzdHJpbmcgaGVhZGVyIE5hbWUgb2YgaGVhZGVyIHRvIGdldC5cclxuICAgKiBAcmV0dXJuIHN0cmluZyBUZXh0IG9mIHRoZSBoZWFkZXIgb3IgbnVsbCBpZiBpdCBkb2Vzbid0IGV4aXN0LlxyXG4gICAqL1xyXG4gIHRoaXMuZ2V0UmVzcG9uc2VIZWFkZXIgPSBmdW5jdGlvbihoZWFkZXIpIHtcclxuICAgIGlmICh0eXBlb2YgaGVhZGVyID09PSBcInN0cmluZ1wiXHJcbiAgICAgICYmIHRoaXMucmVhZHlTdGF0ZSA+IHRoaXMuT1BFTkVEXHJcbiAgICAgICYmIHJlc3BvbnNlLmhlYWRlcnNbaGVhZGVyLnRvTG93ZXJDYXNlKCldXHJcbiAgICAgICYmICFlcnJvckZsYWdcclxuICAgICkge1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuaGVhZGVyc1toZWFkZXIudG9Mb3dlckNhc2UoKV07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbGwgdGhlIHJlc3BvbnNlIGhlYWRlcnMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHN0cmluZyBBIHN0cmluZyB3aXRoIGFsbCByZXNwb25zZSBoZWFkZXJzIHNlcGFyYXRlZCBieSBDUitMRlxyXG4gICAqL1xyXG4gIHRoaXMuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlIDwgdGhpcy5IRUFERVJTX1JFQ0VJVkVEIHx8IGVycm9yRmxhZykge1xyXG4gICAgICByZXR1cm4gXCJcIjtcclxuICAgIH1cclxuICAgIHZhciByZXN1bHQgPSBcIlwiO1xyXG5cclxuICAgIGZvciAodmFyIGkgaW4gcmVzcG9uc2UuaGVhZGVycykge1xyXG4gICAgICAvLyBDb29raWUgaGVhZGVycyBhcmUgZXhjbHVkZWRcclxuICAgICAgaWYgKGkgIT09IFwic2V0LWNvb2tpZVwiICYmIGkgIT09IFwic2V0LWNvb2tpZTJcIikge1xyXG4gICAgICAgIHJlc3VsdCArPSBpICsgXCI6IFwiICsgcmVzcG9uc2UuaGVhZGVyc1tpXSArIFwiXFxyXFxuXCI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQuc3Vic3RyKDAsIHJlc3VsdC5sZW5ndGggLSAyKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGEgcmVxdWVzdCBoZWFkZXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSBzdHJpbmcgbmFtZSBOYW1lIG9mIGhlYWRlciB0byBnZXRcclxuICAgKiBAcmV0dXJuIHN0cmluZyBSZXR1cm5zIHRoZSByZXF1ZXN0IGhlYWRlciBvciBlbXB0eSBzdHJpbmcgaWYgbm90IHNldFxyXG4gICAqL1xyXG4gIHRoaXMuZ2V0UmVxdWVzdEhlYWRlciA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgIC8vIEBUT0RPIE1ha2UgdGhpcyBjYXNlIGluc2Vuc2l0aXZlXHJcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgJiYgaGVhZGVyc1tuYW1lXSkge1xyXG4gICAgICByZXR1cm4gaGVhZGVyc1tuYW1lXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gXCJcIjtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBTZW5kcyB0aGUgcmVxdWVzdCB0byB0aGUgc2VydmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHN0cmluZyBkYXRhIE9wdGlvbmFsIGRhdGEgdG8gc2VuZCBhcyByZXF1ZXN0IGJvZHkuXHJcbiAgICovXHJcbiAgdGhpcy5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPSB0aGlzLk9QRU5FRCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJTlZBTElEX1NUQVRFX0VSUjogY29ubmVjdGlvbiBtdXN0IGJlIG9wZW5lZCBiZWZvcmUgc2VuZCgpIGlzIGNhbGxlZFwiKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2VuZEZsYWcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSU5WQUxJRF9TVEFURV9FUlI6IHNlbmQgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWRcIik7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNzbCA9IGZhbHNlLCBsb2NhbCA9IGZhbHNlO1xyXG4gICAgdmFyIHVybCA9IFVybC5wYXJzZShzZXR0aW5ncy51cmwpO1xyXG4gICAgdmFyIGhvc3Q7XHJcbiAgICAvLyBEZXRlcm1pbmUgdGhlIHNlcnZlclxyXG4gICAgc3dpdGNoICh1cmwucHJvdG9jb2wpIHtcclxuICAgICAgY2FzZSAnaHR0cHM6JzpcclxuICAgICAgICBzc2wgPSB0cnVlO1xyXG4gICAgICAgIC8vIFNTTCAmIG5vbi1TU0wgYm90aCBuZWVkIGhvc3QsIG5vIGJyZWFrIGhlcmUuXHJcbiAgICAgIGNhc2UgJ2h0dHA6JzpcclxuICAgICAgICBob3N0ID0gdXJsLmhvc3RuYW1lO1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSAnZmlsZTonOlxyXG4gICAgICAgIGxvY2FsID0gdHJ1ZTtcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxyXG4gICAgICBjYXNlICcnOlxyXG4gICAgICAgIGhvc3QgPSBcImxvY2FsaG9zdFwiO1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm90b2NvbCBub3Qgc3VwcG9ydGVkLlwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBMb2FkIGZpbGVzIG9mZiB0aGUgbG9jYWwgZmlsZXN5c3RlbSAoZmlsZTovLylcclxuICAgIGlmIChsb2NhbCkge1xyXG4gICAgICBpZiAoc2V0dGluZ3MubWV0aG9kICE9PSBcIkdFVFwiKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWE1MSHR0cFJlcXVlc3Q6IE9ubHkgR0VUIG1ldGhvZCBpcyBzdXBwb3J0ZWRcIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzZXR0aW5ncy5hc3luYykge1xyXG4gICAgICAgIGZzLnJlYWRGaWxlKHVuZXNjYXBlKHVybC5wYXRobmFtZSksICd1dGY4JywgZnVuY3Rpb24oZXJyb3IsIGRhdGEpIHtcclxuICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICBzZWxmLmhhbmRsZUVycm9yKGVycm9yLCBlcnJvci5lcnJubyB8fCAtMSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZWxmLnN0YXR1cyA9IDIwMDtcclxuICAgICAgICAgICAgc2VsZi5yZXNwb25zZVRleHQgPSBkYXRhO1xyXG4gICAgICAgICAgICBzZXRTdGF0ZShzZWxmLkRPTkUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IGZzLnJlYWRGaWxlU3luYyh1bmVzY2FwZSh1cmwucGF0aG5hbWUpLCAndXRmOCcpO1xyXG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSAyMDA7XHJcbiAgICAgICAgICBzZXRTdGF0ZShzZWxmLkRPTkUpO1xyXG4gICAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlLCBlLmVycm5vIHx8IC0xKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZWZhdWx0IHRvIHBvcnQgODAuIElmIGFjY2Vzc2luZyBsb2NhbGhvc3Qgb24gYW5vdGhlciBwb3J0IGJlIHN1cmVcclxuICAgIC8vIHRvIHVzZSBodHRwOi8vbG9jYWxob3N0OnBvcnQvcGF0aFxyXG4gICAgdmFyIHBvcnQgPSB1cmwucG9ydCB8fCAoc3NsID8gNDQzIDogODApO1xyXG4gICAgLy8gQWRkIHF1ZXJ5IHN0cmluZyBpZiBvbmUgaXMgdXNlZFxyXG4gICAgdmFyIHVyaSA9IHVybC5wYXRobmFtZSArICh1cmwuc2VhcmNoID8gdXJsLnNlYXJjaCA6ICcnKTtcclxuXHJcbiAgICAvLyBTZXQgdGhlIEhvc3QgaGVhZGVyIG9yIHRoZSBzZXJ2ZXIgbWF5IHJlamVjdCB0aGUgcmVxdWVzdFxyXG4gICAgaGVhZGVyc1tcIkhvc3RcIl0gPSBob3N0O1xyXG4gICAgaWYgKCEoKHNzbCAmJiBwb3J0ID09PSA0NDMpIHx8IHBvcnQgPT09IDgwKSkge1xyXG4gICAgICBoZWFkZXJzW1wiSG9zdFwiXSArPSAnOicgKyB1cmwucG9ydDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXQgQmFzaWMgQXV0aCBpZiBuZWNlc3NhcnlcclxuICAgIGlmIChzZXR0aW5ncy51c2VyKSB7XHJcbiAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MucGFzc3dvcmQgPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgIHNldHRpbmdzLnBhc3N3b3JkID0gXCJcIjtcclxuICAgICAgfVxyXG4gICAgICB2YXIgYXV0aEJ1ZiA9IG5ldyBCdWZmZXIoc2V0dGluZ3MudXNlciArIFwiOlwiICsgc2V0dGluZ3MucGFzc3dvcmQpO1xyXG4gICAgICBoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IFwiQmFzaWMgXCIgKyBhdXRoQnVmLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNldCBjb250ZW50IGxlbmd0aCBoZWFkZXJcclxuICAgIGlmIChzZXR0aW5ncy5tZXRob2QgPT09IFwiR0VUXCIgfHwgc2V0dGluZ3MubWV0aG9kID09PSBcIkhFQURcIikge1xyXG4gICAgICBkYXRhID0gbnVsbDtcclxuICAgIH0gZWxzZSBpZiAoZGF0YSkge1xyXG4gICAgICBoZWFkZXJzW1wiQ29udGVudC1MZW5ndGhcIl0gPSBCdWZmZXIuaXNCdWZmZXIoZGF0YSkgPyBkYXRhLmxlbmd0aCA6IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xyXG5cclxuICAgICAgaWYgKCFoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdKSB7XHJcbiAgICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwidGV4dC9wbGFpbjtjaGFyc2V0PVVURi04XCI7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MubWV0aG9kID09PSBcIlBPU1RcIikge1xyXG4gICAgICAvLyBGb3IgYSBwb3N0IHdpdGggbm8gZGF0YSBzZXQgQ29udGVudC1MZW5ndGg6IDAuXHJcbiAgICAgIC8vIFRoaXMgaXMgcmVxdWlyZWQgYnkgYnVnZ3kgc2VydmVycyB0aGF0IGRvbid0IG1lZXQgdGhlIHNwZWNzLlxyXG4gICAgICBoZWFkZXJzW1wiQ29udGVudC1MZW5ndGhcIl0gPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBhZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XHJcbiAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgaG9zdDogaG9zdCxcclxuICAgICAgcG9ydDogcG9ydCxcclxuICAgICAgcGF0aDogdXJpLFxyXG4gICAgICBtZXRob2Q6IHNldHRpbmdzLm1ldGhvZCxcclxuICAgICAgaGVhZGVyczogaGVhZGVycyxcclxuICAgICAgYWdlbnQ6IGFnZW50XHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChzc2wpIHtcclxuICAgICAgb3B0aW9ucy5wZnggPSBvcHRzLnBmeDtcclxuICAgICAgb3B0aW9ucy5rZXkgPSBvcHRzLmtleTtcclxuICAgICAgb3B0aW9ucy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xyXG4gICAgICBvcHRpb25zLmNlcnQgPSBvcHRzLmNlcnQ7XHJcbiAgICAgIG9wdGlvbnMuY2EgPSBvcHRzLmNhO1xyXG4gICAgICBvcHRpb25zLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XHJcbiAgICAgIG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlc2V0IGVycm9yIGZsYWdcclxuICAgIGVycm9yRmxhZyA9IGZhbHNlO1xyXG4gICAgLy8gSGFuZGxlIGFzeW5jIHJlcXVlc3RzXHJcbiAgICBpZiAoc2V0dGluZ3MuYXN5bmMpIHtcclxuICAgICAgLy8gVXNlIHRoZSBwcm9wZXIgcHJvdG9jb2xcclxuICAgICAgdmFyIGRvUmVxdWVzdCA9IHNzbCA/IGh0dHBzLnJlcXVlc3QgOiBodHRwLnJlcXVlc3Q7XHJcblxyXG4gICAgICAvLyBSZXF1ZXN0IGlzIGJlaW5nIHNlbnQsIHNldCBzZW5kIGZsYWdcclxuICAgICAgc2VuZEZsYWcgPSB0cnVlO1xyXG5cclxuICAgICAgLy8gQXMgcGVyIHNwZWMsIHRoaXMgaXMgY2FsbGVkIGhlcmUgZm9yIGhpc3RvcmljYWwgcmVhc29ucy5cclxuICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwicmVhZHlzdGF0ZWNoYW5nZVwiKTtcclxuXHJcbiAgICAgIC8vIEhhbmRsZXIgZm9yIHRoZSByZXNwb25zZVxyXG4gICAgICB2YXIgcmVzcG9uc2VIYW5kbGVyID0gZnVuY3Rpb24ocmVzcCkge1xyXG4gICAgICAgIC8vIFNldCByZXNwb25zZSB2YXIgdG8gdGhlIHJlc3BvbnNlIHdlIGdvdCBiYWNrXHJcbiAgICAgICAgLy8gVGhpcyBpcyBzbyBpdCByZW1haW5zIGFjY2Vzc2FibGUgb3V0c2lkZSB0aGlzIHNjb3BlXHJcbiAgICAgICAgcmVzcG9uc2UgPSByZXNwO1xyXG4gICAgICAgIC8vIENoZWNrIGZvciByZWRpcmVjdFxyXG4gICAgICAgIC8vIEBUT0RPIFByZXZlbnQgbG9vcGVkIHJlZGlyZWN0c1xyXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDIgfHwgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAzIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwNykge1xyXG4gICAgICAgICAgLy8gQ2hhbmdlIFVSTCB0byB0aGUgcmVkaXJlY3QgbG9jYXRpb25cclxuICAgICAgICAgIHNldHRpbmdzLnVybCA9IHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb247XHJcbiAgICAgICAgICB2YXIgdXJsID0gVXJsLnBhcnNlKHNldHRpbmdzLnVybCk7XHJcbiAgICAgICAgICAvLyBTZXQgaG9zdCB2YXIgaW4gY2FzZSBpdCdzIHVzZWQgbGF0ZXJcclxuICAgICAgICAgIGhvc3QgPSB1cmwuaG9zdG5hbWU7XHJcbiAgICAgICAgICAvLyBPcHRpb25zIGZvciB0aGUgbmV3IHJlcXVlc3RcclxuICAgICAgICAgIHZhciBuZXdPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBob3N0bmFtZTogdXJsLmhvc3RuYW1lLFxyXG4gICAgICAgICAgICBwb3J0OiB1cmwucG9ydCxcclxuICAgICAgICAgICAgcGF0aDogdXJsLnBhdGgsXHJcbiAgICAgICAgICAgIG1ldGhvZDogcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAzID8gJ0dFVCcgOiBzZXR0aW5ncy5tZXRob2QsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgaWYgKHNzbCkge1xyXG4gICAgICAgICAgICBuZXdPcHRpb25zLnBmeCA9IG9wdHMucGZ4O1xyXG4gICAgICAgICAgICBuZXdPcHRpb25zLmtleSA9IG9wdHMua2V5O1xyXG4gICAgICAgICAgICBuZXdPcHRpb25zLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XHJcbiAgICAgICAgICAgIG5ld09wdGlvbnMuY2VydCA9IG9wdHMuY2VydDtcclxuICAgICAgICAgICAgbmV3T3B0aW9ucy5jYSA9IG9wdHMuY2E7XHJcbiAgICAgICAgICAgIG5ld09wdGlvbnMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcclxuICAgICAgICAgICAgbmV3T3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gSXNzdWUgdGhlIG5ldyByZXF1ZXN0XHJcbiAgICAgICAgICByZXF1ZXN0ID0gZG9SZXF1ZXN0KG5ld09wdGlvbnMsIHJlc3BvbnNlSGFuZGxlcikub24oJ2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcclxuICAgICAgICAgIHJlcXVlc3QuZW5kKCk7XHJcbiAgICAgICAgICAvLyBAVE9ETyBDaGVjayBpZiBhbiBYSFIgZXZlbnQgbmVlZHMgdG8gYmUgZmlyZWQgaGVyZVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLnNldEVuY29kaW5nKSB7XHJcbiAgICAgICAgICByZXNwb25zZS5zZXRFbmNvZGluZyhcInV0ZjhcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZXRTdGF0ZShzZWxmLkhFQURFUlNfUkVDRUlWRUQpO1xyXG4gICAgICAgIHNlbGYuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzQ29kZTtcclxuXHJcbiAgICAgICAgcmVzcG9uc2Uub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1xyXG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZXJlJ3Mgc29tZSBkYXRhXHJcbiAgICAgICAgICBpZiAoY2h1bmspIHtcclxuICAgICAgICAgICAgc2VsZi5yZXNwb25zZVRleHQgKz0gY2h1bms7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBEb24ndCBlbWl0IHN0YXRlIGNoYW5nZXMgaWYgdGhlIGNvbm5lY3Rpb24gaGFzIGJlZW4gYWJvcnRlZC5cclxuICAgICAgICAgIGlmIChzZW5kRmxhZykge1xyXG4gICAgICAgICAgICBzZXRTdGF0ZShzZWxmLkxPQURJTkcpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXNwb25zZS5vbignZW5kJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBpZiAoc2VuZEZsYWcpIHtcclxuICAgICAgICAgICAgLy8gVGhlIHNlbmRGbGFnIG5lZWRzIHRvIGJlIHNldCBiZWZvcmUgc2V0U3RhdGUgaXMgY2FsbGVkLiAgT3RoZXJ3aXNlIGlmIHdlIGFyZSBjaGFpbmluZyBjYWxsYmFja3NcclxuICAgICAgICAgICAgLy8gdGhlcmUgY2FuIGJlIGEgdGltaW5nIGlzc3VlICh0aGUgY2FsbGJhY2sgaXMgY2FsbGVkIGFuZCBhIG5ldyBjYWxsIGlzIG1hZGUgYmVmb3JlIHRoZSBmbGFnIGlzIHJlc2V0KS5cclxuICAgICAgICAgICAgc2VuZEZsYWcgPSBmYWxzZTtcclxuICAgICAgICAgICAgLy8gRGlzY2FyZCB0aGUgJ2VuZCcgZXZlbnQgaWYgdGhlIGNvbm5lY3Rpb24gaGFzIGJlZW4gYWJvcnRlZFxyXG4gICAgICAgICAgICBzZXRTdGF0ZShzZWxmLkRPTkUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXNwb25zZS5vbignZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xyXG4gICAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEVycm9yIGhhbmRsZXIgZm9yIHRoZSByZXF1ZXN0XHJcbiAgICAgIHZhciBlcnJvckhhbmRsZXIgPSBmdW5jdGlvbihlcnJvcikge1xyXG4gICAgICAgIHNlbGYuaGFuZGxlRXJyb3IoZXJyb3IpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDcmVhdGUgdGhlIHJlcXVlc3RcclxuICAgICAgcmVxdWVzdCA9IGRvUmVxdWVzdChvcHRpb25zLCByZXNwb25zZUhhbmRsZXIpLm9uKCdlcnJvcicsIGVycm9ySGFuZGxlcik7XHJcblxyXG4gICAgICBpZiAob3B0cy5hdXRvVW5yZWYpIHtcclxuICAgICAgICByZXF1ZXN0Lm9uKCdzb2NrZXQnLCAoc29ja2V0KSA9PiB7XHJcbiAgICAgICAgICBzb2NrZXQudW5yZWYoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm9kZSAwLjQgYW5kIGxhdGVyIHdvbid0IGFjY2VwdCBlbXB0eSBkYXRhLiBNYWtlIHN1cmUgaXQncyBuZWVkZWQuXHJcbiAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgcmVxdWVzdC53cml0ZShkYXRhKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmVxdWVzdC5lbmQoKTtcclxuXHJcbiAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChcImxvYWRzdGFydFwiKTtcclxuICAgIH0gZWxzZSB7IC8vIFN5bmNocm9ub3VzXHJcbiAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBmaWxlIGZvciBjb21tdW5pY2F0aW9uIHdpdGggdGhlIG90aGVyIE5vZGUgcHJvY2Vzc1xyXG4gICAgICB2YXIgY29udGVudEZpbGUgPSBcIi5ub2RlLXhtbGh0dHByZXF1ZXN0LWNvbnRlbnQtXCIgKyBwcm9jZXNzLnBpZDtcclxuICAgICAgdmFyIHN5bmNGaWxlID0gXCIubm9kZS14bWxodHRwcmVxdWVzdC1zeW5jLVwiICsgcHJvY2Vzcy5waWQ7XHJcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMoc3luY0ZpbGUsIFwiXCIsIFwidXRmOFwiKTtcclxuICAgICAgLy8gVGhlIGFzeW5jIHJlcXVlc3QgdGhlIG90aGVyIE5vZGUgcHJvY2VzcyBleGVjdXRlc1xyXG4gICAgICB2YXIgZXhlY1N0cmluZyA9IFwidmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyksIGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKSwgZnMgPSByZXF1aXJlKCdmcycpO1wiXHJcbiAgICAgICAgKyBcInZhciBkb1JlcXVlc3QgPSBodHRwXCIgKyAoc3NsID8gXCJzXCIgOiBcIlwiKSArIFwiLnJlcXVlc3Q7XCJcclxuICAgICAgICArIFwidmFyIG9wdGlvbnMgPSBcIiArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpICsgXCI7XCJcclxuICAgICAgICArIFwidmFyIHJlc3BvbnNlVGV4dCA9ICcnO1wiXHJcbiAgICAgICAgKyBcInZhciByZXEgPSBkb1JlcXVlc3Qob3B0aW9ucywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcIlxyXG4gICAgICAgICsgXCJyZXNwb25zZS5zZXRFbmNvZGluZygndXRmOCcpO1wiXHJcbiAgICAgICAgKyBcInJlc3BvbnNlLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcIlxyXG4gICAgICAgICsgXCIgIHJlc3BvbnNlVGV4dCArPSBjaHVuaztcIlxyXG4gICAgICAgICsgXCJ9KTtcIlxyXG4gICAgICAgICsgXCJyZXNwb25zZS5vbignZW5kJywgZnVuY3Rpb24oKSB7XCJcclxuICAgICAgICArIFwiZnMud3JpdGVGaWxlU3luYygnXCIgKyBjb250ZW50RmlsZSArIFwiJywgJ05PREUtWE1MSFRUUFJFUVVFU1QtU1RBVFVTOicgKyByZXNwb25zZS5zdGF0dXNDb2RlICsgJywnICsgcmVzcG9uc2VUZXh0LCAndXRmOCcpO1wiXHJcbiAgICAgICAgKyBcImZzLnVubGlua1N5bmMoJ1wiICsgc3luY0ZpbGUgKyBcIicpO1wiXHJcbiAgICAgICAgKyBcIn0pO1wiXHJcbiAgICAgICAgKyBcInJlc3BvbnNlLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XCJcclxuICAgICAgICArIFwiZnMud3JpdGVGaWxlU3luYygnXCIgKyBjb250ZW50RmlsZSArIFwiJywgJ05PREUtWE1MSFRUUFJFUVVFU1QtRVJST1I6JyArIEpTT04uc3RyaW5naWZ5KGVycm9yKSwgJ3V0ZjgnKTtcIlxyXG4gICAgICAgICsgXCJmcy51bmxpbmtTeW5jKCdcIiArIHN5bmNGaWxlICsgXCInKTtcIlxyXG4gICAgICAgICsgXCJ9KTtcIlxyXG4gICAgICAgICsgXCJ9KS5vbignZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1wiXHJcbiAgICAgICAgKyBcImZzLndyaXRlRmlsZVN5bmMoJ1wiICsgY29udGVudEZpbGUgKyBcIicsICdOT0RFLVhNTEhUVFBSRVFVRVNULUVSUk9SOicgKyBKU09OLnN0cmluZ2lmeShlcnJvciksICd1dGY4Jyk7XCJcclxuICAgICAgICArIFwiZnMudW5saW5rU3luYygnXCIgKyBzeW5jRmlsZSArIFwiJyk7XCJcclxuICAgICAgICArIFwifSk7XCJcclxuICAgICAgICArIChkYXRhID8gXCJyZXEud3JpdGUoJ1wiICsgSlNPTi5zdHJpbmdpZnkoZGF0YSkuc2xpY2UoMSwtMSkucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpICsgXCInKTtcIjpcIlwiKVxyXG4gICAgICAgICsgXCJyZXEuZW5kKCk7XCI7XHJcbiAgICAgIC8vIFN0YXJ0IHRoZSBvdGhlciBOb2RlIFByb2Nlc3MsIGV4ZWN1dGluZyB0aGlzIHN0cmluZ1xyXG4gICAgICB2YXIgc3luY1Byb2MgPSBzcGF3bihwcm9jZXNzLmFyZ3ZbMF0sIFtcIi1lXCIsIGV4ZWNTdHJpbmddKTtcclxuICAgICAgdmFyIHN0YXR1c1RleHQ7XHJcbiAgICAgIHdoaWxlKGZzLmV4aXN0c1N5bmMoc3luY0ZpbGUpKSB7XHJcbiAgICAgICAgLy8gV2FpdCB3aGlsZSB0aGUgc3luYyBmaWxlIGlzIGVtcHR5XHJcbiAgICAgIH1cclxuICAgICAgc2VsZi5yZXNwb25zZVRleHQgPSBmcy5yZWFkRmlsZVN5bmMoY29udGVudEZpbGUsICd1dGY4Jyk7XHJcbiAgICAgIC8vIEtpbGwgdGhlIGNoaWxkIHByb2Nlc3Mgb25jZSB0aGUgZmlsZSBoYXMgZGF0YVxyXG4gICAgICBzeW5jUHJvYy5zdGRpbi5lbmQoKTtcclxuICAgICAgLy8gUmVtb3ZlIHRoZSB0ZW1wb3JhcnkgZmlsZVxyXG4gICAgICBmcy51bmxpbmtTeW5jKGNvbnRlbnRGaWxlKTtcclxuICAgICAgaWYgKHNlbGYucmVzcG9uc2VUZXh0Lm1hdGNoKC9eTk9ERS1YTUxIVFRQUkVRVUVTVC1FUlJPUjovKSkge1xyXG4gICAgICAgIC8vIElmIHRoZSBmaWxlIHJldHVybmVkIGFuIGVycm9yLCBoYW5kbGUgaXRcclxuICAgICAgICB2YXIgZXJyb3JPYmogPSBzZWxmLnJlc3BvbnNlVGV4dC5yZXBsYWNlKC9eTk9ERS1YTUxIVFRQUkVRVUVTVC1FUlJPUjovLCBcIlwiKTtcclxuICAgICAgICBzZWxmLmhhbmRsZUVycm9yKGVycm9yT2JqLCA1MDMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIElmIHRoZSBmaWxlIHJldHVybmVkIG9rYXksIHBhcnNlIGl0cyBkYXRhIGFuZCBtb3ZlIHRvIHRoZSBET05FIHN0YXRlXHJcbiAgICAgICAgc2VsZi5zdGF0dXMgPSBzZWxmLnJlc3BvbnNlVGV4dC5yZXBsYWNlKC9eTk9ERS1YTUxIVFRQUkVRVUVTVC1TVEFUVVM6KFswLTldKiksLiovLCBcIiQxXCIpO1xyXG4gICAgICAgIHNlbGYucmVzcG9uc2VUZXh0ID0gc2VsZi5yZXNwb25zZVRleHQucmVwbGFjZSgvXk5PREUtWE1MSFRUUFJFUVVFU1QtU1RBVFVTOlswLTldKiwoLiopLywgXCIkMVwiKTtcclxuICAgICAgICBzZXRTdGF0ZShzZWxmLkRPTkUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGVkIHdoZW4gYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQgdG8gZGVhbCB3aXRoIGl0LlxyXG4gICAqIEBwYXJhbSAgc3RhdHVzICB7bnVtYmVyfSAgICBIVFRQIHN0YXR1cyBjb2RlIHRvIHVzZSByYXRoZXIgdGhhbiB0aGUgZGVmYXVsdCAoMCkgZm9yIFhIUiBlcnJvcnMuXHJcbiAgICovXHJcbiAgdGhpcy5oYW5kbGVFcnJvciA9IGZ1bmN0aW9uKGVycm9yLCBzdGF0dXMpIHtcclxuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzIHx8IDA7XHJcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBlcnJvcjtcclxuICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gZXJyb3Iuc3RhY2s7XHJcbiAgICBlcnJvckZsYWcgPSB0cnVlO1xyXG4gICAgc2V0U3RhdGUodGhpcy5ET05FKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBBYm9ydHMgYSByZXF1ZXN0LlxyXG4gICAqL1xyXG4gIHRoaXMuYWJvcnQgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmIChyZXF1ZXN0KSB7XHJcbiAgICAgIHJlcXVlc3QuYWJvcnQoKTtcclxuICAgICAgcmVxdWVzdCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRIZWFkZXJzKTtcclxuICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gXCJcIjtcclxuICAgIHRoaXMucmVzcG9uc2VYTUwgPSBcIlwiO1xyXG5cclxuICAgIGVycm9yRmxhZyA9IGFib3J0ZWRGbGFnID0gdHJ1ZVxyXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gdGhpcy5VTlNFTlRcclxuICAgICAgICAmJiAodGhpcy5yZWFkeVN0YXRlICE9PSB0aGlzLk9QRU5FRCB8fCBzZW5kRmxhZylcclxuICAgICAgICAmJiB0aGlzLnJlYWR5U3RhdGUgIT09IHRoaXMuRE9ORSkge1xyXG4gICAgICBzZW5kRmxhZyA9IGZhbHNlO1xyXG4gICAgICBzZXRTdGF0ZSh0aGlzLkRPTkUpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gdGhpcy5VTlNFTlQ7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lci4gUHJlZmVycmVkIG1ldGhvZCBvZiBiaW5kaW5nIHRvIGV2ZW50cy5cclxuICAgKi9cclxuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgY2FsbGJhY2spIHtcclxuICAgIGlmICghKGV2ZW50IGluIGxpc3RlbmVycykpIHtcclxuICAgICAgbGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xyXG4gICAgfVxyXG4gICAgLy8gQ3VycmVudGx5IGFsbG93cyBkdXBsaWNhdGUgY2FsbGJhY2tzLiBTaG91bGQgaXQ/XHJcbiAgICBsaXN0ZW5lcnNbZXZlbnRdLnB1c2goY2FsbGJhY2spO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhbiBldmVudCBjYWxsYmFjayB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gYm91bmQuXHJcbiAgICogT25seSB3b3JrcyBvbiB0aGUgbWF0Y2hpbmcgZnVuY2l0b24sIGNhbm5vdCBiZSBhIGNvcHkuXHJcbiAgICovXHJcbiAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoZXZlbnQgaW4gbGlzdGVuZXJzKSB7XHJcbiAgICAgIC8vIEZpbHRlciB3aWxsIHJldHVybiBhIG5ldyBhcnJheSB3aXRoIHRoZSBjYWxsYmFjayByZW1vdmVkXHJcbiAgICAgIGxpc3RlbmVyc1tldmVudF0gPSBsaXN0ZW5lcnNbZXZlbnRdLmZpbHRlcihmdW5jdGlvbihldikge1xyXG4gICAgICAgIHJldHVybiBldiAhPT0gY2FsbGJhY2s7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3BhdGNoIGFueSBldmVudHMsIGluY2x1ZGluZyBib3RoIFwib25cIiBtZXRob2RzIGFuZCBldmVudHMgYXR0YWNoZWQgdXNpbmcgYWRkRXZlbnRMaXN0ZW5lci5cclxuICAgKi9cclxuICB0aGlzLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xyXG4gICAgaWYgKHR5cGVvZiBzZWxmW1wib25cIiArIGV2ZW50XSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuRE9ORSlcclxuICAgICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7IHNlbGZbXCJvblwiICsgZXZlbnRdKCkgfSlcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHNlbGZbXCJvblwiICsgZXZlbnRdKClcclxuICAgIH1cclxuICAgIGlmIChldmVudCBpbiBsaXN0ZW5lcnMpIHtcclxuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxpc3RlbmVyc1tldmVudF0ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpXHJcbiAgICAgICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7IGxpc3RlbmVyc1tldmVudF1baV0uY2FsbChzZWxmKSB9KVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIGxpc3RlbmVyc1tldmVudF1baV0uY2FsbChzZWxmKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hhbmdlcyByZWFkeVN0YXRlIGFuZCBjYWxscyBvbnJlYWR5c3RhdGVjaGFuZ2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gaW50IHN0YXRlIE5ldyBzdGF0ZVxyXG4gICAqL1xyXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XHJcbiAgICBpZiAoKHNlbGYucmVhZHlTdGF0ZSA9PT0gc3RhdGUpIHx8IChzZWxmLnJlYWR5U3RhdGUgPT09IHNlbGYuVU5TRU5UICYmIGFib3J0ZWRGbGFnKSlcclxuICAgICAgcmV0dXJuXHJcblxyXG4gICAgc2VsZi5yZWFkeVN0YXRlID0gc3RhdGU7XHJcblxyXG4gICAgaWYgKHNldHRpbmdzLmFzeW5jIHx8IHNlbGYucmVhZHlTdGF0ZSA8IHNlbGYuT1BFTkVEIHx8IHNlbGYucmVhZHlTdGF0ZSA9PT0gc2VsZi5ET05FKSB7XHJcbiAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChcInJlYWR5c3RhdGVjaGFuZ2VcIik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNlbGYucmVhZHlTdGF0ZSA9PT0gc2VsZi5ET05FKSB7XHJcbiAgICAgIGxldCBmaXJlXHJcblxyXG4gICAgICBpZiAoYWJvcnRlZEZsYWcpXHJcbiAgICAgICAgZmlyZSA9IFwiYWJvcnRcIlxyXG4gICAgICBlbHNlIGlmIChlcnJvckZsYWcpXHJcbiAgICAgICAgZmlyZSA9IFwiZXJyb3JcIlxyXG4gICAgICBlbHNlXHJcbiAgICAgICAgZmlyZSA9IFwibG9hZFwiXHJcblxyXG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoZmlyZSlcclxuXHJcbiAgICAgIC8vIEBUT0RPIGZpZ3VyZSBvdXQgSW5zcGVjdG9ySW5zdHJ1bWVudGF0aW9uOjpkaWRMb2FkWEhSKGNvb2tpZSlcclxuICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwibG9hZGVuZFwiKTtcclxuICAgIH1cclxuICB9O1xyXG59O1xyXG4iXSwibmFtZXMiOlsiZnMiLCJyZXF1aXJlIiwiVXJsIiwic3Bhd24iLCJtb2R1bGUiLCJleHBvcnRzIiwiWE1MSHR0cFJlcXVlc3QiLCJvcHRzIiwic2VsZiIsImh0dHAiLCJodHRwcyIsInJlcXVlc3QiLCJyZXNwb25zZSIsInNldHRpbmdzIiwiZGlzYWJsZUhlYWRlckNoZWNrIiwiZGVmYXVsdEhlYWRlcnMiLCJoZWFkZXJzIiwiT2JqZWN0IiwiYXNzaWduIiwiZm9yYmlkZGVuUmVxdWVzdEhlYWRlcnMiLCJmb3JiaWRkZW5SZXF1ZXN0TWV0aG9kcyIsInNlbmRGbGFnIiwiZXJyb3JGbGFnIiwiYWJvcnRlZEZsYWciLCJsaXN0ZW5lcnMiLCJVTlNFTlQiLCJPUEVORUQiLCJIRUFERVJTX1JFQ0VJVkVEIiwiTE9BRElORyIsIkRPTkUiLCJyZWFkeVN0YXRlIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVzcG9uc2VUZXh0IiwicmVzcG9uc2VYTUwiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiaXNBbGxvd2VkSHR0cEhlYWRlciIsImhlYWRlciIsImluZGV4T2YiLCJ0b0xvd2VyQ2FzZSIsImlzQWxsb3dlZEh0dHBNZXRob2QiLCJtZXRob2QiLCJvcGVuIiwidXJsIiwiYXN5bmMiLCJ1c2VyIiwicGFzc3dvcmQiLCJhYm9ydCIsIkVycm9yIiwidG9TdHJpbmciLCJzZXRTdGF0ZSIsInNldERpc2FibGVIZWFkZXJDaGVjayIsInN0YXRlIiwic2V0UmVxdWVzdEhlYWRlciIsInZhbHVlIiwiY29uc29sZSIsIndhcm4iLCJnZXRSZXNwb25zZUhlYWRlciIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsInJlc3VsdCIsImkiLCJzdWJzdHIiLCJsZW5ndGgiLCJnZXRSZXF1ZXN0SGVhZGVyIiwibmFtZSIsInNlbmQiLCJkYXRhIiwic3NsIiwibG9jYWwiLCJwYXJzZSIsImhvc3QiLCJwcm90b2NvbCIsImhvc3RuYW1lIiwidW5kZWZpbmVkIiwicmVhZEZpbGUiLCJ1bmVzY2FwZSIsInBhdGhuYW1lIiwiZXJyb3IiLCJoYW5kbGVFcnJvciIsImVycm5vIiwicmVhZEZpbGVTeW5jIiwiZSIsInBvcnQiLCJ1cmkiLCJzZWFyY2giLCJhdXRoQnVmIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJieXRlTGVuZ3RoIiwiYWdlbnQiLCJvcHRpb25zIiwicGF0aCIsInBmeCIsImtleSIsInBhc3NwaHJhc2UiLCJjZXJ0IiwiY2EiLCJjaXBoZXJzIiwicmVqZWN0VW5hdXRob3JpemVkIiwiZG9SZXF1ZXN0IiwiZGlzcGF0Y2hFdmVudCIsInJlc3BvbnNlSGFuZGxlciIsInJlc3AiLCJzdGF0dXNDb2RlIiwibG9jYXRpb24iLCJuZXdPcHRpb25zIiwib24iLCJlcnJvckhhbmRsZXIiLCJlbmQiLCJzZXRFbmNvZGluZyIsImNodW5rIiwiYXV0b1VucmVmIiwic29ja2V0IiwidW5yZWYiLCJ3cml0ZSIsImNvbnRlbnRGaWxlIiwicHJvY2VzcyIsInBpZCIsInN5bmNGaWxlIiwid3JpdGVGaWxlU3luYyIsImV4ZWNTdHJpbmciLCJKU09OIiwic3RyaW5naWZ5Iiwic2xpY2UiLCJyZXBsYWNlIiwic3luY1Byb2MiLCJhcmd2IiwiZXhpc3RzU3luYyIsInN0ZGluIiwidW5saW5rU3luYyIsIm1hdGNoIiwiZXJyb3JPYmoiLCJzdGFjayIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsImNhbGxiYWNrIiwicHVzaCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJmaWx0ZXIiLCJldiIsInNldEltbWVkaWF0ZSIsImxlbiIsImNhbGwiLCJmaXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js\n");

/***/ })

};
;