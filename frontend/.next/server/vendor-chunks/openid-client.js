/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/openid-client";
exports.ids = ["vendor-chunks/openid-client"];
exports.modules = {

/***/ "(rsc)/./node_modules/openid-client/lib/client.js":
/*!**************************************************!*\
  !*** ./node_modules/openid-client/lib/client.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { inspect } = __webpack_require__(/*! util */ \"util\");\nconst stdhttp = __webpack_require__(/*! http */ \"http\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst { strict: assert } = __webpack_require__(/*! assert */ \"assert\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst { URL, URLSearchParams } = __webpack_require__(/*! url */ \"url\");\nconst jose = __webpack_require__(/*! jose */ \"(rsc)/./node_modules/jose/dist/node/cjs/index.js\");\nconst tokenHash = __webpack_require__(/*! oidc-token-hash */ \"(rsc)/./node_modules/oidc-token-hash/lib/index.js\");\nconst isKeyObject = __webpack_require__(/*! ./helpers/is_key_object */ \"(rsc)/./node_modules/openid-client/lib/helpers/is_key_object.js\");\nconst decodeJWT = __webpack_require__(/*! ./helpers/decode_jwt */ \"(rsc)/./node_modules/openid-client/lib/helpers/decode_jwt.js\");\nconst base64url = __webpack_require__(/*! ./helpers/base64url */ \"(rsc)/./node_modules/openid-client/lib/helpers/base64url.js\");\nconst defaults = __webpack_require__(/*! ./helpers/defaults */ \"(rsc)/./node_modules/openid-client/lib/helpers/defaults.js\");\nconst parseWwwAuthenticate = __webpack_require__(/*! ./helpers/www_authenticate_parser */ \"(rsc)/./node_modules/openid-client/lib/helpers/www_authenticate_parser.js\");\nconst { assertSigningAlgValuesSupport, assertIssuerConfiguration } = __webpack_require__(/*! ./helpers/assert */ \"(rsc)/./node_modules/openid-client/lib/helpers/assert.js\");\nconst pick = __webpack_require__(/*! ./helpers/pick */ \"(rsc)/./node_modules/openid-client/lib/helpers/pick.js\");\nconst isPlainObject = __webpack_require__(/*! ./helpers/is_plain_object */ \"(rsc)/./node_modules/openid-client/lib/helpers/is_plain_object.js\");\nconst processResponse = __webpack_require__(/*! ./helpers/process_response */ \"(rsc)/./node_modules/openid-client/lib/helpers/process_response.js\");\nconst TokenSet = __webpack_require__(/*! ./token_set */ \"(rsc)/./node_modules/openid-client/lib/token_set.js\");\nconst { OPError, RPError } = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/openid-client/lib/errors.js\");\nconst now = __webpack_require__(/*! ./helpers/unix_timestamp */ \"(rsc)/./node_modules/openid-client/lib/helpers/unix_timestamp.js\");\nconst { random } = __webpack_require__(/*! ./helpers/generators */ \"(rsc)/./node_modules/openid-client/lib/helpers/generators.js\");\nconst request = __webpack_require__(/*! ./helpers/request */ \"(rsc)/./node_modules/openid-client/lib/helpers/request.js\");\nconst { CLOCK_TOLERANCE } = __webpack_require__(/*! ./helpers/consts */ \"(rsc)/./node_modules/openid-client/lib/helpers/consts.js\");\nconst { keystores } = __webpack_require__(/*! ./helpers/weak_cache */ \"(rsc)/./node_modules/openid-client/lib/helpers/weak_cache.js\");\nconst KeyStore = __webpack_require__(/*! ./helpers/keystore */ \"(rsc)/./node_modules/openid-client/lib/helpers/keystore.js\");\nconst clone = __webpack_require__(/*! ./helpers/deep_clone */ \"(rsc)/./node_modules/openid-client/lib/helpers/deep_clone.js\");\nconst { authenticatedPost, resolveResponseType, resolveRedirectUri } = __webpack_require__(/*! ./helpers/client */ \"(rsc)/./node_modules/openid-client/lib/helpers/client.js\");\nconst { queryKeyStore } = __webpack_require__(/*! ./helpers/issuer */ \"(rsc)/./node_modules/openid-client/lib/helpers/issuer.js\");\nconst DeviceFlowHandle = __webpack_require__(/*! ./device_flow_handle */ \"(rsc)/./node_modules/openid-client/lib/device_flow_handle.js\");\nconst [major, minor] = process.version.slice(1).split(\".\").map((str)=>parseInt(str, 10));\nconst rsaPssParams = major >= 17 || major === 16 && minor >= 9;\nconst retryAttempt = Symbol();\nconst skipNonceCheck = Symbol();\nconst skipMaxAgeCheck = Symbol();\nfunction pickCb(input) {\n    return pick(input, \"access_token\", \"code\", \"error_description\", \"error_uri\", \"error\", \"expires_in\", \"id_token\", \"iss\", \"response\", \"session_state\", \"state\", \"token_type\");\n}\nfunction authorizationHeaderValue(token, tokenType = \"Bearer\") {\n    return `${tokenType} ${token}`;\n}\nfunction getSearchParams(input) {\n    const parsed = url.parse(input);\n    if (!parsed.search) return {};\n    return querystring.parse(parsed.search.substring(1));\n}\nfunction verifyPresence(payload, jwt, prop) {\n    if (payload[prop] === undefined) {\n        throw new RPError({\n            message: `missing required JWT property ${prop}`,\n            jwt\n        });\n    }\n}\nfunction authorizationParams(params) {\n    const authParams = {\n        client_id: this.client_id,\n        scope: \"openid\",\n        response_type: resolveResponseType.call(this),\n        redirect_uri: resolveRedirectUri.call(this),\n        ...params\n    };\n    Object.entries(authParams).forEach(([key, value])=>{\n        if (value === null || value === undefined) {\n            delete authParams[key];\n        } else if (key === \"claims\" && typeof value === \"object\") {\n            authParams[key] = JSON.stringify(value);\n        } else if (key === \"resource\" && Array.isArray(value)) {\n            authParams[key] = value;\n        } else if (typeof value !== \"string\") {\n            authParams[key] = String(value);\n        }\n    });\n    return authParams;\n}\nfunction getKeystore(jwks) {\n    if (!isPlainObject(jwks) || !Array.isArray(jwks.keys) || jwks.keys.some((k)=>!isPlainObject(k) || !(\"kty\" in k))) {\n        throw new TypeError(\"jwks must be a JSON Web Key Set formatted object\");\n    }\n    return KeyStore.fromJWKS(jwks, {\n        onlyPrivate: true\n    });\n}\n// if an OP doesnt support client_secret_basic but supports client_secret_post, use it instead\n// this is in place to take care of most common pitfalls when first using discovered Issuers without\n// the support for default values defined by Discovery 1.0\nfunction checkBasicSupport(client, properties) {\n    try {\n        const supported = client.issuer.token_endpoint_auth_methods_supported;\n        if (!supported.includes(properties.token_endpoint_auth_method)) {\n            if (supported.includes(\"client_secret_post\")) {\n                properties.token_endpoint_auth_method = \"client_secret_post\";\n            }\n        }\n    } catch (err) {}\n}\nfunction handleCommonMistakes(client, metadata, properties) {\n    if (!metadata.token_endpoint_auth_method) {\n        // if no explicit value was provided\n        checkBasicSupport(client, properties);\n    }\n    // :fp: c'mon people... RTFM\n    if (metadata.redirect_uri) {\n        if (metadata.redirect_uris) {\n            throw new TypeError(\"provide a redirect_uri or redirect_uris, not both\");\n        }\n        properties.redirect_uris = [\n            metadata.redirect_uri\n        ];\n        delete properties.redirect_uri;\n    }\n    if (metadata.response_type) {\n        if (metadata.response_types) {\n            throw new TypeError(\"provide a response_type or response_types, not both\");\n        }\n        properties.response_types = [\n            metadata.response_type\n        ];\n        delete properties.response_type;\n    }\n}\nfunction getDefaultsForEndpoint(endpoint, issuer, properties) {\n    if (!issuer[`${endpoint}_endpoint`]) return;\n    const tokenEndpointAuthMethod = properties.token_endpoint_auth_method;\n    const tokenEndpointAuthSigningAlg = properties.token_endpoint_auth_signing_alg;\n    const eam = `${endpoint}_endpoint_auth_method`;\n    const easa = `${endpoint}_endpoint_auth_signing_alg`;\n    if (properties[eam] === undefined && properties[easa] === undefined) {\n        if (tokenEndpointAuthMethod !== undefined) {\n            properties[eam] = tokenEndpointAuthMethod;\n        }\n        if (tokenEndpointAuthSigningAlg !== undefined) {\n            properties[easa] = tokenEndpointAuthSigningAlg;\n        }\n    }\n}\nclass BaseClient {\n    #metadata;\n    #issuer;\n    #aadIssValidation;\n    #additionalAuthorizedParties;\n    constructor(issuer, aadIssValidation, metadata = {}, jwks, options){\n        this.#metadata = new Map();\n        this.#issuer = issuer;\n        this.#aadIssValidation = aadIssValidation;\n        if (typeof metadata.client_id !== \"string\" || !metadata.client_id) {\n            throw new TypeError(\"client_id is required\");\n        }\n        const properties = {\n            grant_types: [\n                \"authorization_code\"\n            ],\n            id_token_signed_response_alg: \"RS256\",\n            authorization_signed_response_alg: \"RS256\",\n            response_types: [\n                \"code\"\n            ],\n            token_endpoint_auth_method: \"client_secret_basic\",\n            ...this.fapi() ? {\n                grant_types: [\n                    \"authorization_code\",\n                    \"implicit\"\n                ],\n                id_token_signed_response_alg: \"PS256\",\n                authorization_signed_response_alg: \"PS256\",\n                response_types: [\n                    \"code id_token\"\n                ],\n                tls_client_certificate_bound_access_tokens: true,\n                token_endpoint_auth_method: undefined\n            } : undefined,\n            ...metadata\n        };\n        if (this.fapi()) {\n            switch(properties.token_endpoint_auth_method){\n                case \"self_signed_tls_client_auth\":\n                case \"tls_client_auth\":\n                    break;\n                case \"private_key_jwt\":\n                    if (!jwks) {\n                        throw new TypeError(\"jwks is required\");\n                    }\n                    break;\n                case undefined:\n                    throw new TypeError(\"token_endpoint_auth_method is required\");\n                default:\n                    throw new TypeError(\"invalid or unsupported token_endpoint_auth_method\");\n            }\n        }\n        handleCommonMistakes(this, metadata, properties);\n        assertSigningAlgValuesSupport(\"token\", this.issuer, properties);\n        [\n            \"introspection\",\n            \"revocation\"\n        ].forEach((endpoint)=>{\n            getDefaultsForEndpoint(endpoint, this.issuer, properties);\n            assertSigningAlgValuesSupport(endpoint, this.issuer, properties);\n        });\n        Object.entries(properties).forEach(([key, value])=>{\n            this.#metadata.set(key, value);\n            if (!this[key]) {\n                Object.defineProperty(this, key, {\n                    get () {\n                        return this.#metadata.get(key);\n                    },\n                    enumerable: true\n                });\n            }\n        });\n        if (jwks !== undefined) {\n            const keystore = getKeystore.call(this, jwks);\n            keystores.set(this, keystore);\n        }\n        if (options != null && options.additionalAuthorizedParties) {\n            this.#additionalAuthorizedParties = clone(options.additionalAuthorizedParties);\n        }\n        this[CLOCK_TOLERANCE] = 0;\n    }\n    authorizationUrl(params = {}) {\n        if (!isPlainObject(params)) {\n            throw new TypeError(\"params must be a plain object\");\n        }\n        assertIssuerConfiguration(this.issuer, \"authorization_endpoint\");\n        const target = new URL(this.issuer.authorization_endpoint);\n        for (const [name, value] of Object.entries(authorizationParams.call(this, params))){\n            if (Array.isArray(value)) {\n                target.searchParams.delete(name);\n                for (const member of value){\n                    target.searchParams.append(name, member);\n                }\n            } else {\n                target.searchParams.set(name, value);\n            }\n        }\n        // TODO: is the replace needed?\n        return target.href.replace(/\\+/g, \"%20\");\n    }\n    authorizationPost(params = {}) {\n        if (!isPlainObject(params)) {\n            throw new TypeError(\"params must be a plain object\");\n        }\n        const inputs = authorizationParams.call(this, params);\n        const formInputs = Object.keys(inputs).map((name)=>`<input type=\"hidden\" name=\"${name}\" value=\"${inputs[name]}\"/>`).join(\"\\n\");\n        return `<!DOCTYPE html>\r\n<head>\r\n<title>Requesting Authorization</title>\r\n</head>\r\n<body onload=\"javascript:document.forms[0].submit()\">\r\n<form method=\"post\" action=\"${this.issuer.authorization_endpoint}\">\r\n  ${formInputs}\r\n</form>\r\n</body>\r\n</html>`;\n    }\n    endSessionUrl(params = {}) {\n        assertIssuerConfiguration(this.issuer, \"end_session_endpoint\");\n        const { 0: postLogout, length } = this.post_logout_redirect_uris || [];\n        const { post_logout_redirect_uri = length === 1 ? postLogout : undefined } = params;\n        let id_token_hint;\n        ({ id_token_hint, ...params } = params);\n        if (id_token_hint instanceof TokenSet) {\n            if (!id_token_hint.id_token) {\n                throw new TypeError(\"id_token not present in TokenSet\");\n            }\n            id_token_hint = id_token_hint.id_token;\n        }\n        const target = url.parse(this.issuer.end_session_endpoint);\n        const query = defaults(getSearchParams(this.issuer.end_session_endpoint), params, {\n            post_logout_redirect_uri,\n            client_id: this.client_id\n        }, {\n            id_token_hint\n        });\n        Object.entries(query).forEach(([key, value])=>{\n            if (value === null || value === undefined) {\n                delete query[key];\n            }\n        });\n        target.search = null;\n        target.query = query;\n        return url.format(target);\n    }\n    callbackParams(input) {\n        const isIncomingMessage = input instanceof stdhttp.IncomingMessage || input && input.method && input.url;\n        const isString = typeof input === \"string\";\n        if (!isString && !isIncomingMessage) {\n            throw new TypeError(\"#callbackParams only accepts string urls, http.IncomingMessage or a lookalike\");\n        }\n        if (isIncomingMessage) {\n            switch(input.method){\n                case \"GET\":\n                    return pickCb(getSearchParams(input.url));\n                case \"POST\":\n                    if (input.body === undefined) {\n                        throw new TypeError(\"incoming message body missing, include a body parser prior to this method call\");\n                    }\n                    switch(typeof input.body){\n                        case \"object\":\n                        case \"string\":\n                            if (Buffer.isBuffer(input.body)) {\n                                return pickCb(querystring.parse(input.body.toString(\"utf-8\")));\n                            }\n                            if (typeof input.body === \"string\") {\n                                return pickCb(querystring.parse(input.body));\n                            }\n                            return pickCb(input.body);\n                        default:\n                            throw new TypeError(\"invalid IncomingMessage body object\");\n                    }\n                default:\n                    throw new TypeError(\"invalid IncomingMessage method\");\n            }\n        } else {\n            return pickCb(getSearchParams(input));\n        }\n    }\n    async callback(redirectUri, parameters, checks = {}, { exchangeBody, clientAssertionPayload, DPoP } = {}) {\n        let params = pickCb(parameters);\n        if (checks.jarm && !(\"response\" in parameters)) {\n            throw new RPError({\n                message: \"expected a JARM response\",\n                checks,\n                params\n            });\n        } else if (\"response\" in parameters) {\n            const decrypted = await this.decryptJARM(params.response);\n            params = await this.validateJARM(decrypted);\n        }\n        if (this.default_max_age && !checks.max_age) {\n            checks.max_age = this.default_max_age;\n        }\n        if (params.state && !checks.state) {\n            throw new TypeError(\"checks.state argument is missing\");\n        }\n        if (!params.state && checks.state) {\n            throw new RPError({\n                message: \"state missing from the response\",\n                checks,\n                params\n            });\n        }\n        if (checks.state !== params.state) {\n            throw new RPError({\n                printf: [\n                    \"state mismatch, expected %s, got: %s\",\n                    checks.state,\n                    params.state\n                ],\n                checks,\n                params\n            });\n        }\n        if (\"iss\" in params) {\n            assertIssuerConfiguration(this.issuer, \"issuer\");\n            if (params.iss !== this.issuer.issuer) {\n                throw new RPError({\n                    printf: [\n                        \"iss mismatch, expected %s, got: %s\",\n                        this.issuer.issuer,\n                        params.iss\n                    ],\n                    params\n                });\n            }\n        } else if (this.issuer.authorization_response_iss_parameter_supported && !(\"id_token\" in params) && !(\"response\" in parameters)) {\n            throw new RPError({\n                message: \"iss missing from the response\",\n                params\n            });\n        }\n        if (params.error) {\n            throw new OPError(params);\n        }\n        const RESPONSE_TYPE_REQUIRED_PARAMS = {\n            code: [\n                \"code\"\n            ],\n            id_token: [\n                \"id_token\"\n            ],\n            token: [\n                \"access_token\",\n                \"token_type\"\n            ]\n        };\n        if (checks.response_type) {\n            for (const type of checks.response_type.split(\" \")){\n                if (type === \"none\") {\n                    if (params.code || params.id_token || params.access_token) {\n                        throw new RPError({\n                            message: 'unexpected params encountered for \"none\" response',\n                            checks,\n                            params\n                        });\n                    }\n                } else {\n                    for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]){\n                        if (!params[param]) {\n                            throw new RPError({\n                                message: `${param} missing from response`,\n                                checks,\n                                params\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        if (params.id_token) {\n            const tokenset = new TokenSet(params);\n            await this.decryptIdToken(tokenset);\n            await this.validateIdToken(tokenset, checks.nonce, \"authorization\", checks.max_age, checks.state);\n            if (!params.code) {\n                return tokenset;\n            }\n        }\n        if (params.code) {\n            const tokenset = await this.grant({\n                ...exchangeBody,\n                grant_type: \"authorization_code\",\n                code: params.code,\n                redirect_uri: redirectUri,\n                code_verifier: checks.code_verifier\n            }, {\n                clientAssertionPayload,\n                DPoP\n            });\n            await this.decryptIdToken(tokenset);\n            await this.validateIdToken(tokenset, checks.nonce, \"token\", checks.max_age);\n            if (params.session_state) {\n                tokenset.session_state = params.session_state;\n            }\n            return tokenset;\n        }\n        return new TokenSet(params);\n    }\n    async oauthCallback(redirectUri, parameters, checks = {}, { exchangeBody, clientAssertionPayload, DPoP } = {}) {\n        let params = pickCb(parameters);\n        if (checks.jarm && !(\"response\" in parameters)) {\n            throw new RPError({\n                message: \"expected a JARM response\",\n                checks,\n                params\n            });\n        } else if (\"response\" in parameters) {\n            const decrypted = await this.decryptJARM(params.response);\n            params = await this.validateJARM(decrypted);\n        }\n        if (params.state && !checks.state) {\n            throw new TypeError(\"checks.state argument is missing\");\n        }\n        if (!params.state && checks.state) {\n            throw new RPError({\n                message: \"state missing from the response\",\n                checks,\n                params\n            });\n        }\n        if (checks.state !== params.state) {\n            throw new RPError({\n                printf: [\n                    \"state mismatch, expected %s, got: %s\",\n                    checks.state,\n                    params.state\n                ],\n                checks,\n                params\n            });\n        }\n        if (\"iss\" in params) {\n            assertIssuerConfiguration(this.issuer, \"issuer\");\n            if (params.iss !== this.issuer.issuer) {\n                throw new RPError({\n                    printf: [\n                        \"iss mismatch, expected %s, got: %s\",\n                        this.issuer.issuer,\n                        params.iss\n                    ],\n                    params\n                });\n            }\n        } else if (this.issuer.authorization_response_iss_parameter_supported && !(\"id_token\" in params) && !(\"response\" in parameters)) {\n            throw new RPError({\n                message: \"iss missing from the response\",\n                params\n            });\n        }\n        if (params.error) {\n            throw new OPError(params);\n        }\n        if (typeof params.id_token === \"string\" && params.id_token.length) {\n            throw new RPError({\n                message: \"id_token detected in the response, you must use client.callback() instead of client.oauthCallback()\",\n                params\n            });\n        }\n        delete params.id_token;\n        const RESPONSE_TYPE_REQUIRED_PARAMS = {\n            code: [\n                \"code\"\n            ],\n            token: [\n                \"access_token\",\n                \"token_type\"\n            ]\n        };\n        if (checks.response_type) {\n            for (const type of checks.response_type.split(\" \")){\n                if (type === \"none\") {\n                    if (params.code || params.id_token || params.access_token) {\n                        throw new RPError({\n                            message: 'unexpected params encountered for \"none\" response',\n                            checks,\n                            params\n                        });\n                    }\n                }\n                if (RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n                    for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]){\n                        if (!params[param]) {\n                            throw new RPError({\n                                message: `${param} missing from response`,\n                                checks,\n                                params\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        if (params.code) {\n            const tokenset = await this.grant({\n                ...exchangeBody,\n                grant_type: \"authorization_code\",\n                code: params.code,\n                redirect_uri: redirectUri,\n                code_verifier: checks.code_verifier\n            }, {\n                clientAssertionPayload,\n                DPoP\n            });\n            if (typeof tokenset.id_token === \"string\" && tokenset.id_token.length) {\n                throw new RPError({\n                    message: \"id_token detected in the response, you must use client.callback() instead of client.oauthCallback()\",\n                    params\n                });\n            }\n            delete tokenset.id_token;\n            return tokenset;\n        }\n        return new TokenSet(params);\n    }\n    async decryptIdToken(token) {\n        if (!this.id_token_encrypted_response_alg) {\n            return token;\n        }\n        let idToken = token;\n        if (idToken instanceof TokenSet) {\n            if (!idToken.id_token) {\n                throw new TypeError(\"id_token not present in TokenSet\");\n            }\n            idToken = idToken.id_token;\n        }\n        const expectedAlg = this.id_token_encrypted_response_alg;\n        const expectedEnc = this.id_token_encrypted_response_enc;\n        const result = await this.decryptJWE(idToken, expectedAlg, expectedEnc);\n        if (token instanceof TokenSet) {\n            token.id_token = result;\n            return token;\n        }\n        return result;\n    }\n    async validateJWTUserinfo(body) {\n        const expectedAlg = this.userinfo_signed_response_alg;\n        return this.validateJWT(body, expectedAlg, []);\n    }\n    async decryptJARM(response) {\n        if (!this.authorization_encrypted_response_alg) {\n            return response;\n        }\n        const expectedAlg = this.authorization_encrypted_response_alg;\n        const expectedEnc = this.authorization_encrypted_response_enc;\n        return this.decryptJWE(response, expectedAlg, expectedEnc);\n    }\n    async decryptJWTUserinfo(body) {\n        if (!this.userinfo_encrypted_response_alg) {\n            return body;\n        }\n        const expectedAlg = this.userinfo_encrypted_response_alg;\n        const expectedEnc = this.userinfo_encrypted_response_enc;\n        return this.decryptJWE(body, expectedAlg, expectedEnc);\n    }\n    async decryptJWE(jwe, expectedAlg, expectedEnc = \"A128CBC-HS256\") {\n        const header = JSON.parse(base64url.decode(jwe.split(\".\")[0]));\n        if (header.alg !== expectedAlg) {\n            throw new RPError({\n                printf: [\n                    \"unexpected JWE alg received, expected %s, got: %s\",\n                    expectedAlg,\n                    header.alg\n                ],\n                jwt: jwe\n            });\n        }\n        if (header.enc !== expectedEnc) {\n            throw new RPError({\n                printf: [\n                    \"unexpected JWE enc received, expected %s, got: %s\",\n                    expectedEnc,\n                    header.enc\n                ],\n                jwt: jwe\n            });\n        }\n        const getPlaintext = (result)=>new TextDecoder().decode(result.plaintext);\n        let plaintext;\n        if (expectedAlg.match(/^(?:RSA|ECDH)/)) {\n            const keystore = await keystores.get(this);\n            const protectedHeader = jose.decodeProtectedHeader(jwe);\n            for (const key of keystore.all({\n                ...protectedHeader,\n                use: \"enc\"\n            })){\n                plaintext = await jose.compactDecrypt(jwe, await key.keyObject(protectedHeader.alg)).then(getPlaintext, ()=>{});\n                if (plaintext) break;\n            }\n        } else {\n            plaintext = await jose.compactDecrypt(jwe, this.secretForAlg(expectedAlg === \"dir\" ? expectedEnc : expectedAlg)).then(getPlaintext, ()=>{});\n        }\n        if (!plaintext) {\n            throw new RPError({\n                message: \"failed to decrypt JWE\",\n                jwt: jwe\n            });\n        }\n        return plaintext;\n    }\n    async validateIdToken(tokenSet, nonce, returnedBy, maxAge, state) {\n        let idToken = tokenSet;\n        const expectedAlg = this.id_token_signed_response_alg;\n        const isTokenSet = idToken instanceof TokenSet;\n        if (isTokenSet) {\n            if (!idToken.id_token) {\n                throw new TypeError(\"id_token not present in TokenSet\");\n            }\n            idToken = idToken.id_token;\n        }\n        idToken = String(idToken);\n        const timestamp = now();\n        const { protected: header, payload, key } = await this.validateJWT(idToken, expectedAlg);\n        if (typeof maxAge === \"number\" || maxAge !== skipMaxAgeCheck && this.require_auth_time) {\n            if (!payload.auth_time) {\n                throw new RPError({\n                    message: \"missing required JWT property auth_time\",\n                    jwt: idToken\n                });\n            }\n            if (typeof payload.auth_time !== \"number\") {\n                throw new RPError({\n                    message: \"JWT auth_time claim must be a JSON numeric value\",\n                    jwt: idToken\n                });\n            }\n        }\n        if (typeof maxAge === \"number\" && payload.auth_time + maxAge < timestamp - this[CLOCK_TOLERANCE]) {\n            throw new RPError({\n                printf: [\n                    \"too much time has elapsed since the last End-User authentication, max_age %i, auth_time: %i, now %i\",\n                    maxAge,\n                    payload.auth_time,\n                    timestamp - this[CLOCK_TOLERANCE]\n                ],\n                now: timestamp,\n                tolerance: this[CLOCK_TOLERANCE],\n                auth_time: payload.auth_time,\n                jwt: idToken\n            });\n        }\n        if (nonce !== skipNonceCheck && (payload.nonce || nonce !== undefined) && payload.nonce !== nonce) {\n            throw new RPError({\n                printf: [\n                    \"nonce mismatch, expected %s, got: %s\",\n                    nonce,\n                    payload.nonce\n                ],\n                jwt: idToken\n            });\n        }\n        if (returnedBy === \"authorization\") {\n            if (!payload.at_hash && tokenSet.access_token) {\n                throw new RPError({\n                    message: \"missing required property at_hash\",\n                    jwt: idToken\n                });\n            }\n            if (!payload.c_hash && tokenSet.code) {\n                throw new RPError({\n                    message: \"missing required property c_hash\",\n                    jwt: idToken\n                });\n            }\n            if (this.fapi()) {\n                if (!payload.s_hash && (tokenSet.state || state)) {\n                    throw new RPError({\n                        message: \"missing required property s_hash\",\n                        jwt: idToken\n                    });\n                }\n            }\n            if (payload.s_hash) {\n                if (!state) {\n                    throw new TypeError('cannot verify s_hash, \"checks.state\" property not provided');\n                }\n                try {\n                    tokenHash.validate({\n                        claim: \"s_hash\",\n                        source: \"state\"\n                    }, payload.s_hash, state, header.alg, key.jwk && key.jwk.crv);\n                } catch (err) {\n                    throw new RPError({\n                        message: err.message,\n                        jwt: idToken\n                    });\n                }\n            }\n        }\n        if (this.fapi() && payload.iat < timestamp - 3600) {\n            throw new RPError({\n                printf: [\n                    \"JWT issued too far in the past, now %i, iat %i\",\n                    timestamp,\n                    payload.iat\n                ],\n                now: timestamp,\n                tolerance: this[CLOCK_TOLERANCE],\n                iat: payload.iat,\n                jwt: idToken\n            });\n        }\n        if (tokenSet.access_token && payload.at_hash !== undefined) {\n            try {\n                tokenHash.validate({\n                    claim: \"at_hash\",\n                    source: \"access_token\"\n                }, payload.at_hash, tokenSet.access_token, header.alg, key.jwk && key.jwk.crv);\n            } catch (err) {\n                throw new RPError({\n                    message: err.message,\n                    jwt: idToken\n                });\n            }\n        }\n        if (tokenSet.code && payload.c_hash !== undefined) {\n            try {\n                tokenHash.validate({\n                    claim: \"c_hash\",\n                    source: \"code\"\n                }, payload.c_hash, tokenSet.code, header.alg, key.jwk && key.jwk.crv);\n            } catch (err) {\n                throw new RPError({\n                    message: err.message,\n                    jwt: idToken\n                });\n            }\n        }\n        return tokenSet;\n    }\n    async validateJWT(jwt, expectedAlg, required = [\n        \"iss\",\n        \"sub\",\n        \"aud\",\n        \"exp\",\n        \"iat\"\n    ]) {\n        const isSelfIssued = this.issuer.issuer === \"https://self-issued.me\";\n        const timestamp = now();\n        let header;\n        let payload;\n        try {\n            ({ header, payload } = decodeJWT(jwt, {\n                complete: true\n            }));\n        } catch (err) {\n            throw new RPError({\n                printf: [\n                    \"failed to decode JWT (%s: %s)\",\n                    err.name,\n                    err.message\n                ],\n                jwt\n            });\n        }\n        if (header.alg !== expectedAlg) {\n            throw new RPError({\n                printf: [\n                    \"unexpected JWT alg received, expected %s, got: %s\",\n                    expectedAlg,\n                    header.alg\n                ],\n                jwt\n            });\n        }\n        if (isSelfIssued) {\n            required = [\n                ...required,\n                \"sub_jwk\"\n            ];\n        }\n        required.forEach(verifyPresence.bind(undefined, payload, jwt));\n        if (payload.iss !== undefined) {\n            let expectedIss = this.issuer.issuer;\n            if (this.#aadIssValidation) {\n                expectedIss = this.issuer.issuer.replace(\"{tenantid}\", payload.tid);\n            }\n            if (payload.iss !== expectedIss) {\n                throw new RPError({\n                    printf: [\n                        \"unexpected iss value, expected %s, got: %s\",\n                        expectedIss,\n                        payload.iss\n                    ],\n                    jwt\n                });\n            }\n        }\n        if (payload.iat !== undefined) {\n            if (typeof payload.iat !== \"number\") {\n                throw new RPError({\n                    message: \"JWT iat claim must be a JSON numeric value\",\n                    jwt\n                });\n            }\n        }\n        if (payload.nbf !== undefined) {\n            if (typeof payload.nbf !== \"number\") {\n                throw new RPError({\n                    message: \"JWT nbf claim must be a JSON numeric value\",\n                    jwt\n                });\n            }\n            if (payload.nbf > timestamp + this[CLOCK_TOLERANCE]) {\n                throw new RPError({\n                    printf: [\n                        \"JWT not active yet, now %i, nbf %i\",\n                        timestamp + this[CLOCK_TOLERANCE],\n                        payload.nbf\n                    ],\n                    now: timestamp,\n                    tolerance: this[CLOCK_TOLERANCE],\n                    nbf: payload.nbf,\n                    jwt\n                });\n            }\n        }\n        if (payload.exp !== undefined) {\n            if (typeof payload.exp !== \"number\") {\n                throw new RPError({\n                    message: \"JWT exp claim must be a JSON numeric value\",\n                    jwt\n                });\n            }\n            if (timestamp - this[CLOCK_TOLERANCE] >= payload.exp) {\n                throw new RPError({\n                    printf: [\n                        \"JWT expired, now %i, exp %i\",\n                        timestamp - this[CLOCK_TOLERANCE],\n                        payload.exp\n                    ],\n                    now: timestamp,\n                    tolerance: this[CLOCK_TOLERANCE],\n                    exp: payload.exp,\n                    jwt\n                });\n            }\n        }\n        if (payload.aud !== undefined) {\n            if (Array.isArray(payload.aud)) {\n                if (payload.aud.length > 1 && !payload.azp) {\n                    throw new RPError({\n                        message: \"missing required JWT property azp\",\n                        jwt\n                    });\n                }\n                if (!payload.aud.includes(this.client_id)) {\n                    throw new RPError({\n                        printf: [\n                            \"aud is missing the client_id, expected %s to be included in %j\",\n                            this.client_id,\n                            payload.aud\n                        ],\n                        jwt\n                    });\n                }\n            } else if (payload.aud !== this.client_id) {\n                throw new RPError({\n                    printf: [\n                        \"aud mismatch, expected %s, got: %s\",\n                        this.client_id,\n                        payload.aud\n                    ],\n                    jwt\n                });\n            }\n        }\n        if (payload.azp !== undefined) {\n            let additionalAuthorizedParties = this.#additionalAuthorizedParties;\n            if (typeof additionalAuthorizedParties === \"string\") {\n                additionalAuthorizedParties = [\n                    this.client_id,\n                    additionalAuthorizedParties\n                ];\n            } else if (Array.isArray(additionalAuthorizedParties)) {\n                additionalAuthorizedParties = [\n                    this.client_id,\n                    ...additionalAuthorizedParties\n                ];\n            } else {\n                additionalAuthorizedParties = [\n                    this.client_id\n                ];\n            }\n            if (!additionalAuthorizedParties.includes(payload.azp)) {\n                throw new RPError({\n                    printf: [\n                        \"azp mismatch, got: %s\",\n                        payload.azp\n                    ],\n                    jwt\n                });\n            }\n        }\n        let keys;\n        if (isSelfIssued) {\n            try {\n                assert(isPlainObject(payload.sub_jwk));\n                const key = await jose.importJWK(payload.sub_jwk, header.alg);\n                assert.equal(key.type, \"public\");\n                keys = [\n                    {\n                        keyObject () {\n                            return key;\n                        }\n                    }\n                ];\n            } catch (err) {\n                throw new RPError({\n                    message: \"failed to use sub_jwk claim as an asymmetric JSON Web Key\",\n                    jwt\n                });\n            }\n            if (await jose.calculateJwkThumbprint(payload.sub_jwk) !== payload.sub) {\n                throw new RPError({\n                    message: \"failed to match the subject with sub_jwk\",\n                    jwt\n                });\n            }\n        } else if (header.alg.startsWith(\"HS\")) {\n            keys = [\n                this.secretForAlg(header.alg)\n            ];\n        } else if (header.alg !== \"none\") {\n            keys = await queryKeyStore.call(this.issuer, {\n                ...header,\n                use: \"sig\"\n            });\n        }\n        if (!keys && header.alg === \"none\") {\n            return {\n                protected: header,\n                payload\n            };\n        }\n        for (const key of keys){\n            const verified = await jose.compactVerify(jwt, key instanceof Uint8Array ? key : await key.keyObject(header.alg)).catch(()=>{});\n            if (verified) {\n                return {\n                    payload,\n                    protected: verified.protectedHeader,\n                    key\n                };\n            }\n        }\n        throw new RPError({\n            message: \"failed to validate JWT signature\",\n            jwt\n        });\n    }\n    async refresh(refreshToken, { exchangeBody, clientAssertionPayload, DPoP } = {}) {\n        let token = refreshToken;\n        if (token instanceof TokenSet) {\n            if (!token.refresh_token) {\n                throw new TypeError(\"refresh_token not present in TokenSet\");\n            }\n            token = token.refresh_token;\n        }\n        const tokenset = await this.grant({\n            ...exchangeBody,\n            grant_type: \"refresh_token\",\n            refresh_token: String(token)\n        }, {\n            clientAssertionPayload,\n            DPoP\n        });\n        if (tokenset.id_token) {\n            await this.decryptIdToken(tokenset);\n            await this.validateIdToken(tokenset, skipNonceCheck, \"token\", skipMaxAgeCheck);\n            if (refreshToken instanceof TokenSet && refreshToken.id_token) {\n                const expectedSub = refreshToken.claims().sub;\n                const actualSub = tokenset.claims().sub;\n                if (actualSub !== expectedSub) {\n                    throw new RPError({\n                        printf: [\n                            \"sub mismatch, expected %s, got: %s\",\n                            expectedSub,\n                            actualSub\n                        ],\n                        jwt: tokenset.id_token\n                    });\n                }\n            }\n        }\n        return tokenset;\n    }\n    async requestResource(resourceUrl, accessToken, { method, headers, body, DPoP, tokenType = DPoP ? \"DPoP\" : accessToken instanceof TokenSet ? accessToken.token_type : \"Bearer\" } = {}, retry) {\n        if (accessToken instanceof TokenSet) {\n            if (!accessToken.access_token) {\n                throw new TypeError(\"access_token not present in TokenSet\");\n            }\n            accessToken = accessToken.access_token;\n        }\n        if (!accessToken) {\n            throw new TypeError(\"no access token provided\");\n        } else if (typeof accessToken !== \"string\") {\n            throw new TypeError(\"invalid access token provided\");\n        }\n        const requestOpts = {\n            headers: {\n                Authorization: authorizationHeaderValue(accessToken, tokenType),\n                ...headers\n            },\n            body\n        };\n        const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n        const response = await request.call(this, {\n            ...requestOpts,\n            responseType: \"buffer\",\n            method,\n            url: resourceUrl\n        }, {\n            accessToken,\n            mTLS,\n            DPoP\n        });\n        const wwwAuthenticate = response.headers[\"www-authenticate\"];\n        if (retry !== retryAttempt && wwwAuthenticate && wwwAuthenticate.toLowerCase().startsWith(\"dpop \") && parseWwwAuthenticate(wwwAuthenticate).error === \"use_dpop_nonce\") {\n            return this.requestResource(resourceUrl, accessToken, {\n                method,\n                headers,\n                body,\n                DPoP,\n                tokenType\n            });\n        }\n        return response;\n    }\n    async userinfo(accessToken, { method = \"GET\", via = \"header\", tokenType, params, DPoP } = {}) {\n        assertIssuerConfiguration(this.issuer, \"userinfo_endpoint\");\n        const options = {\n            tokenType,\n            method: String(method).toUpperCase(),\n            DPoP\n        };\n        if (options.method !== \"GET\" && options.method !== \"POST\") {\n            throw new TypeError(\"#userinfo() method can only be POST or a GET\");\n        }\n        if (via === \"body\" && options.method !== \"POST\") {\n            throw new TypeError(\"can only send body on POST\");\n        }\n        const jwt = !!(this.userinfo_signed_response_alg || this.userinfo_encrypted_response_alg);\n        if (jwt) {\n            options.headers = {\n                Accept: \"application/jwt\"\n            };\n        } else {\n            options.headers = {\n                Accept: \"application/json\"\n            };\n        }\n        const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n        let targetUrl;\n        if (mTLS && this.issuer.mtls_endpoint_aliases) {\n            targetUrl = this.issuer.mtls_endpoint_aliases.userinfo_endpoint;\n        }\n        targetUrl = new URL(targetUrl || this.issuer.userinfo_endpoint);\n        if (via === \"body\") {\n            options.headers.Authorization = undefined;\n            options.headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n            options.body = new URLSearchParams();\n            options.body.append(\"access_token\", accessToken instanceof TokenSet ? accessToken.access_token : accessToken);\n        }\n        // handle additional parameters, GET via querystring, POST via urlencoded body\n        if (params) {\n            if (options.method === \"GET\") {\n                Object.entries(params).forEach(([key, value])=>{\n                    targetUrl.searchParams.append(key, value);\n                });\n            } else if (options.body) {\n                // POST && via body\n                Object.entries(params).forEach(([key, value])=>{\n                    options.body.append(key, value);\n                });\n            } else {\n                // POST && via header\n                options.body = new URLSearchParams();\n                options.headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n                Object.entries(params).forEach(([key, value])=>{\n                    options.body.append(key, value);\n                });\n            }\n        }\n        if (options.body) {\n            options.body = options.body.toString();\n        }\n        const response = await this.requestResource(targetUrl, accessToken, options);\n        let parsed = processResponse(response, {\n            bearer: true\n        });\n        if (jwt) {\n            if (!/^application\\/jwt/.test(response.headers[\"content-type\"])) {\n                throw new RPError({\n                    message: \"expected application/jwt response from the userinfo_endpoint\",\n                    response\n                });\n            }\n            const body = response.body.toString();\n            const userinfo = await this.decryptJWTUserinfo(body);\n            if (!this.userinfo_signed_response_alg) {\n                try {\n                    parsed = JSON.parse(userinfo);\n                    assert(isPlainObject(parsed));\n                } catch (err) {\n                    throw new RPError({\n                        message: \"failed to parse userinfo JWE payload as JSON\",\n                        jwt: userinfo\n                    });\n                }\n            } else {\n                ({ payload: parsed } = await this.validateJWTUserinfo(userinfo));\n            }\n        } else {\n            try {\n                parsed = JSON.parse(response.body);\n            } catch (err) {\n                Object.defineProperty(err, \"response\", {\n                    value: response\n                });\n                throw err;\n            }\n        }\n        if (accessToken instanceof TokenSet && accessToken.id_token) {\n            const expectedSub = accessToken.claims().sub;\n            if (parsed.sub !== expectedSub) {\n                throw new RPError({\n                    printf: [\n                        \"userinfo sub mismatch, expected %s, got: %s\",\n                        expectedSub,\n                        parsed.sub\n                    ],\n                    body: parsed,\n                    jwt: accessToken.id_token\n                });\n            }\n        }\n        return parsed;\n    }\n    encryptionSecret(len) {\n        const hash = len <= 256 ? \"sha256\" : len <= 384 ? \"sha384\" : len <= 512 ? \"sha512\" : false;\n        if (!hash) {\n            throw new Error(\"unsupported symmetric encryption key derivation\");\n        }\n        return crypto.createHash(hash).update(this.client_secret).digest().slice(0, len / 8);\n    }\n    secretForAlg(alg) {\n        if (!this.client_secret) {\n            throw new TypeError(\"client_secret is required\");\n        }\n        if (/^A(\\d{3})(?:GCM)?KW$/.test(alg)) {\n            return this.encryptionSecret(parseInt(RegExp.$1, 10));\n        }\n        if (/^A(\\d{3})(?:GCM|CBC-HS(\\d{3}))$/.test(alg)) {\n            return this.encryptionSecret(parseInt(RegExp.$2 || RegExp.$1, 10));\n        }\n        return new TextEncoder().encode(this.client_secret);\n    }\n    async grant(body, { clientAssertionPayload, DPoP } = {}, retry) {\n        assertIssuerConfiguration(this.issuer, \"token_endpoint\");\n        const response = await authenticatedPost.call(this, \"token\", {\n            form: body,\n            responseType: \"json\"\n        }, {\n            clientAssertionPayload,\n            DPoP\n        });\n        let responseBody;\n        try {\n            responseBody = processResponse(response);\n        } catch (err) {\n            if (retry !== retryAttempt && err instanceof OPError && err.error === \"use_dpop_nonce\") {\n                return this.grant(body, {\n                    clientAssertionPayload,\n                    DPoP\n                }, retryAttempt);\n            }\n            throw err;\n        }\n        return new TokenSet(responseBody);\n    }\n    async deviceAuthorization(params = {}, { exchangeBody, clientAssertionPayload, DPoP } = {}) {\n        assertIssuerConfiguration(this.issuer, \"device_authorization_endpoint\");\n        assertIssuerConfiguration(this.issuer, \"token_endpoint\");\n        const body = authorizationParams.call(this, {\n            client_id: this.client_id,\n            redirect_uri: null,\n            response_type: null,\n            ...params\n        });\n        const response = await authenticatedPost.call(this, \"device_authorization\", {\n            responseType: \"json\",\n            form: body\n        }, {\n            clientAssertionPayload,\n            endpointAuthMethod: \"token\"\n        });\n        const responseBody = processResponse(response);\n        return new DeviceFlowHandle({\n            client: this,\n            exchangeBody,\n            clientAssertionPayload,\n            response: responseBody,\n            maxAge: params.max_age,\n            DPoP\n        });\n    }\n    async revoke(token, hint, { revokeBody, clientAssertionPayload } = {}) {\n        assertIssuerConfiguration(this.issuer, \"revocation_endpoint\");\n        if (hint !== undefined && typeof hint !== \"string\") {\n            throw new TypeError(\"hint must be a string\");\n        }\n        const form = {\n            ...revokeBody,\n            token\n        };\n        if (hint) {\n            form.token_type_hint = hint;\n        }\n        const response = await authenticatedPost.call(this, \"revocation\", {\n            form\n        }, {\n            clientAssertionPayload\n        });\n        processResponse(response, {\n            body: false\n        });\n    }\n    async introspect(token, hint, { introspectBody, clientAssertionPayload } = {}) {\n        assertIssuerConfiguration(this.issuer, \"introspection_endpoint\");\n        if (hint !== undefined && typeof hint !== \"string\") {\n            throw new TypeError(\"hint must be a string\");\n        }\n        const form = {\n            ...introspectBody,\n            token\n        };\n        if (hint) {\n            form.token_type_hint = hint;\n        }\n        const response = await authenticatedPost.call(this, \"introspection\", {\n            form,\n            responseType: \"json\"\n        }, {\n            clientAssertionPayload\n        });\n        const responseBody = processResponse(response);\n        return responseBody;\n    }\n    static async register(metadata, options = {}) {\n        const { initialAccessToken, jwks, ...clientOptions } = options;\n        assertIssuerConfiguration(this.issuer, \"registration_endpoint\");\n        if (jwks !== undefined && !(metadata.jwks || metadata.jwks_uri)) {\n            const keystore = await getKeystore.call(this, jwks);\n            metadata.jwks = keystore.toJWKS();\n        }\n        const response = await request.call(this, {\n            headers: {\n                Accept: \"application/json\",\n                ...initialAccessToken ? {\n                    Authorization: authorizationHeaderValue(initialAccessToken)\n                } : undefined\n            },\n            responseType: \"json\",\n            json: metadata,\n            url: this.issuer.registration_endpoint,\n            method: \"POST\"\n        });\n        const responseBody = processResponse(response, {\n            statusCode: 201,\n            bearer: true\n        });\n        return new this(responseBody, jwks, clientOptions);\n    }\n    get metadata() {\n        return clone(Object.fromEntries(this.#metadata.entries()));\n    }\n    static async fromUri(registrationClientUri, registrationAccessToken, jwks, clientOptions) {\n        const response = await request.call(this, {\n            method: \"GET\",\n            url: registrationClientUri,\n            responseType: \"json\",\n            headers: {\n                Authorization: authorizationHeaderValue(registrationAccessToken),\n                Accept: \"application/json\"\n            }\n        });\n        const responseBody = processResponse(response, {\n            bearer: true\n        });\n        return new this(responseBody, jwks, clientOptions);\n    }\n    async requestObject(requestObject = {}, { sign: signingAlgorithm = this.request_object_signing_alg || \"none\", encrypt: { alg: eKeyManagement = this.request_object_encryption_alg, enc: eContentEncryption = this.request_object_encryption_enc || \"A128CBC-HS256\" } = {} } = {}) {\n        if (!isPlainObject(requestObject)) {\n            throw new TypeError(\"requestObject must be a plain object\");\n        }\n        let signed;\n        let key;\n        const unix = now();\n        const header = {\n            alg: signingAlgorithm,\n            typ: \"oauth-authz-req+jwt\"\n        };\n        const payload = JSON.stringify(defaults({}, requestObject, {\n            iss: this.client_id,\n            aud: this.issuer.issuer,\n            client_id: this.client_id,\n            jti: random(),\n            iat: unix,\n            exp: unix + 300,\n            ...this.fapi() ? {\n                nbf: unix\n            } : undefined\n        }));\n        if (signingAlgorithm === \"none\") {\n            signed = [\n                base64url.encode(JSON.stringify(header)),\n                base64url.encode(payload),\n                \"\"\n            ].join(\".\");\n        } else {\n            const symmetric = signingAlgorithm.startsWith(\"HS\");\n            if (symmetric) {\n                key = this.secretForAlg(signingAlgorithm);\n            } else {\n                const keystore = await keystores.get(this);\n                if (!keystore) {\n                    throw new TypeError(`no keystore present for client, cannot sign using alg ${signingAlgorithm}`);\n                }\n                key = keystore.get({\n                    alg: signingAlgorithm,\n                    use: \"sig\"\n                });\n                if (!key) {\n                    throw new TypeError(`no key to sign with found for alg ${signingAlgorithm}`);\n                }\n            }\n            signed = await new jose.CompactSign(new TextEncoder().encode(payload)).setProtectedHeader({\n                ...header,\n                kid: symmetric ? undefined : key.jwk.kid\n            }).sign(symmetric ? key : await key.keyObject(signingAlgorithm));\n        }\n        if (!eKeyManagement) {\n            return signed;\n        }\n        const fields = {\n            alg: eKeyManagement,\n            enc: eContentEncryption,\n            cty: \"oauth-authz-req+jwt\"\n        };\n        if (fields.alg.match(/^(RSA|ECDH)/)) {\n            [key] = await queryKeyStore.call(this.issuer, {\n                alg: fields.alg,\n                use: \"enc\"\n            }, {\n                allowMulti: true\n            });\n        } else {\n            key = this.secretForAlg(fields.alg === \"dir\" ? fields.enc : fields.alg);\n        }\n        return new jose.CompactEncrypt(new TextEncoder().encode(signed)).setProtectedHeader({\n            ...fields,\n            kid: key instanceof Uint8Array ? undefined : key.jwk.kid\n        }).encrypt(key instanceof Uint8Array ? key : await key.keyObject(fields.alg));\n    }\n    async pushedAuthorizationRequest(params = {}, { clientAssertionPayload } = {}) {\n        assertIssuerConfiguration(this.issuer, \"pushed_authorization_request_endpoint\");\n        const body = {\n            ...\"request\" in params ? params : authorizationParams.call(this, params),\n            client_id: this.client_id\n        };\n        const response = await authenticatedPost.call(this, \"pushed_authorization_request\", {\n            responseType: \"json\",\n            form: body\n        }, {\n            clientAssertionPayload,\n            endpointAuthMethod: \"token\"\n        });\n        const responseBody = processResponse(response, {\n            statusCode: 201\n        });\n        if (!(\"expires_in\" in responseBody)) {\n            throw new RPError({\n                message: \"expected expires_in in Pushed Authorization Successful Response\",\n                response\n            });\n        }\n        if (typeof responseBody.expires_in !== \"number\") {\n            throw new RPError({\n                message: \"invalid expires_in value in Pushed Authorization Successful Response\",\n                response\n            });\n        }\n        if (!(\"request_uri\" in responseBody)) {\n            throw new RPError({\n                message: \"expected request_uri in Pushed Authorization Successful Response\",\n                response\n            });\n        }\n        if (typeof responseBody.request_uri !== \"string\") {\n            throw new RPError({\n                message: \"invalid request_uri value in Pushed Authorization Successful Response\",\n                response\n            });\n        }\n        return responseBody;\n    }\n    get issuer() {\n        return this.#issuer;\n    }\n    /* istanbul ignore next */ [inspect.custom]() {\n        return `${this.constructor.name} ${inspect(this.metadata, {\n            depth: Infinity,\n            colors: process.stdout.isTTY,\n            compact: false,\n            sorted: true\n        })}`;\n    }\n    fapi() {\n        return this.constructor.name === \"FAPI1Client\";\n    }\n    async validateJARM(response) {\n        const expectedAlg = this.authorization_signed_response_alg;\n        const { payload } = await this.validateJWT(response, expectedAlg, [\n            \"iss\",\n            \"exp\",\n            \"aud\"\n        ]);\n        return pickCb(payload);\n    }\n    /**\r\n   * @name dpopProof\r\n   * @api private\r\n   */ async dpopProof(payload, privateKeyInput, accessToken) {\n        if (!isPlainObject(payload)) {\n            throw new TypeError(\"payload must be a plain object\");\n        }\n        let privateKey;\n        if (isKeyObject(privateKeyInput)) {\n            privateKey = privateKeyInput;\n        } else if (privateKeyInput[Symbol.toStringTag] === \"CryptoKey\") {\n            privateKey = privateKeyInput;\n        } else if (jose.cryptoRuntime === \"node:crypto\") {\n            privateKey = crypto.createPrivateKey(privateKeyInput);\n        } else {\n            throw new TypeError(\"unrecognized crypto runtime\");\n        }\n        if (privateKey.type !== \"private\") {\n            throw new TypeError('\"DPoP\" option must be a private key');\n        }\n        let alg = determineDPoPAlgorithm.call(this, privateKey, privateKeyInput);\n        if (!alg) {\n            throw new TypeError(\"could not determine DPoP JWS Algorithm\");\n        }\n        return new jose.SignJWT({\n            ath: accessToken ? base64url.encode(crypto.createHash(\"sha256\").update(accessToken).digest()) : undefined,\n            ...payload\n        }).setProtectedHeader({\n            alg,\n            typ: \"dpop+jwt\",\n            jwk: await getJwk(privateKey, privateKeyInput)\n        }).setIssuedAt().setJti(random()).sign(privateKey);\n    }\n}\nfunction determineDPoPAlgorithmFromCryptoKey(cryptoKey) {\n    switch(cryptoKey.algorithm.name){\n        case \"Ed25519\":\n        case \"Ed448\":\n            return \"EdDSA\";\n        case \"ECDSA\":\n            {\n                switch(cryptoKey.algorithm.namedCurve){\n                    case \"P-256\":\n                        return \"ES256\";\n                    case \"P-384\":\n                        return \"ES384\";\n                    case \"P-521\":\n                        return \"ES512\";\n                    default:\n                        break;\n                }\n                break;\n            }\n        case \"RSASSA-PKCS1-v1_5\":\n            return `RS${cryptoKey.algorithm.hash.name.slice(4)}`;\n        case \"RSA-PSS\":\n            return `PS${cryptoKey.algorithm.hash.name.slice(4)}`;\n        default:\n            throw new TypeError(\"unsupported DPoP private key\");\n    }\n}\nlet determineDPoPAlgorithm;\nif (jose.cryptoRuntime === \"node:crypto\") {\n    determineDPoPAlgorithm = function(privateKey, privateKeyInput) {\n        if (privateKeyInput[Symbol.toStringTag] === \"CryptoKey\") {\n            return determineDPoPAlgorithmFromCryptoKey(privateKey);\n        }\n        switch(privateKey.asymmetricKeyType){\n            case \"ed25519\":\n            case \"ed448\":\n                return \"EdDSA\";\n            case \"ec\":\n                return determineEcAlgorithm(privateKey, privateKeyInput);\n            case \"rsa\":\n            case rsaPssParams && \"rsa-pss\":\n                return determineRsaAlgorithm(privateKey, privateKeyInput, this.issuer.dpop_signing_alg_values_supported);\n            default:\n                throw new TypeError(\"unsupported DPoP private key\");\n        }\n    };\n    const RSPS = /^(?:RS|PS)(?:256|384|512)$/;\n    function determineRsaAlgorithm(privateKey, privateKeyInput, valuesSupported) {\n        if (typeof privateKeyInput === \"object\" && privateKeyInput.format === \"jwk\" && privateKeyInput.key && privateKeyInput.key.alg) {\n            return privateKeyInput.key.alg;\n        }\n        if (Array.isArray(valuesSupported)) {\n            let candidates = valuesSupported.filter(RegExp.prototype.test.bind(RSPS));\n            if (privateKey.asymmetricKeyType === \"rsa-pss\") {\n                candidates = candidates.filter((value)=>value.startsWith(\"PS\"));\n            }\n            return [\n                \"PS256\",\n                \"PS384\",\n                \"PS512\",\n                \"RS256\",\n                \"RS384\",\n                \"RS384\"\n            ].find((preferred)=>candidates.includes(preferred));\n        }\n        return \"PS256\";\n    }\n    const p256 = Buffer.from([\n        42,\n        134,\n        72,\n        206,\n        61,\n        3,\n        1,\n        7\n    ]);\n    const p384 = Buffer.from([\n        43,\n        129,\n        4,\n        0,\n        34\n    ]);\n    const p521 = Buffer.from([\n        43,\n        129,\n        4,\n        0,\n        35\n    ]);\n    const secp256k1 = Buffer.from([\n        43,\n        129,\n        4,\n        0,\n        10\n    ]);\n    function determineEcAlgorithm(privateKey, privateKeyInput) {\n        // If input was a JWK\n        switch(typeof privateKeyInput === \"object\" && typeof privateKeyInput.key === \"object\" && privateKeyInput.key.crv){\n            case \"P-256\":\n                return \"ES256\";\n            case \"secp256k1\":\n                return \"ES256K\";\n            case \"P-384\":\n                return \"ES384\";\n            case \"P-512\":\n                return \"ES512\";\n            default:\n                break;\n        }\n        const buf = privateKey.export({\n            format: \"der\",\n            type: \"pkcs8\"\n        });\n        const i = buf[1] < 128 ? 17 : 18;\n        const len = buf[i];\n        const curveOid = buf.slice(i + 1, i + 1 + len);\n        if (curveOid.equals(p256)) {\n            return \"ES256\";\n        }\n        if (curveOid.equals(p384)) {\n            return \"ES384\";\n        }\n        if (curveOid.equals(p521)) {\n            return \"ES512\";\n        }\n        if (curveOid.equals(secp256k1)) {\n            return \"ES256K\";\n        }\n        throw new TypeError(\"unsupported DPoP private key curve\");\n    }\n} else {\n    determineDPoPAlgorithm = determineDPoPAlgorithmFromCryptoKey;\n}\nconst jwkCache = new WeakMap();\nasync function getJwk(keyObject, privateKeyInput) {\n    if (jose.cryptoRuntime === \"node:crypto\" && typeof privateKeyInput === \"object\" && typeof privateKeyInput.key === \"object\" && privateKeyInput.format === \"jwk\") {\n        return pick(privateKeyInput.key, \"kty\", \"crv\", \"x\", \"y\", \"e\", \"n\");\n    }\n    if (jwkCache.has(privateKeyInput)) {\n        return jwkCache.get(privateKeyInput);\n    }\n    const jwk = pick(await jose.exportJWK(keyObject), \"kty\", \"crv\", \"x\", \"y\", \"e\", \"n\");\n    if (isKeyObject(privateKeyInput) || jose.cryptoRuntime === \"WebCryptoAPI\") {\n        jwkCache.set(privateKeyInput, jwk);\n    }\n    return jwk;\n}\nmodule.exports = (issuer, aadIssValidation = false)=>class Client extends BaseClient {\n        constructor(...args){\n            super(issuer, aadIssValidation, ...args);\n        }\n        static get issuer() {\n            return issuer;\n        }\n    };\nmodule.exports.BaseClient = BaseClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU0sRUFBRUEsT0FBTyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzVCLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDO0FBQ3hCLE1BQU1FLFNBQVNGLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRUcsUUFBUUMsTUFBTSxFQUFFLEdBQUdKLG1CQUFPQSxDQUFDO0FBQ25DLE1BQU1LLGNBQWNMLG1CQUFPQSxDQUFDO0FBQzVCLE1BQU1NLE1BQU1OLG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU0sRUFBRU8sR0FBRyxFQUFFQyxlQUFlLEVBQUUsR0FBR1IsbUJBQU9BLENBQUM7QUFFekMsTUFBTVMsT0FBT1QsbUJBQU9BLENBQUM7QUFDckIsTUFBTVUsWUFBWVYsbUJBQU9BLENBQUM7QUFFMUIsTUFBTVcsY0FBY1gsbUJBQU9BLENBQUM7QUFDNUIsTUFBTVksWUFBWVosbUJBQU9BLENBQUM7QUFDMUIsTUFBTWEsWUFBWWIsbUJBQU9BLENBQUM7QUFDMUIsTUFBTWMsV0FBV2QsbUJBQU9BLENBQUM7QUFDekIsTUFBTWUsdUJBQXVCZixtQkFBT0EsQ0FBQztBQUNyQyxNQUFNLEVBQUVnQiw2QkFBNkIsRUFBRUMseUJBQXlCLEVBQUUsR0FBR2pCLG1CQUFPQSxDQUFDO0FBQzdFLE1BQU1rQixPQUFPbEIsbUJBQU9BLENBQUM7QUFDckIsTUFBTW1CLGdCQUFnQm5CLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU1vQixrQkFBa0JwQixtQkFBT0EsQ0FBQztBQUNoQyxNQUFNcUIsV0FBV3JCLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU0sRUFBRXNCLE9BQU8sRUFBRUMsT0FBTyxFQUFFLEdBQUd2QixtQkFBT0EsQ0FBQztBQUNyQyxNQUFNd0IsTUFBTXhCLG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU0sRUFBRXlCLE1BQU0sRUFBRSxHQUFHekIsbUJBQU9BLENBQUM7QUFD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T0FBT3JJLEtBQUtxVixnQkFBZ0IxUixHQUFHLEVBQUUsT0FBTyxPQUFPLEtBQUssS0FBSyxLQUFLO0lBQ2hFO0lBRUEsSUFBSThULFNBQVNFLEdBQUcsQ0FBQ3RDLGtCQUFrQjtRQUNqQyxPQUFPb0MsU0FBUzlRLEdBQUcsQ0FBQzBPO0lBQ3RCO0lBRUEsTUFBTXRILE1BQU0vTixLQUFLLE1BQU1ULEtBQUtxWSxTQUFTLENBQUMvSyxZQUFZLE9BQU8sT0FBTyxLQUFLLEtBQUssS0FBSztJQUUvRSxJQUFJcE4sWUFBWTRWLG9CQUFvQjlWLEtBQUtpVyxhQUFhLEtBQUssZ0JBQWdCO1FBQ3pFaUMsU0FBU2hSLEdBQUcsQ0FBQzRPLGlCQUFpQnRIO0lBQ2hDO0lBRUEsT0FBT0E7QUFDVDtBQUVBOEosT0FBT0MsT0FBTyxHQUFHLENBQUNoVCxRQUFRaUIsbUJBQW1CLEtBQUssR0FDaEQsTUFBTWdTLGVBQWVqUztRQUNuQkcsWUFBWSxHQUFHK1IsSUFBSSxDQUFFO1lBQ25CLEtBQUssQ0FBQ2xULFFBQVFpQixxQkFBcUJpUztRQUNyQztRQUVBLFdBQVdsVCxTQUFTO1lBQ2xCLE9BQU9BO1FBQ1Q7SUFDRjtBQUVGK1MseUJBQXlCLEdBQUcvUiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2NsaWVudC5qcz9kNGZjIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgaW5zcGVjdCB9ID0gcmVxdWlyZSgndXRpbCcpO1xyXG5jb25zdCBzdGRodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xyXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcclxuY29uc3QgeyBzdHJpY3Q6IGFzc2VydCB9ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XHJcbmNvbnN0IHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcclxuY29uc3QgdXJsID0gcmVxdWlyZSgndXJsJyk7XHJcbmNvbnN0IHsgVVJMLCBVUkxTZWFyY2hQYXJhbXMgfSA9IHJlcXVpcmUoJ3VybCcpO1xyXG5cclxuY29uc3Qgam9zZSA9IHJlcXVpcmUoJ2pvc2UnKTtcclxuY29uc3QgdG9rZW5IYXNoID0gcmVxdWlyZSgnb2lkYy10b2tlbi1oYXNoJyk7XHJcblxyXG5jb25zdCBpc0tleU9iamVjdCA9IHJlcXVpcmUoJy4vaGVscGVycy9pc19rZXlfb2JqZWN0Jyk7XHJcbmNvbnN0IGRlY29kZUpXVCA9IHJlcXVpcmUoJy4vaGVscGVycy9kZWNvZGVfand0Jyk7XHJcbmNvbnN0IGJhc2U2NHVybCA9IHJlcXVpcmUoJy4vaGVscGVycy9iYXNlNjR1cmwnKTtcclxuY29uc3QgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2hlbHBlcnMvZGVmYXVsdHMnKTtcclxuY29uc3QgcGFyc2VXd3dBdXRoZW50aWNhdGUgPSByZXF1aXJlKCcuL2hlbHBlcnMvd3d3X2F1dGhlbnRpY2F0ZV9wYXJzZXInKTtcclxuY29uc3QgeyBhc3NlcnRTaWduaW5nQWxnVmFsdWVzU3VwcG9ydCwgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbiB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Fzc2VydCcpO1xyXG5jb25zdCBwaWNrID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BpY2snKTtcclxuY29uc3QgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaGVscGVycy9pc19wbGFpbl9vYmplY3QnKTtcclxuY29uc3QgcHJvY2Vzc1Jlc3BvbnNlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb2Nlc3NfcmVzcG9uc2UnKTtcclxuY29uc3QgVG9rZW5TZXQgPSByZXF1aXJlKCcuL3Rva2VuX3NldCcpO1xyXG5jb25zdCB7IE9QRXJyb3IsIFJQRXJyb3IgfSA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XHJcbmNvbnN0IG5vdyA9IHJlcXVpcmUoJy4vaGVscGVycy91bml4X3RpbWVzdGFtcCcpO1xyXG5jb25zdCB7IHJhbmRvbSB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2dlbmVyYXRvcnMnKTtcclxuY29uc3QgcmVxdWVzdCA9IHJlcXVpcmUoJy4vaGVscGVycy9yZXF1ZXN0Jyk7XHJcbmNvbnN0IHsgQ0xPQ0tfVE9MRVJBTkNFIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMvY29uc3RzJyk7XHJcbmNvbnN0IHsga2V5c3RvcmVzIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMvd2Vha19jYWNoZScpO1xyXG5jb25zdCBLZXlTdG9yZSA9IHJlcXVpcmUoJy4vaGVscGVycy9rZXlzdG9yZScpO1xyXG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4vaGVscGVycy9kZWVwX2Nsb25lJyk7XHJcbmNvbnN0IHsgYXV0aGVudGljYXRlZFBvc3QsIHJlc29sdmVSZXNwb25zZVR5cGUsIHJlc29sdmVSZWRpcmVjdFVyaSB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2NsaWVudCcpO1xyXG5jb25zdCB7IHF1ZXJ5S2V5U3RvcmUgfSA9IHJlcXVpcmUoJy4vaGVscGVycy9pc3N1ZXInKTtcclxuY29uc3QgRGV2aWNlRmxvd0hhbmRsZSA9IHJlcXVpcmUoJy4vZGV2aWNlX2Zsb3dfaGFuZGxlJyk7XHJcblxyXG5jb25zdCBbbWFqb3IsIG1pbm9yXSA9IHByb2Nlc3MudmVyc2lvblxyXG4gIC5zbGljZSgxKVxyXG4gIC5zcGxpdCgnLicpXHJcbiAgLm1hcCgoc3RyKSA9PiBwYXJzZUludChzdHIsIDEwKSk7XHJcblxyXG5jb25zdCByc2FQc3NQYXJhbXMgPSBtYWpvciA+PSAxNyB8fCAobWFqb3IgPT09IDE2ICYmIG1pbm9yID49IDkpO1xyXG5jb25zdCByZXRyeUF0dGVtcHQgPSBTeW1ib2woKTtcclxuY29uc3Qgc2tpcE5vbmNlQ2hlY2sgPSBTeW1ib2woKTtcclxuY29uc3Qgc2tpcE1heEFnZUNoZWNrID0gU3ltYm9sKCk7XHJcblxyXG5mdW5jdGlvbiBwaWNrQ2IoaW5wdXQpIHtcclxuICByZXR1cm4gcGljayhcclxuICAgIGlucHV0LFxyXG4gICAgJ2FjY2Vzc190b2tlbicsIC8vIE9BdXRoIDIuMFxyXG4gICAgJ2NvZGUnLCAvLyBPQXV0aCAyLjBcclxuICAgICdlcnJvcl9kZXNjcmlwdGlvbicsIC8vIE9BdXRoIDIuMFxyXG4gICAgJ2Vycm9yX3VyaScsIC8vIE9BdXRoIDIuMFxyXG4gICAgJ2Vycm9yJywgLy8gT0F1dGggMi4wXHJcbiAgICAnZXhwaXJlc19pbicsIC8vIE9BdXRoIDIuMFxyXG4gICAgJ2lkX3Rva2VuJywgLy8gT0lEQyBDb3JlIDEuMFxyXG4gICAgJ2lzcycsIC8vIGRyYWZ0LWlldGYtb2F1dGgtaXNzLWF1dGgtcmVzcFxyXG4gICAgJ3Jlc3BvbnNlJywgLy8gRkFQSSBKQVJNXHJcbiAgICAnc2Vzc2lvbl9zdGF0ZScsIC8vIE9JREMgU2Vzc2lvbiBNYW5hZ2VtZW50XHJcbiAgICAnc3RhdGUnLCAvLyBPQXV0aCAyLjBcclxuICAgICd0b2tlbl90eXBlJywgLy8gT0F1dGggMi4wXHJcbiAgKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXV0aG9yaXphdGlvbkhlYWRlclZhbHVlKHRva2VuLCB0b2tlblR5cGUgPSAnQmVhcmVyJykge1xyXG4gIHJldHVybiBgJHt0b2tlblR5cGV9ICR7dG9rZW59YDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0U2VhcmNoUGFyYW1zKGlucHV0KSB7XHJcbiAgY29uc3QgcGFyc2VkID0gdXJsLnBhcnNlKGlucHV0KTtcclxuICBpZiAoIXBhcnNlZC5zZWFyY2gpIHJldHVybiB7fTtcclxuICByZXR1cm4gcXVlcnlzdHJpbmcucGFyc2UocGFyc2VkLnNlYXJjaC5zdWJzdHJpbmcoMSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB2ZXJpZnlQcmVzZW5jZShwYXlsb2FkLCBqd3QsIHByb3ApIHtcclxuICBpZiAocGF5bG9hZFtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgIG1lc3NhZ2U6IGBtaXNzaW5nIHJlcXVpcmVkIEpXVCBwcm9wZXJ0eSAke3Byb3B9YCxcclxuICAgICAgand0LFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhdXRob3JpemF0aW9uUGFyYW1zKHBhcmFtcykge1xyXG4gIGNvbnN0IGF1dGhQYXJhbXMgPSB7XHJcbiAgICBjbGllbnRfaWQ6IHRoaXMuY2xpZW50X2lkLFxyXG4gICAgc2NvcGU6ICdvcGVuaWQnLFxyXG4gICAgcmVzcG9uc2VfdHlwZTogcmVzb2x2ZVJlc3BvbnNlVHlwZS5jYWxsKHRoaXMpLFxyXG4gICAgcmVkaXJlY3RfdXJpOiByZXNvbHZlUmVkaXJlY3RVcmkuY2FsbCh0aGlzKSxcclxuICAgIC4uLnBhcmFtcyxcclxuICB9O1xyXG5cclxuICBPYmplY3QuZW50cmllcyhhdXRoUGFyYW1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcclxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGRlbGV0ZSBhdXRoUGFyYW1zW2tleV07XHJcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2NsYWltcycgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICBhdXRoUGFyYW1zW2tleV0gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XHJcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3Jlc291cmNlJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICBhdXRoUGFyYW1zW2tleV0gPSB2YWx1ZTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICBhdXRoUGFyYW1zW2tleV0gPSBTdHJpbmcodmFsdWUpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gYXV0aFBhcmFtcztcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0S2V5c3RvcmUoandrcykge1xyXG4gIGlmIChcclxuICAgICFpc1BsYWluT2JqZWN0KGp3a3MpIHx8XHJcbiAgICAhQXJyYXkuaXNBcnJheShqd2tzLmtleXMpIHx8XHJcbiAgICBqd2tzLmtleXMuc29tZSgoaykgPT4gIWlzUGxhaW5PYmplY3QoaykgfHwgISgna3R5JyBpbiBrKSlcclxuICApIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2p3a3MgbXVzdCBiZSBhIEpTT04gV2ViIEtleSBTZXQgZm9ybWF0dGVkIG9iamVjdCcpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIEtleVN0b3JlLmZyb21KV0tTKGp3a3MsIHsgb25seVByaXZhdGU6IHRydWUgfSk7XHJcbn1cclxuXHJcbi8vIGlmIGFuIE9QIGRvZXNudCBzdXBwb3J0IGNsaWVudF9zZWNyZXRfYmFzaWMgYnV0IHN1cHBvcnRzIGNsaWVudF9zZWNyZXRfcG9zdCwgdXNlIGl0IGluc3RlYWRcclxuLy8gdGhpcyBpcyBpbiBwbGFjZSB0byB0YWtlIGNhcmUgb2YgbW9zdCBjb21tb24gcGl0ZmFsbHMgd2hlbiBmaXJzdCB1c2luZyBkaXNjb3ZlcmVkIElzc3VlcnMgd2l0aG91dFxyXG4vLyB0aGUgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMgZGVmaW5lZCBieSBEaXNjb3ZlcnkgMS4wXHJcbmZ1bmN0aW9uIGNoZWNrQmFzaWNTdXBwb3J0KGNsaWVudCwgcHJvcGVydGllcykge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBzdXBwb3J0ZWQgPSBjbGllbnQuaXNzdWVyLnRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kc19zdXBwb3J0ZWQ7XHJcbiAgICBpZiAoIXN1cHBvcnRlZC5pbmNsdWRlcyhwcm9wZXJ0aWVzLnRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kKSkge1xyXG4gICAgICBpZiAoc3VwcG9ydGVkLmluY2x1ZGVzKCdjbGllbnRfc2VjcmV0X3Bvc3QnKSkge1xyXG4gICAgICAgIHByb3BlcnRpZXMudG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2QgPSAnY2xpZW50X3NlY3JldF9wb3N0JztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycikge31cclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlQ29tbW9uTWlzdGFrZXMoY2xpZW50LCBtZXRhZGF0YSwgcHJvcGVydGllcykge1xyXG4gIGlmICghbWV0YWRhdGEudG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2QpIHtcclxuICAgIC8vIGlmIG5vIGV4cGxpY2l0IHZhbHVlIHdhcyBwcm92aWRlZFxyXG4gICAgY2hlY2tCYXNpY1N1cHBvcnQoY2xpZW50LCBwcm9wZXJ0aWVzKTtcclxuICB9XHJcblxyXG4gIC8vIDpmcDogYydtb24gcGVvcGxlLi4uIFJURk1cclxuICBpZiAobWV0YWRhdGEucmVkaXJlY3RfdXJpKSB7XHJcbiAgICBpZiAobWV0YWRhdGEucmVkaXJlY3RfdXJpcykge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcm92aWRlIGEgcmVkaXJlY3RfdXJpIG9yIHJlZGlyZWN0X3VyaXMsIG5vdCBib3RoJyk7XHJcbiAgICB9XHJcbiAgICBwcm9wZXJ0aWVzLnJlZGlyZWN0X3VyaXMgPSBbbWV0YWRhdGEucmVkaXJlY3RfdXJpXTtcclxuICAgIGRlbGV0ZSBwcm9wZXJ0aWVzLnJlZGlyZWN0X3VyaTtcclxuICB9XHJcblxyXG4gIGlmIChtZXRhZGF0YS5yZXNwb25zZV90eXBlKSB7XHJcbiAgICBpZiAobWV0YWRhdGEucmVzcG9uc2VfdHlwZXMpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJvdmlkZSBhIHJlc3BvbnNlX3R5cGUgb3IgcmVzcG9uc2VfdHlwZXMsIG5vdCBib3RoJyk7XHJcbiAgICB9XHJcbiAgICBwcm9wZXJ0aWVzLnJlc3BvbnNlX3R5cGVzID0gW21ldGFkYXRhLnJlc3BvbnNlX3R5cGVdO1xyXG4gICAgZGVsZXRlIHByb3BlcnRpZXMucmVzcG9uc2VfdHlwZTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldERlZmF1bHRzRm9yRW5kcG9pbnQoZW5kcG9pbnQsIGlzc3VlciwgcHJvcGVydGllcykge1xyXG4gIGlmICghaXNzdWVyW2Ake2VuZHBvaW50fV9lbmRwb2ludGBdKSByZXR1cm47XHJcblxyXG4gIGNvbnN0IHRva2VuRW5kcG9pbnRBdXRoTWV0aG9kID0gcHJvcGVydGllcy50b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZDtcclxuICBjb25zdCB0b2tlbkVuZHBvaW50QXV0aFNpZ25pbmdBbGcgPSBwcm9wZXJ0aWVzLnRva2VuX2VuZHBvaW50X2F1dGhfc2lnbmluZ19hbGc7XHJcblxyXG4gIGNvbnN0IGVhbSA9IGAke2VuZHBvaW50fV9lbmRwb2ludF9hdXRoX21ldGhvZGA7XHJcbiAgY29uc3QgZWFzYSA9IGAke2VuZHBvaW50fV9lbmRwb2ludF9hdXRoX3NpZ25pbmdfYWxnYDtcclxuXHJcbiAgaWYgKHByb3BlcnRpZXNbZWFtXSA9PT0gdW5kZWZpbmVkICYmIHByb3BlcnRpZXNbZWFzYV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgaWYgKHRva2VuRW5kcG9pbnRBdXRoTWV0aG9kICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgcHJvcGVydGllc1tlYW1dID0gdG9rZW5FbmRwb2ludEF1dGhNZXRob2Q7XHJcbiAgICB9XHJcbiAgICBpZiAodG9rZW5FbmRwb2ludEF1dGhTaWduaW5nQWxnICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgcHJvcGVydGllc1tlYXNhXSA9IHRva2VuRW5kcG9pbnRBdXRoU2lnbmluZ0FsZztcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIEJhc2VDbGllbnQge1xyXG4gICNtZXRhZGF0YTtcclxuICAjaXNzdWVyO1xyXG4gICNhYWRJc3NWYWxpZGF0aW9uO1xyXG4gICNhZGRpdGlvbmFsQXV0aG9yaXplZFBhcnRpZXM7XHJcbiAgY29uc3RydWN0b3IoaXNzdWVyLCBhYWRJc3NWYWxpZGF0aW9uLCBtZXRhZGF0YSA9IHt9LCBqd2tzLCBvcHRpb25zKSB7XHJcbiAgICB0aGlzLiNtZXRhZGF0YSA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMuI2lzc3VlciA9IGlzc3VlcjtcclxuICAgIHRoaXMuI2FhZElzc1ZhbGlkYXRpb24gPSBhYWRJc3NWYWxpZGF0aW9uO1xyXG5cclxuICAgIGlmICh0eXBlb2YgbWV0YWRhdGEuY2xpZW50X2lkICE9PSAnc3RyaW5nJyB8fCAhbWV0YWRhdGEuY2xpZW50X2lkKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NsaWVudF9pZCBpcyByZXF1aXJlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XHJcbiAgICAgIGdyYW50X3R5cGVzOiBbJ2F1dGhvcml6YXRpb25fY29kZSddLFxyXG4gICAgICBpZF90b2tlbl9zaWduZWRfcmVzcG9uc2VfYWxnOiAnUlMyNTYnLFxyXG4gICAgICBhdXRob3JpemF0aW9uX3NpZ25lZF9yZXNwb25zZV9hbGc6ICdSUzI1NicsXHJcbiAgICAgIHJlc3BvbnNlX3R5cGVzOiBbJ2NvZGUnXSxcclxuICAgICAgdG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2Q6ICdjbGllbnRfc2VjcmV0X2Jhc2ljJyxcclxuICAgICAgLi4uKHRoaXMuZmFwaSgpXHJcbiAgICAgICAgPyB7XHJcbiAgICAgICAgICAgIGdyYW50X3R5cGVzOiBbJ2F1dGhvcml6YXRpb25fY29kZScsICdpbXBsaWNpdCddLFxyXG4gICAgICAgICAgICBpZF90b2tlbl9zaWduZWRfcmVzcG9uc2VfYWxnOiAnUFMyNTYnLFxyXG4gICAgICAgICAgICBhdXRob3JpemF0aW9uX3NpZ25lZF9yZXNwb25zZV9hbGc6ICdQUzI1NicsXHJcbiAgICAgICAgICAgIHJlc3BvbnNlX3R5cGVzOiBbJ2NvZGUgaWRfdG9rZW4nXSxcclxuICAgICAgICAgICAgdGxzX2NsaWVudF9jZXJ0aWZpY2F0ZV9ib3VuZF9hY2Nlc3NfdG9rZW5zOiB0cnVlLFxyXG4gICAgICAgICAgICB0b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIDogdW5kZWZpbmVkKSxcclxuICAgICAgLi4ubWV0YWRhdGEsXHJcbiAgICB9O1xyXG5cclxuICAgIGlmICh0aGlzLmZhcGkoKSkge1xyXG4gICAgICBzd2l0Y2ggKHByb3BlcnRpZXMudG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2QpIHtcclxuICAgICAgICBjYXNlICdzZWxmX3NpZ25lZF90bHNfY2xpZW50X2F1dGgnOlxyXG4gICAgICAgIGNhc2UgJ3Rsc19jbGllbnRfYXV0aCc6XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdwcml2YXRlX2tleV9qd3QnOlxyXG4gICAgICAgICAgaWYgKCFqd2tzKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2p3a3MgaXMgcmVxdWlyZWQnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2QgaXMgcmVxdWlyZWQnKTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBvciB1bnN1cHBvcnRlZCB0b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZCcpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlQ29tbW9uTWlzdGFrZXModGhpcywgbWV0YWRhdGEsIHByb3BlcnRpZXMpO1xyXG5cclxuICAgIGFzc2VydFNpZ25pbmdBbGdWYWx1ZXNTdXBwb3J0KCd0b2tlbicsIHRoaXMuaXNzdWVyLCBwcm9wZXJ0aWVzKTtcclxuICAgIFsnaW50cm9zcGVjdGlvbicsICdyZXZvY2F0aW9uJ10uZm9yRWFjaCgoZW5kcG9pbnQpID0+IHtcclxuICAgICAgZ2V0RGVmYXVsdHNGb3JFbmRwb2ludChlbmRwb2ludCwgdGhpcy5pc3N1ZXIsIHByb3BlcnRpZXMpO1xyXG4gICAgICBhc3NlcnRTaWduaW5nQWxnVmFsdWVzU3VwcG9ydChlbmRwb2ludCwgdGhpcy5pc3N1ZXIsIHByb3BlcnRpZXMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgT2JqZWN0LmVudHJpZXMocHJvcGVydGllcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XHJcbiAgICAgIHRoaXMuI21ldGFkYXRhLnNldChrZXksIHZhbHVlKTtcclxuICAgICAgaWYgKCF0aGlzW2tleV0pIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XHJcbiAgICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNtZXRhZGF0YS5nZXQoa2V5KTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoandrcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNvbnN0IGtleXN0b3JlID0gZ2V0S2V5c3RvcmUuY2FsbCh0aGlzLCBqd2tzKTtcclxuICAgICAga2V5c3RvcmVzLnNldCh0aGlzLCBrZXlzdG9yZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLmFkZGl0aW9uYWxBdXRob3JpemVkUGFydGllcykge1xyXG4gICAgICB0aGlzLiNhZGRpdGlvbmFsQXV0aG9yaXplZFBhcnRpZXMgPSBjbG9uZShvcHRpb25zLmFkZGl0aW9uYWxBdXRob3JpemVkUGFydGllcyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpc1tDTE9DS19UT0xFUkFOQ0VdID0gMDtcclxuICB9XHJcblxyXG4gIGF1dGhvcml6YXRpb25VcmwocGFyYW1zID0ge30pIHtcclxuICAgIGlmICghaXNQbGFpbk9iamVjdChwYXJhbXMpKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtcyBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0Jyk7XHJcbiAgICB9XHJcbiAgICBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uKHRoaXMuaXNzdWVyLCAnYXV0aG9yaXphdGlvbl9lbmRwb2ludCcpO1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gbmV3IFVSTCh0aGlzLmlzc3Vlci5hdXRob3JpemF0aW9uX2VuZHBvaW50KTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXV0aG9yaXphdGlvblBhcmFtcy5jYWxsKHRoaXMsIHBhcmFtcykpKSB7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHRhcmdldC5zZWFyY2hQYXJhbXMuZGVsZXRlKG5hbWUpO1xyXG4gICAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHZhbHVlKSB7XHJcbiAgICAgICAgICB0YXJnZXQuc2VhcmNoUGFyYW1zLmFwcGVuZChuYW1lLCBtZW1iZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0YXJnZXQuc2VhcmNoUGFyYW1zLnNldChuYW1lLCB2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiBpcyB0aGUgcmVwbGFjZSBuZWVkZWQ/XHJcbiAgICByZXR1cm4gdGFyZ2V0LmhyZWYucmVwbGFjZSgvXFwrL2csICclMjAnKTtcclxuICB9XHJcblxyXG4gIGF1dGhvcml6YXRpb25Qb3N0KHBhcmFtcyA9IHt9KSB7XHJcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QocGFyYW1zKSkge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbXMgbXVzdCBiZSBhIHBsYWluIG9iamVjdCcpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW5wdXRzID0gYXV0aG9yaXphdGlvblBhcmFtcy5jYWxsKHRoaXMsIHBhcmFtcyk7XHJcbiAgICBjb25zdCBmb3JtSW5wdXRzID0gT2JqZWN0LmtleXMoaW5wdXRzKVxyXG4gICAgICAubWFwKChuYW1lKSA9PiBgPGlucHV0IHR5cGU9XCJoaWRkZW5cIiBuYW1lPVwiJHtuYW1lfVwiIHZhbHVlPVwiJHtpbnB1dHNbbmFtZV19XCIvPmApXHJcbiAgICAgIC5qb2luKCdcXG4nKTtcclxuXHJcbiAgICByZXR1cm4gYDwhRE9DVFlQRSBodG1sPlxyXG48aGVhZD5cclxuPHRpdGxlPlJlcXVlc3RpbmcgQXV0aG9yaXphdGlvbjwvdGl0bGU+XHJcbjwvaGVhZD5cclxuPGJvZHkgb25sb2FkPVwiamF2YXNjcmlwdDpkb2N1bWVudC5mb3Jtc1swXS5zdWJtaXQoKVwiPlxyXG48Zm9ybSBtZXRob2Q9XCJwb3N0XCIgYWN0aW9uPVwiJHt0aGlzLmlzc3Vlci5hdXRob3JpemF0aW9uX2VuZHBvaW50fVwiPlxyXG4gICR7Zm9ybUlucHV0c31cclxuPC9mb3JtPlxyXG48L2JvZHk+XHJcbjwvaHRtbD5gO1xyXG4gIH1cclxuXHJcbiAgZW5kU2Vzc2lvblVybChwYXJhbXMgPSB7fSkge1xyXG4gICAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbih0aGlzLmlzc3VlciwgJ2VuZF9zZXNzaW9uX2VuZHBvaW50Jyk7XHJcblxyXG4gICAgY29uc3QgeyAwOiBwb3N0TG9nb3V0LCBsZW5ndGggfSA9IHRoaXMucG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpcyB8fCBbXTtcclxuXHJcbiAgICBjb25zdCB7IHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSA9IGxlbmd0aCA9PT0gMSA/IHBvc3RMb2dvdXQgOiB1bmRlZmluZWQgfSA9IHBhcmFtcztcclxuXHJcbiAgICBsZXQgaWRfdG9rZW5faGludDtcclxuICAgICh7IGlkX3Rva2VuX2hpbnQsIC4uLnBhcmFtcyB9ID0gcGFyYW1zKTtcclxuICAgIGlmIChpZF90b2tlbl9oaW50IGluc3RhbmNlb2YgVG9rZW5TZXQpIHtcclxuICAgICAgaWYgKCFpZF90b2tlbl9oaW50LmlkX3Rva2VuKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaWRfdG9rZW4gbm90IHByZXNlbnQgaW4gVG9rZW5TZXQnKTtcclxuICAgICAgfVxyXG4gICAgICBpZF90b2tlbl9oaW50ID0gaWRfdG9rZW5faGludC5pZF90b2tlbjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0YXJnZXQgPSB1cmwucGFyc2UodGhpcy5pc3N1ZXIuZW5kX3Nlc3Npb25fZW5kcG9pbnQpO1xyXG4gICAgY29uc3QgcXVlcnkgPSBkZWZhdWx0cyhcclxuICAgICAgZ2V0U2VhcmNoUGFyYW1zKHRoaXMuaXNzdWVyLmVuZF9zZXNzaW9uX2VuZHBvaW50KSxcclxuICAgICAgcGFyYW1zLFxyXG4gICAgICB7XHJcbiAgICAgICAgcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpLFxyXG4gICAgICAgIGNsaWVudF9pZDogdGhpcy5jbGllbnRfaWQsXHJcbiAgICAgIH0sXHJcbiAgICAgIHsgaWRfdG9rZW5faGludCB9LFxyXG4gICAgKTtcclxuXHJcbiAgICBPYmplY3QuZW50cmllcyhxdWVyeSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XHJcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZGVsZXRlIHF1ZXJ5W2tleV07XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHRhcmdldC5zZWFyY2ggPSBudWxsO1xyXG4gICAgdGFyZ2V0LnF1ZXJ5ID0gcXVlcnk7XHJcblxyXG4gICAgcmV0dXJuIHVybC5mb3JtYXQodGFyZ2V0KTtcclxuICB9XHJcblxyXG4gIGNhbGxiYWNrUGFyYW1zKGlucHV0KSB7XHJcbiAgICBjb25zdCBpc0luY29taW5nTWVzc2FnZSA9XHJcbiAgICAgIGlucHV0IGluc3RhbmNlb2Ygc3RkaHR0cC5JbmNvbWluZ01lc3NhZ2UgfHwgKGlucHV0ICYmIGlucHV0Lm1ldGhvZCAmJiBpbnB1dC51cmwpO1xyXG4gICAgY29uc3QgaXNTdHJpbmcgPSB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnO1xyXG5cclxuICAgIGlmICghaXNTdHJpbmcgJiYgIWlzSW5jb21pbmdNZXNzYWdlKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXHJcbiAgICAgICAgJyNjYWxsYmFja1BhcmFtcyBvbmx5IGFjY2VwdHMgc3RyaW5nIHVybHMsIGh0dHAuSW5jb21pbmdNZXNzYWdlIG9yIGEgbG9va2FsaWtlJyxcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIGlmIChpc0luY29taW5nTWVzc2FnZSkge1xyXG4gICAgICBzd2l0Y2ggKGlucHV0Lm1ldGhvZCkge1xyXG4gICAgICAgIGNhc2UgJ0dFVCc6XHJcbiAgICAgICAgICByZXR1cm4gcGlja0NiKGdldFNlYXJjaFBhcmFtcyhpbnB1dC51cmwpKTtcclxuICAgICAgICBjYXNlICdQT1NUJzpcclxuICAgICAgICAgIGlmIChpbnB1dC5ib2R5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcclxuICAgICAgICAgICAgICAnaW5jb21pbmcgbWVzc2FnZSBib2R5IG1pc3NpbmcsIGluY2x1ZGUgYSBib2R5IHBhcnNlciBwcmlvciB0byB0aGlzIG1ldGhvZCBjYWxsJyxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGlucHV0LmJvZHkpIHtcclxuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcclxuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcclxuICAgICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGlucHV0LmJvZHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGlja0NiKHF1ZXJ5c3RyaW5nLnBhcnNlKGlucHV0LmJvZHkudG9TdHJpbmcoJ3V0Zi04JykpKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC5ib2R5ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBpY2tDYihxdWVyeXN0cmluZy5wYXJzZShpbnB1dC5ib2R5KSk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICByZXR1cm4gcGlja0NiKGlucHV0LmJvZHkpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgSW5jb21pbmdNZXNzYWdlIGJvZHkgb2JqZWN0Jyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgSW5jb21pbmdNZXNzYWdlIG1ldGhvZCcpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gcGlja0NiKGdldFNlYXJjaFBhcmFtcyhpbnB1dCkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgY2FsbGJhY2soXHJcbiAgICByZWRpcmVjdFVyaSxcclxuICAgIHBhcmFtZXRlcnMsXHJcbiAgICBjaGVja3MgPSB7fSxcclxuICAgIHsgZXhjaGFuZ2VCb2R5LCBjbGllbnRBc3NlcnRpb25QYXlsb2FkLCBEUG9QIH0gPSB7fSxcclxuICApIHtcclxuICAgIGxldCBwYXJhbXMgPSBwaWNrQ2IocGFyYW1ldGVycyk7XHJcblxyXG4gICAgaWYgKGNoZWNrcy5qYXJtICYmICEoJ3Jlc3BvbnNlJyBpbiBwYXJhbWV0ZXJzKSkge1xyXG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgICAgbWVzc2FnZTogJ2V4cGVjdGVkIGEgSkFSTSByZXNwb25zZScsXHJcbiAgICAgICAgY2hlY2tzLFxyXG4gICAgICAgIHBhcmFtcyxcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2UgaWYgKCdyZXNwb25zZScgaW4gcGFyYW1ldGVycykge1xyXG4gICAgICBjb25zdCBkZWNyeXB0ZWQgPSBhd2FpdCB0aGlzLmRlY3J5cHRKQVJNKHBhcmFtcy5yZXNwb25zZSk7XHJcbiAgICAgIHBhcmFtcyA9IGF3YWl0IHRoaXMudmFsaWRhdGVKQVJNKGRlY3J5cHRlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuZGVmYXVsdF9tYXhfYWdlICYmICFjaGVja3MubWF4X2FnZSkge1xyXG4gICAgICBjaGVja3MubWF4X2FnZSA9IHRoaXMuZGVmYXVsdF9tYXhfYWdlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChwYXJhbXMuc3RhdGUgJiYgIWNoZWNrcy5zdGF0ZSkge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjaGVja3Muc3RhdGUgYXJndW1lbnQgaXMgbWlzc2luZycpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghcGFyYW1zLnN0YXRlICYmIGNoZWNrcy5zdGF0ZSkge1xyXG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgICAgbWVzc2FnZTogJ3N0YXRlIG1pc3NpbmcgZnJvbSB0aGUgcmVzcG9uc2UnLFxyXG4gICAgICAgIGNoZWNrcyxcclxuICAgICAgICBwYXJhbXMsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjaGVja3Muc3RhdGUgIT09IHBhcmFtcy5zdGF0ZSkge1xyXG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgICAgcHJpbnRmOiBbJ3N0YXRlIG1pc21hdGNoLCBleHBlY3RlZCAlcywgZ290OiAlcycsIGNoZWNrcy5zdGF0ZSwgcGFyYW1zLnN0YXRlXSxcclxuICAgICAgICBjaGVja3MsXHJcbiAgICAgICAgcGFyYW1zLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoJ2lzcycgaW4gcGFyYW1zKSB7XHJcbiAgICAgIGFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24odGhpcy5pc3N1ZXIsICdpc3N1ZXInKTtcclxuICAgICAgaWYgKHBhcmFtcy5pc3MgIT09IHRoaXMuaXNzdWVyLmlzc3Vlcikge1xyXG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcclxuICAgICAgICAgIHByaW50ZjogWydpc3MgbWlzbWF0Y2gsIGV4cGVjdGVkICVzLCBnb3Q6ICVzJywgdGhpcy5pc3N1ZXIuaXNzdWVyLCBwYXJhbXMuaXNzXSxcclxuICAgICAgICAgIHBhcmFtcyxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChcclxuICAgICAgdGhpcy5pc3N1ZXIuYXV0aG9yaXphdGlvbl9yZXNwb25zZV9pc3NfcGFyYW1ldGVyX3N1cHBvcnRlZCAmJlxyXG4gICAgICAhKCdpZF90b2tlbicgaW4gcGFyYW1zKSAmJlxyXG4gICAgICAhKCdyZXNwb25zZScgaW4gcGFyYW1ldGVycylcclxuICAgICkge1xyXG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgICAgbWVzc2FnZTogJ2lzcyBtaXNzaW5nIGZyb20gdGhlIHJlc3BvbnNlJyxcclxuICAgICAgICBwYXJhbXMsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChwYXJhbXMuZXJyb3IpIHtcclxuICAgICAgdGhyb3cgbmV3IE9QRXJyb3IocGFyYW1zKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBSRVNQT05TRV9UWVBFX1JFUVVJUkVEX1BBUkFNUyA9IHtcclxuICAgICAgY29kZTogWydjb2RlJ10sXHJcbiAgICAgIGlkX3Rva2VuOiBbJ2lkX3Rva2VuJ10sXHJcbiAgICAgIHRva2VuOiBbJ2FjY2Vzc190b2tlbicsICd0b2tlbl90eXBlJ10sXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChjaGVja3MucmVzcG9uc2VfdHlwZSkge1xyXG4gICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgY2hlY2tzLnJlc3BvbnNlX3R5cGUuc3BsaXQoJyAnKSkge1xyXG4gICAgICAgIGlmICh0eXBlID09PSAnbm9uZScpIHtcclxuICAgICAgICAgIGlmIChwYXJhbXMuY29kZSB8fCBwYXJhbXMuaWRfdG9rZW4gfHwgcGFyYW1zLmFjY2Vzc190b2tlbikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ3VuZXhwZWN0ZWQgcGFyYW1zIGVuY291bnRlcmVkIGZvciBcIm5vbmVcIiByZXNwb25zZScsXHJcbiAgICAgICAgICAgICAgY2hlY2tzLFxyXG4gICAgICAgICAgICAgIHBhcmFtcyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZvciAoY29uc3QgcGFyYW0gb2YgUkVTUE9OU0VfVFlQRV9SRVFVSVJFRF9QQVJBTVNbdHlwZV0pIHtcclxuICAgICAgICAgICAgaWYgKCFwYXJhbXNbcGFyYW1dKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYCR7cGFyYW19IG1pc3NpbmcgZnJvbSByZXNwb25zZWAsXHJcbiAgICAgICAgICAgICAgICBjaGVja3MsXHJcbiAgICAgICAgICAgICAgICBwYXJhbXMsXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAocGFyYW1zLmlkX3Rva2VuKSB7XHJcbiAgICAgIGNvbnN0IHRva2Vuc2V0ID0gbmV3IFRva2VuU2V0KHBhcmFtcyk7XHJcbiAgICAgIGF3YWl0IHRoaXMuZGVjcnlwdElkVG9rZW4odG9rZW5zZXQpO1xyXG4gICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlSWRUb2tlbihcclxuICAgICAgICB0b2tlbnNldCxcclxuICAgICAgICBjaGVja3Mubm9uY2UsXHJcbiAgICAgICAgJ2F1dGhvcml6YXRpb24nLFxyXG4gICAgICAgIGNoZWNrcy5tYXhfYWdlLFxyXG4gICAgICAgIGNoZWNrcy5zdGF0ZSxcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGlmICghcGFyYW1zLmNvZGUpIHtcclxuICAgICAgICByZXR1cm4gdG9rZW5zZXQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAocGFyYW1zLmNvZGUpIHtcclxuICAgICAgY29uc3QgdG9rZW5zZXQgPSBhd2FpdCB0aGlzLmdyYW50KFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIC4uLmV4Y2hhbmdlQm9keSxcclxuICAgICAgICAgIGdyYW50X3R5cGU6ICdhdXRob3JpemF0aW9uX2NvZGUnLFxyXG4gICAgICAgICAgY29kZTogcGFyYW1zLmNvZGUsXHJcbiAgICAgICAgICByZWRpcmVjdF91cmk6IHJlZGlyZWN0VXJpLFxyXG4gICAgICAgICAgY29kZV92ZXJpZmllcjogY2hlY2tzLmNvZGVfdmVyaWZpZXIsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7IGNsaWVudEFzc2VydGlvblBheWxvYWQsIERQb1AgfSxcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGF3YWl0IHRoaXMuZGVjcnlwdElkVG9rZW4odG9rZW5zZXQpO1xyXG4gICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlSWRUb2tlbih0b2tlbnNldCwgY2hlY2tzLm5vbmNlLCAndG9rZW4nLCBjaGVja3MubWF4X2FnZSk7XHJcblxyXG4gICAgICBpZiAocGFyYW1zLnNlc3Npb25fc3RhdGUpIHtcclxuICAgICAgICB0b2tlbnNldC5zZXNzaW9uX3N0YXRlID0gcGFyYW1zLnNlc3Npb25fc3RhdGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0b2tlbnNldDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFRva2VuU2V0KHBhcmFtcyk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBvYXV0aENhbGxiYWNrKFxyXG4gICAgcmVkaXJlY3RVcmksXHJcbiAgICBwYXJhbWV0ZXJzLFxyXG4gICAgY2hlY2tzID0ge30sXHJcbiAgICB7IGV4Y2hhbmdlQm9keSwgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCwgRFBvUCB9ID0ge30sXHJcbiAgKSB7XHJcbiAgICBsZXQgcGFyYW1zID0gcGlja0NiKHBhcmFtZXRlcnMpO1xyXG5cclxuICAgIGlmIChjaGVja3MuamFybSAmJiAhKCdyZXNwb25zZScgaW4gcGFyYW1ldGVycykpIHtcclxuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdleHBlY3RlZCBhIEpBUk0gcmVzcG9uc2UnLFxyXG4gICAgICAgIGNoZWNrcyxcclxuICAgICAgICBwYXJhbXMsXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIGlmICgncmVzcG9uc2UnIGluIHBhcmFtZXRlcnMpIHtcclxuICAgICAgY29uc3QgZGVjcnlwdGVkID0gYXdhaXQgdGhpcy5kZWNyeXB0SkFSTShwYXJhbXMucmVzcG9uc2UpO1xyXG4gICAgICBwYXJhbXMgPSBhd2FpdCB0aGlzLnZhbGlkYXRlSkFSTShkZWNyeXB0ZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChwYXJhbXMuc3RhdGUgJiYgIWNoZWNrcy5zdGF0ZSkge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjaGVja3Muc3RhdGUgYXJndW1lbnQgaXMgbWlzc2luZycpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghcGFyYW1zLnN0YXRlICYmIGNoZWNrcy5zdGF0ZSkge1xyXG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgICAgbWVzc2FnZTogJ3N0YXRlIG1pc3NpbmcgZnJvbSB0aGUgcmVzcG9uc2UnLFxyXG4gICAgICAgIGNoZWNrcyxcclxuICAgICAgICBwYXJhbXMsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjaGVja3Muc3RhdGUgIT09IHBhcmFtcy5zdGF0ZSkge1xyXG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgICAgcHJpbnRmOiBbJ3N0YXRlIG1pc21hdGNoLCBleHBlY3RlZCAlcywgZ290OiAlcycsIGNoZWNrcy5zdGF0ZSwgcGFyYW1zLnN0YXRlXSxcclxuICAgICAgICBjaGVja3MsXHJcbiAgICAgICAgcGFyYW1zLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoJ2lzcycgaW4gcGFyYW1zKSB7XHJcbiAgICAgIGFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24odGhpcy5pc3N1ZXIsICdpc3N1ZXInKTtcclxuICAgICAgaWYgKHBhcmFtcy5pc3MgIT09IHRoaXMuaXNzdWVyLmlzc3Vlcikge1xyXG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcclxuICAgICAgICAgIHByaW50ZjogWydpc3MgbWlzbWF0Y2gsIGV4cGVjdGVkICVzLCBnb3Q6ICVzJywgdGhpcy5pc3N1ZXIuaXNzdWVyLCBwYXJhbXMuaXNzXSxcclxuICAgICAgICAgIHBhcmFtcyxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChcclxuICAgICAgdGhpcy5pc3N1ZXIuYXV0aG9yaXphdGlvbl9yZXNwb25zZV9pc3NfcGFyYW1ldGVyX3N1cHBvcnRlZCAmJlxyXG4gICAgICAhKCdpZF90b2tlbicgaW4gcGFyYW1zKSAmJlxyXG4gICAgICAhKCdyZXNwb25zZScgaW4gcGFyYW1ldGVycylcclxuICAgICkge1xyXG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgICAgbWVzc2FnZTogJ2lzcyBtaXNzaW5nIGZyb20gdGhlIHJlc3BvbnNlJyxcclxuICAgICAgICBwYXJhbXMsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChwYXJhbXMuZXJyb3IpIHtcclxuICAgICAgdGhyb3cgbmV3IE9QRXJyb3IocGFyYW1zKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIHBhcmFtcy5pZF90b2tlbiA9PT0gJ3N0cmluZycgJiYgcGFyYW1zLmlkX3Rva2VuLmxlbmd0aCkge1xyXG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgICAgbWVzc2FnZTpcclxuICAgICAgICAgICdpZF90b2tlbiBkZXRlY3RlZCBpbiB0aGUgcmVzcG9uc2UsIHlvdSBtdXN0IHVzZSBjbGllbnQuY2FsbGJhY2soKSBpbnN0ZWFkIG9mIGNsaWVudC5vYXV0aENhbGxiYWNrKCknLFxyXG4gICAgICAgIHBhcmFtcyxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBkZWxldGUgcGFyYW1zLmlkX3Rva2VuO1xyXG5cclxuICAgIGNvbnN0IFJFU1BPTlNFX1RZUEVfUkVRVUlSRURfUEFSQU1TID0ge1xyXG4gICAgICBjb2RlOiBbJ2NvZGUnXSxcclxuICAgICAgdG9rZW46IFsnYWNjZXNzX3Rva2VuJywgJ3Rva2VuX3R5cGUnXSxcclxuICAgIH07XHJcblxyXG4gICAgaWYgKGNoZWNrcy5yZXNwb25zZV90eXBlKSB7XHJcbiAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBjaGVja3MucmVzcG9uc2VfdHlwZS5zcGxpdCgnICcpKSB7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdub25lJykge1xyXG4gICAgICAgICAgaWYgKHBhcmFtcy5jb2RlIHx8IHBhcmFtcy5pZF90b2tlbiB8fCBwYXJhbXMuYWNjZXNzX3Rva2VuKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcclxuICAgICAgICAgICAgICBtZXNzYWdlOiAndW5leHBlY3RlZCBwYXJhbXMgZW5jb3VudGVyZWQgZm9yIFwibm9uZVwiIHJlc3BvbnNlJyxcclxuICAgICAgICAgICAgICBjaGVja3MsXHJcbiAgICAgICAgICAgICAgcGFyYW1zLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChSRVNQT05TRV9UWVBFX1JFUVVJUkVEX1BBUkFNU1t0eXBlXSkge1xyXG4gICAgICAgICAgZm9yIChjb25zdCBwYXJhbSBvZiBSRVNQT05TRV9UWVBFX1JFUVVJUkVEX1BBUkFNU1t0eXBlXSkge1xyXG4gICAgICAgICAgICBpZiAoIXBhcmFtc1twYXJhbV0pIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgJHtwYXJhbX0gbWlzc2luZyBmcm9tIHJlc3BvbnNlYCxcclxuICAgICAgICAgICAgICAgIGNoZWNrcyxcclxuICAgICAgICAgICAgICAgIHBhcmFtcyxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChwYXJhbXMuY29kZSkge1xyXG4gICAgICBjb25zdCB0b2tlbnNldCA9IGF3YWl0IHRoaXMuZ3JhbnQoXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgLi4uZXhjaGFuZ2VCb2R5LFxyXG4gICAgICAgICAgZ3JhbnRfdHlwZTogJ2F1dGhvcml6YXRpb25fY29kZScsXHJcbiAgICAgICAgICBjb2RlOiBwYXJhbXMuY29kZSxcclxuICAgICAgICAgIHJlZGlyZWN0X3VyaTogcmVkaXJlY3RVcmksXHJcbiAgICAgICAgICBjb2RlX3ZlcmlmaWVyOiBjaGVja3MuY29kZV92ZXJpZmllcixcclxuICAgICAgICB9LFxyXG4gICAgICAgIHsgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCwgRFBvUCB9LFxyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiB0b2tlbnNldC5pZF90b2tlbiA9PT0gJ3N0cmluZycgJiYgdG9rZW5zZXQuaWRfdG9rZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xyXG4gICAgICAgICAgbWVzc2FnZTpcclxuICAgICAgICAgICAgJ2lkX3Rva2VuIGRldGVjdGVkIGluIHRoZSByZXNwb25zZSwgeW91IG11c3QgdXNlIGNsaWVudC5jYWxsYmFjaygpIGluc3RlYWQgb2YgY2xpZW50Lm9hdXRoQ2FsbGJhY2soKScsXHJcbiAgICAgICAgICBwYXJhbXMsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgZGVsZXRlIHRva2Vuc2V0LmlkX3Rva2VuO1xyXG5cclxuICAgICAgcmV0dXJuIHRva2Vuc2V0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgVG9rZW5TZXQocGFyYW1zKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGRlY3J5cHRJZFRva2VuKHRva2VuKSB7XHJcbiAgICBpZiAoIXRoaXMuaWRfdG9rZW5fZW5jcnlwdGVkX3Jlc3BvbnNlX2FsZykge1xyXG4gICAgICByZXR1cm4gdG9rZW47XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGlkVG9rZW4gPSB0b2tlbjtcclxuXHJcbiAgICBpZiAoaWRUb2tlbiBpbnN0YW5jZW9mIFRva2VuU2V0KSB7XHJcbiAgICAgIGlmICghaWRUb2tlbi5pZF90b2tlbikge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lkX3Rva2VuIG5vdCBwcmVzZW50IGluIFRva2VuU2V0Jyk7XHJcbiAgICAgIH1cclxuICAgICAgaWRUb2tlbiA9IGlkVG9rZW4uaWRfdG9rZW47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZXhwZWN0ZWRBbGcgPSB0aGlzLmlkX3Rva2VuX2VuY3J5cHRlZF9yZXNwb25zZV9hbGc7XHJcbiAgICBjb25zdCBleHBlY3RlZEVuYyA9IHRoaXMuaWRfdG9rZW5fZW5jcnlwdGVkX3Jlc3BvbnNlX2VuYztcclxuXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmRlY3J5cHRKV0UoaWRUb2tlbiwgZXhwZWN0ZWRBbGcsIGV4cGVjdGVkRW5jKTtcclxuXHJcbiAgICBpZiAodG9rZW4gaW5zdGFuY2VvZiBUb2tlblNldCkge1xyXG4gICAgICB0b2tlbi5pZF90b2tlbiA9IHJlc3VsdDtcclxuICAgICAgcmV0dXJuIHRva2VuO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBhc3luYyB2YWxpZGF0ZUpXVFVzZXJpbmZvKGJvZHkpIHtcclxuICAgIGNvbnN0IGV4cGVjdGVkQWxnID0gdGhpcy51c2VyaW5mb19zaWduZWRfcmVzcG9uc2VfYWxnO1xyXG5cclxuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlSldUKGJvZHksIGV4cGVjdGVkQWxnLCBbXSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBkZWNyeXB0SkFSTShyZXNwb25zZSkge1xyXG4gICAgaWYgKCF0aGlzLmF1dGhvcml6YXRpb25fZW5jcnlwdGVkX3Jlc3BvbnNlX2FsZykge1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZXhwZWN0ZWRBbGcgPSB0aGlzLmF1dGhvcml6YXRpb25fZW5jcnlwdGVkX3Jlc3BvbnNlX2FsZztcclxuICAgIGNvbnN0IGV4cGVjdGVkRW5jID0gdGhpcy5hdXRob3JpemF0aW9uX2VuY3J5cHRlZF9yZXNwb25zZV9lbmM7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZGVjcnlwdEpXRShyZXNwb25zZSwgZXhwZWN0ZWRBbGcsIGV4cGVjdGVkRW5jKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGRlY3J5cHRKV1RVc2VyaW5mbyhib2R5KSB7XHJcbiAgICBpZiAoIXRoaXMudXNlcmluZm9fZW5jcnlwdGVkX3Jlc3BvbnNlX2FsZykge1xyXG4gICAgICByZXR1cm4gYm9keTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBleHBlY3RlZEFsZyA9IHRoaXMudXNlcmluZm9fZW5jcnlwdGVkX3Jlc3BvbnNlX2FsZztcclxuICAgIGNvbnN0IGV4cGVjdGVkRW5jID0gdGhpcy51c2VyaW5mb19lbmNyeXB0ZWRfcmVzcG9uc2VfZW5jO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmRlY3J5cHRKV0UoYm9keSwgZXhwZWN0ZWRBbGcsIGV4cGVjdGVkRW5jKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGRlY3J5cHRKV0UoandlLCBleHBlY3RlZEFsZywgZXhwZWN0ZWRFbmMgPSAnQTEyOENCQy1IUzI1NicpIHtcclxuICAgIGNvbnN0IGhlYWRlciA9IEpTT04ucGFyc2UoYmFzZTY0dXJsLmRlY29kZShqd2Uuc3BsaXQoJy4nKVswXSkpO1xyXG5cclxuICAgIGlmIChoZWFkZXIuYWxnICE9PSBleHBlY3RlZEFsZykge1xyXG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgICAgcHJpbnRmOiBbJ3VuZXhwZWN0ZWQgSldFIGFsZyByZWNlaXZlZCwgZXhwZWN0ZWQgJXMsIGdvdDogJXMnLCBleHBlY3RlZEFsZywgaGVhZGVyLmFsZ10sXHJcbiAgICAgICAgand0OiBqd2UsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChoZWFkZXIuZW5jICE9PSBleHBlY3RlZEVuYykge1xyXG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgICAgcHJpbnRmOiBbJ3VuZXhwZWN0ZWQgSldFIGVuYyByZWNlaXZlZCwgZXhwZWN0ZWQgJXMsIGdvdDogJXMnLCBleHBlY3RlZEVuYywgaGVhZGVyLmVuY10sXHJcbiAgICAgICAgand0OiBqd2UsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGdldFBsYWludGV4dCA9IChyZXN1bHQpID0+IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShyZXN1bHQucGxhaW50ZXh0KTtcclxuICAgIGxldCBwbGFpbnRleHQ7XHJcbiAgICBpZiAoZXhwZWN0ZWRBbGcubWF0Y2goL14oPzpSU0F8RUNESCkvKSkge1xyXG4gICAgICBjb25zdCBrZXlzdG9yZSA9IGF3YWl0IGtleXN0b3Jlcy5nZXQodGhpcyk7XHJcblxyXG4gICAgICBjb25zdCBwcm90ZWN0ZWRIZWFkZXIgPSBqb3NlLmRlY29kZVByb3RlY3RlZEhlYWRlcihqd2UpO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5c3RvcmUuYWxsKHtcclxuICAgICAgICAuLi5wcm90ZWN0ZWRIZWFkZXIsXHJcbiAgICAgICAgdXNlOiAnZW5jJyxcclxuICAgICAgfSkpIHtcclxuICAgICAgICBwbGFpbnRleHQgPSBhd2FpdCBqb3NlXHJcbiAgICAgICAgICAuY29tcGFjdERlY3J5cHQoandlLCBhd2FpdCBrZXkua2V5T2JqZWN0KHByb3RlY3RlZEhlYWRlci5hbGcpKVxyXG4gICAgICAgICAgLnRoZW4oZ2V0UGxhaW50ZXh0LCAoKSA9PiB7fSk7XHJcbiAgICAgICAgaWYgKHBsYWludGV4dCkgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBsYWludGV4dCA9IGF3YWl0IGpvc2VcclxuICAgICAgICAuY29tcGFjdERlY3J5cHQoandlLCB0aGlzLnNlY3JldEZvckFsZyhleHBlY3RlZEFsZyA9PT0gJ2RpcicgPyBleHBlY3RlZEVuYyA6IGV4cGVjdGVkQWxnKSlcclxuICAgICAgICAudGhlbihnZXRQbGFpbnRleHQsICgpID0+IHt9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXBsYWludGV4dCkge1xyXG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgICAgbWVzc2FnZTogJ2ZhaWxlZCB0byBkZWNyeXB0IEpXRScsXHJcbiAgICAgICAgand0OiBqd2UsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBsYWludGV4dDtcclxuICB9XHJcblxyXG4gIGFzeW5jIHZhbGlkYXRlSWRUb2tlbih0b2tlblNldCwgbm9uY2UsIHJldHVybmVkQnksIG1heEFnZSwgc3RhdGUpIHtcclxuICAgIGxldCBpZFRva2VuID0gdG9rZW5TZXQ7XHJcblxyXG4gICAgY29uc3QgZXhwZWN0ZWRBbGcgPSB0aGlzLmlkX3Rva2VuX3NpZ25lZF9yZXNwb25zZV9hbGc7XHJcblxyXG4gICAgY29uc3QgaXNUb2tlblNldCA9IGlkVG9rZW4gaW5zdGFuY2VvZiBUb2tlblNldDtcclxuXHJcbiAgICBpZiAoaXNUb2tlblNldCkge1xyXG4gICAgICBpZiAoIWlkVG9rZW4uaWRfdG9rZW4pIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpZF90b2tlbiBub3QgcHJlc2VudCBpbiBUb2tlblNldCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGlkVG9rZW4gPSBpZFRva2VuLmlkX3Rva2VuO1xyXG4gICAgfVxyXG5cclxuICAgIGlkVG9rZW4gPSBTdHJpbmcoaWRUb2tlbik7XHJcblxyXG4gICAgY29uc3QgdGltZXN0YW1wID0gbm93KCk7XHJcbiAgICBjb25zdCB7IHByb3RlY3RlZDogaGVhZGVyLCBwYXlsb2FkLCBrZXkgfSA9IGF3YWl0IHRoaXMudmFsaWRhdGVKV1QoaWRUb2tlbiwgZXhwZWN0ZWRBbGcpO1xyXG5cclxuICAgIGlmICh0eXBlb2YgbWF4QWdlID09PSAnbnVtYmVyJyB8fCAobWF4QWdlICE9PSBza2lwTWF4QWdlQ2hlY2sgJiYgdGhpcy5yZXF1aXJlX2F1dGhfdGltZSkpIHtcclxuICAgICAgaWYgKCFwYXlsb2FkLmF1dGhfdGltZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcclxuICAgICAgICAgIG1lc3NhZ2U6ICdtaXNzaW5nIHJlcXVpcmVkIEpXVCBwcm9wZXJ0eSBhdXRoX3RpbWUnLFxyXG4gICAgICAgICAgand0OiBpZFRva2VuLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0eXBlb2YgcGF5bG9hZC5hdXRoX3RpbWUgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xyXG4gICAgICAgICAgbWVzc2FnZTogJ0pXVCBhdXRoX3RpbWUgY2xhaW0gbXVzdCBiZSBhIEpTT04gbnVtZXJpYyB2YWx1ZScsXHJcbiAgICAgICAgICBqd3Q6IGlkVG9rZW4sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIHR5cGVvZiBtYXhBZ2UgPT09ICdudW1iZXInICYmXHJcbiAgICAgIHBheWxvYWQuYXV0aF90aW1lICsgbWF4QWdlIDwgdGltZXN0YW1wIC0gdGhpc1tDTE9DS19UT0xFUkFOQ0VdXHJcbiAgICApIHtcclxuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xyXG4gICAgICAgIHByaW50ZjogW1xyXG4gICAgICAgICAgJ3RvbyBtdWNoIHRpbWUgaGFzIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgRW5kLVVzZXIgYXV0aGVudGljYXRpb24sIG1heF9hZ2UgJWksIGF1dGhfdGltZTogJWksIG5vdyAlaScsXHJcbiAgICAgICAgICBtYXhBZ2UsXHJcbiAgICAgICAgICBwYXlsb2FkLmF1dGhfdGltZSxcclxuICAgICAgICAgIHRpbWVzdGFtcCAtIHRoaXNbQ0xPQ0tfVE9MRVJBTkNFXSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIG5vdzogdGltZXN0YW1wLFxyXG4gICAgICAgIHRvbGVyYW5jZTogdGhpc1tDTE9DS19UT0xFUkFOQ0VdLFxyXG4gICAgICAgIGF1dGhfdGltZTogcGF5bG9hZC5hdXRoX3RpbWUsXHJcbiAgICAgICAgand0OiBpZFRva2VuLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIG5vbmNlICE9PSBza2lwTm9uY2VDaGVjayAmJlxyXG4gICAgICAocGF5bG9hZC5ub25jZSB8fCBub25jZSAhPT0gdW5kZWZpbmVkKSAmJlxyXG4gICAgICBwYXlsb2FkLm5vbmNlICE9PSBub25jZVxyXG4gICAgKSB7XHJcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcclxuICAgICAgICBwcmludGY6IFsnbm9uY2UgbWlzbWF0Y2gsIGV4cGVjdGVkICVzLCBnb3Q6ICVzJywgbm9uY2UsIHBheWxvYWQubm9uY2VdLFxyXG4gICAgICAgIGp3dDogaWRUb2tlbixcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJldHVybmVkQnkgPT09ICdhdXRob3JpemF0aW9uJykge1xyXG4gICAgICBpZiAoIXBheWxvYWQuYXRfaGFzaCAmJiB0b2tlblNldC5hY2Nlc3NfdG9rZW4pIHtcclxuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgICAgICBtZXNzYWdlOiAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBhdF9oYXNoJyxcclxuICAgICAgICAgIGp3dDogaWRUb2tlbixcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFwYXlsb2FkLmNfaGFzaCAmJiB0b2tlblNldC5jb2RlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xyXG4gICAgICAgICAgbWVzc2FnZTogJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgY19oYXNoJyxcclxuICAgICAgICAgIGp3dDogaWRUb2tlbixcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuZmFwaSgpKSB7XHJcbiAgICAgICAgaWYgKCFwYXlsb2FkLnNfaGFzaCAmJiAodG9rZW5TZXQuc3RhdGUgfHwgc3RhdGUpKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5IHNfaGFzaCcsXHJcbiAgICAgICAgICAgIGp3dDogaWRUb2tlbixcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHBheWxvYWQuc19oYXNoKSB7XHJcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHZlcmlmeSBzX2hhc2gsIFwiY2hlY2tzLnN0YXRlXCIgcHJvcGVydHkgbm90IHByb3ZpZGVkJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgdG9rZW5IYXNoLnZhbGlkYXRlKFxyXG4gICAgICAgICAgICB7IGNsYWltOiAnc19oYXNoJywgc291cmNlOiAnc3RhdGUnIH0sXHJcbiAgICAgICAgICAgIHBheWxvYWQuc19oYXNoLFxyXG4gICAgICAgICAgICBzdGF0ZSxcclxuICAgICAgICAgICAgaGVhZGVyLmFsZyxcclxuICAgICAgICAgICAga2V5Lmp3ayAmJiBrZXkuandrLmNydixcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7IG1lc3NhZ2U6IGVyci5tZXNzYWdlLCBqd3Q6IGlkVG9rZW4gfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuZmFwaSgpICYmIHBheWxvYWQuaWF0IDwgdGltZXN0YW1wIC0gMzYwMCkge1xyXG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgICAgcHJpbnRmOiBbJ0pXVCBpc3N1ZWQgdG9vIGZhciBpbiB0aGUgcGFzdCwgbm93ICVpLCBpYXQgJWknLCB0aW1lc3RhbXAsIHBheWxvYWQuaWF0XSxcclxuICAgICAgICBub3c6IHRpbWVzdGFtcCxcclxuICAgICAgICB0b2xlcmFuY2U6IHRoaXNbQ0xPQ0tfVE9MRVJBTkNFXSxcclxuICAgICAgICBpYXQ6IHBheWxvYWQuaWF0LFxyXG4gICAgICAgIGp3dDogaWRUb2tlbixcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRva2VuU2V0LmFjY2Vzc190b2tlbiAmJiBwYXlsb2FkLmF0X2hhc2ggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHRva2VuSGFzaC52YWxpZGF0ZShcclxuICAgICAgICAgIHsgY2xhaW06ICdhdF9oYXNoJywgc291cmNlOiAnYWNjZXNzX3Rva2VuJyB9LFxyXG4gICAgICAgICAgcGF5bG9hZC5hdF9oYXNoLFxyXG4gICAgICAgICAgdG9rZW5TZXQuYWNjZXNzX3Rva2VuLFxyXG4gICAgICAgICAgaGVhZGVyLmFsZyxcclxuICAgICAgICAgIGtleS5qd2sgJiYga2V5Lmp3ay5jcnYsXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3IoeyBtZXNzYWdlOiBlcnIubWVzc2FnZSwgand0OiBpZFRva2VuIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRva2VuU2V0LmNvZGUgJiYgcGF5bG9hZC5jX2hhc2ggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHRva2VuSGFzaC52YWxpZGF0ZShcclxuICAgICAgICAgIHsgY2xhaW06ICdjX2hhc2gnLCBzb3VyY2U6ICdjb2RlJyB9LFxyXG4gICAgICAgICAgcGF5bG9hZC5jX2hhc2gsXHJcbiAgICAgICAgICB0b2tlblNldC5jb2RlLFxyXG4gICAgICAgICAgaGVhZGVyLmFsZyxcclxuICAgICAgICAgIGtleS5qd2sgJiYga2V5Lmp3ay5jcnYsXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3IoeyBtZXNzYWdlOiBlcnIubWVzc2FnZSwgand0OiBpZFRva2VuIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRva2VuU2V0O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgdmFsaWRhdGVKV1Qoand0LCBleHBlY3RlZEFsZywgcmVxdWlyZWQgPSBbJ2lzcycsICdzdWInLCAnYXVkJywgJ2V4cCcsICdpYXQnXSkge1xyXG4gICAgY29uc3QgaXNTZWxmSXNzdWVkID0gdGhpcy5pc3N1ZXIuaXNzdWVyID09PSAnaHR0cHM6Ly9zZWxmLWlzc3VlZC5tZSc7XHJcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBub3coKTtcclxuICAgIGxldCBoZWFkZXI7XHJcbiAgICBsZXQgcGF5bG9hZDtcclxuICAgIHRyeSB7XHJcbiAgICAgICh7IGhlYWRlciwgcGF5bG9hZCB9ID0gZGVjb2RlSldUKGp3dCwgeyBjb21wbGV0ZTogdHJ1ZSB9KSk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xyXG4gICAgICAgIHByaW50ZjogWydmYWlsZWQgdG8gZGVjb2RlIEpXVCAoJXM6ICVzKScsIGVyci5uYW1lLCBlcnIubWVzc2FnZV0sXHJcbiAgICAgICAgand0LFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaGVhZGVyLmFsZyAhPT0gZXhwZWN0ZWRBbGcpIHtcclxuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xyXG4gICAgICAgIHByaW50ZjogWyd1bmV4cGVjdGVkIEpXVCBhbGcgcmVjZWl2ZWQsIGV4cGVjdGVkICVzLCBnb3Q6ICVzJywgZXhwZWN0ZWRBbGcsIGhlYWRlci5hbGddLFxyXG4gICAgICAgIGp3dCxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzU2VsZklzc3VlZCkge1xyXG4gICAgICByZXF1aXJlZCA9IFsuLi5yZXF1aXJlZCwgJ3N1Yl9qd2snXTtcclxuICAgIH1cclxuXHJcbiAgICByZXF1aXJlZC5mb3JFYWNoKHZlcmlmeVByZXNlbmNlLmJpbmQodW5kZWZpbmVkLCBwYXlsb2FkLCBqd3QpKTtcclxuXHJcbiAgICBpZiAocGF5bG9hZC5pc3MgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBsZXQgZXhwZWN0ZWRJc3MgPSB0aGlzLmlzc3Vlci5pc3N1ZXI7XHJcblxyXG4gICAgICBpZiAodGhpcy4jYWFkSXNzVmFsaWRhdGlvbikge1xyXG4gICAgICAgIGV4cGVjdGVkSXNzID0gdGhpcy5pc3N1ZXIuaXNzdWVyLnJlcGxhY2UoJ3t0ZW5hbnRpZH0nLCBwYXlsb2FkLnRpZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChwYXlsb2FkLmlzcyAhPT0gZXhwZWN0ZWRJc3MpIHtcclxuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgICAgICBwcmludGY6IFsndW5leHBlY3RlZCBpc3MgdmFsdWUsIGV4cGVjdGVkICVzLCBnb3Q6ICVzJywgZXhwZWN0ZWRJc3MsIHBheWxvYWQuaXNzXSxcclxuICAgICAgICAgIGp3dCxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChwYXlsb2FkLmlhdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgcGF5bG9hZC5pYXQgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xyXG4gICAgICAgICAgbWVzc2FnZTogJ0pXVCBpYXQgY2xhaW0gbXVzdCBiZSBhIEpTT04gbnVtZXJpYyB2YWx1ZScsXHJcbiAgICAgICAgICBqd3QsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAocGF5bG9hZC5uYmYgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpZiAodHlwZW9mIHBheWxvYWQubmJmICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcclxuICAgICAgICAgIG1lc3NhZ2U6ICdKV1QgbmJmIGNsYWltIG11c3QgYmUgYSBKU09OIG51bWVyaWMgdmFsdWUnLFxyXG4gICAgICAgICAgand0LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwYXlsb2FkLm5iZiA+IHRpbWVzdGFtcCArIHRoaXNbQ0xPQ0tfVE9MRVJBTkNFXSkge1xyXG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcclxuICAgICAgICAgIHByaW50ZjogW1xyXG4gICAgICAgICAgICAnSldUIG5vdCBhY3RpdmUgeWV0LCBub3cgJWksIG5iZiAlaScsXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcCArIHRoaXNbQ0xPQ0tfVE9MRVJBTkNFXSxcclxuICAgICAgICAgICAgcGF5bG9hZC5uYmYsXHJcbiAgICAgICAgICBdLFxyXG4gICAgICAgICAgbm93OiB0aW1lc3RhbXAsXHJcbiAgICAgICAgICB0b2xlcmFuY2U6IHRoaXNbQ0xPQ0tfVE9MRVJBTkNFXSxcclxuICAgICAgICAgIG5iZjogcGF5bG9hZC5uYmYsXHJcbiAgICAgICAgICBqd3QsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAocGF5bG9hZC5leHAgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpZiAodHlwZW9mIHBheWxvYWQuZXhwICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcclxuICAgICAgICAgIG1lc3NhZ2U6ICdKV1QgZXhwIGNsYWltIG11c3QgYmUgYSBKU09OIG51bWVyaWMgdmFsdWUnLFxyXG4gICAgICAgICAgand0LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aW1lc3RhbXAgLSB0aGlzW0NMT0NLX1RPTEVSQU5DRV0gPj0gcGF5bG9hZC5leHApIHtcclxuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgICAgICBwcmludGY6IFsnSldUIGV4cGlyZWQsIG5vdyAlaSwgZXhwICVpJywgdGltZXN0YW1wIC0gdGhpc1tDTE9DS19UT0xFUkFOQ0VdLCBwYXlsb2FkLmV4cF0sXHJcbiAgICAgICAgICBub3c6IHRpbWVzdGFtcCxcclxuICAgICAgICAgIHRvbGVyYW5jZTogdGhpc1tDTE9DS19UT0xFUkFOQ0VdLFxyXG4gICAgICAgICAgZXhwOiBwYXlsb2FkLmV4cCxcclxuICAgICAgICAgIGp3dCxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChwYXlsb2FkLmF1ZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQuYXVkKSkge1xyXG4gICAgICAgIGlmIChwYXlsb2FkLmF1ZC5sZW5ndGggPiAxICYmICFwYXlsb2FkLmF6cCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xyXG4gICAgICAgICAgICBtZXNzYWdlOiAnbWlzc2luZyByZXF1aXJlZCBKV1QgcHJvcGVydHkgYXpwJyxcclxuICAgICAgICAgICAgand0LFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXBheWxvYWQuYXVkLmluY2x1ZGVzKHRoaXMuY2xpZW50X2lkKSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xyXG4gICAgICAgICAgICBwcmludGY6IFtcclxuICAgICAgICAgICAgICAnYXVkIGlzIG1pc3NpbmcgdGhlIGNsaWVudF9pZCwgZXhwZWN0ZWQgJXMgdG8gYmUgaW5jbHVkZWQgaW4gJWonLFxyXG4gICAgICAgICAgICAgIHRoaXMuY2xpZW50X2lkLFxyXG4gICAgICAgICAgICAgIHBheWxvYWQuYXVkLFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBqd3QsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAocGF5bG9hZC5hdWQgIT09IHRoaXMuY2xpZW50X2lkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xyXG4gICAgICAgICAgcHJpbnRmOiBbJ2F1ZCBtaXNtYXRjaCwgZXhwZWN0ZWQgJXMsIGdvdDogJXMnLCB0aGlzLmNsaWVudF9pZCwgcGF5bG9hZC5hdWRdLFxyXG4gICAgICAgICAgand0LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHBheWxvYWQuYXpwICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgbGV0IGFkZGl0aW9uYWxBdXRob3JpemVkUGFydGllcyA9IHRoaXMuI2FkZGl0aW9uYWxBdXRob3JpemVkUGFydGllcztcclxuXHJcbiAgICAgIGlmICh0eXBlb2YgYWRkaXRpb25hbEF1dGhvcml6ZWRQYXJ0aWVzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGFkZGl0aW9uYWxBdXRob3JpemVkUGFydGllcyA9IFt0aGlzLmNsaWVudF9pZCwgYWRkaXRpb25hbEF1dGhvcml6ZWRQYXJ0aWVzXTtcclxuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFkZGl0aW9uYWxBdXRob3JpemVkUGFydGllcykpIHtcclxuICAgICAgICBhZGRpdGlvbmFsQXV0aG9yaXplZFBhcnRpZXMgPSBbdGhpcy5jbGllbnRfaWQsIC4uLmFkZGl0aW9uYWxBdXRob3JpemVkUGFydGllc107XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWRkaXRpb25hbEF1dGhvcml6ZWRQYXJ0aWVzID0gW3RoaXMuY2xpZW50X2lkXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFhZGRpdGlvbmFsQXV0aG9yaXplZFBhcnRpZXMuaW5jbHVkZXMocGF5bG9hZC5henApKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xyXG4gICAgICAgICAgcHJpbnRmOiBbJ2F6cCBtaXNtYXRjaCwgZ290OiAlcycsIHBheWxvYWQuYXpwXSxcclxuICAgICAgICAgIGp3dCxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxldCBrZXlzO1xyXG5cclxuICAgIGlmIChpc1NlbGZJc3N1ZWQpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhc3NlcnQoaXNQbGFpbk9iamVjdChwYXlsb2FkLnN1Yl9qd2spKTtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBqb3NlLmltcG9ydEpXSyhwYXlsb2FkLnN1Yl9qd2ssIGhlYWRlci5hbGcpO1xyXG4gICAgICAgIGFzc2VydC5lcXVhbChrZXkudHlwZSwgJ3B1YmxpYycpO1xyXG4gICAgICAgIGtleXMgPSBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGtleU9iamVjdCgpIHtcclxuICAgICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICBdO1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgICAgICBtZXNzYWdlOiAnZmFpbGVkIHRvIHVzZSBzdWJfandrIGNsYWltIGFzIGFuIGFzeW1tZXRyaWMgSlNPTiBXZWIgS2V5JyxcclxuICAgICAgICAgIGp3dCxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoKGF3YWl0IGpvc2UuY2FsY3VsYXRlSndrVGh1bWJwcmludChwYXlsb2FkLnN1Yl9qd2spKSAhPT0gcGF5bG9hZC5zdWIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgICAgICBtZXNzYWdlOiAnZmFpbGVkIHRvIG1hdGNoIHRoZSBzdWJqZWN0IHdpdGggc3ViX2p3aycsXHJcbiAgICAgICAgICBqd3QsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoaGVhZGVyLmFsZy5zdGFydHNXaXRoKCdIUycpKSB7XHJcbiAgICAgIGtleXMgPSBbdGhpcy5zZWNyZXRGb3JBbGcoaGVhZGVyLmFsZyldO1xyXG4gICAgfSBlbHNlIGlmIChoZWFkZXIuYWxnICE9PSAnbm9uZScpIHtcclxuICAgICAga2V5cyA9IGF3YWl0IHF1ZXJ5S2V5U3RvcmUuY2FsbCh0aGlzLmlzc3VlciwgeyAuLi5oZWFkZXIsIHVzZTogJ3NpZycgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFrZXlzICYmIGhlYWRlci5hbGcgPT09ICdub25lJykge1xyXG4gICAgICByZXR1cm4geyBwcm90ZWN0ZWQ6IGhlYWRlciwgcGF5bG9hZCB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcclxuICAgICAgY29uc3QgdmVyaWZpZWQgPSBhd2FpdCBqb3NlXHJcbiAgICAgICAgLmNvbXBhY3RWZXJpZnkoand0LCBrZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8ga2V5IDogYXdhaXQga2V5LmtleU9iamVjdChoZWFkZXIuYWxnKSlcclxuICAgICAgICAuY2F0Y2goKCkgPT4ge30pO1xyXG4gICAgICBpZiAodmVyaWZpZWQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgcGF5bG9hZCxcclxuICAgICAgICAgIHByb3RlY3RlZDogdmVyaWZpZWQucHJvdGVjdGVkSGVhZGVyLFxyXG4gICAgICAgICAga2V5LFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgIG1lc3NhZ2U6ICdmYWlsZWQgdG8gdmFsaWRhdGUgSldUIHNpZ25hdHVyZScsXHJcbiAgICAgIGp3dCxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcmVmcmVzaChyZWZyZXNoVG9rZW4sIHsgZXhjaGFuZ2VCb2R5LCBjbGllbnRBc3NlcnRpb25QYXlsb2FkLCBEUG9QIH0gPSB7fSkge1xyXG4gICAgbGV0IHRva2VuID0gcmVmcmVzaFRva2VuO1xyXG5cclxuICAgIGlmICh0b2tlbiBpbnN0YW5jZW9mIFRva2VuU2V0KSB7XHJcbiAgICAgIGlmICghdG9rZW4ucmVmcmVzaF90b2tlbikge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlZnJlc2hfdG9rZW4gbm90IHByZXNlbnQgaW4gVG9rZW5TZXQnKTtcclxuICAgICAgfVxyXG4gICAgICB0b2tlbiA9IHRva2VuLnJlZnJlc2hfdG9rZW47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdG9rZW5zZXQgPSBhd2FpdCB0aGlzLmdyYW50KFxyXG4gICAgICB7XHJcbiAgICAgICAgLi4uZXhjaGFuZ2VCb2R5LFxyXG4gICAgICAgIGdyYW50X3R5cGU6ICdyZWZyZXNoX3Rva2VuJyxcclxuICAgICAgICByZWZyZXNoX3Rva2VuOiBTdHJpbmcodG9rZW4pLFxyXG4gICAgICB9LFxyXG4gICAgICB7IGNsaWVudEFzc2VydGlvblBheWxvYWQsIERQb1AgfSxcclxuICAgICk7XHJcblxyXG4gICAgaWYgKHRva2Vuc2V0LmlkX3Rva2VuKSB7XHJcbiAgICAgIGF3YWl0IHRoaXMuZGVjcnlwdElkVG9rZW4odG9rZW5zZXQpO1xyXG4gICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlSWRUb2tlbih0b2tlbnNldCwgc2tpcE5vbmNlQ2hlY2ssICd0b2tlbicsIHNraXBNYXhBZ2VDaGVjayk7XHJcblxyXG4gICAgICBpZiAocmVmcmVzaFRva2VuIGluc3RhbmNlb2YgVG9rZW5TZXQgJiYgcmVmcmVzaFRva2VuLmlkX3Rva2VuKSB7XHJcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRTdWIgPSByZWZyZXNoVG9rZW4uY2xhaW1zKCkuc3ViO1xyXG4gICAgICAgIGNvbnN0IGFjdHVhbFN1YiA9IHRva2Vuc2V0LmNsYWltcygpLnN1YjtcclxuICAgICAgICBpZiAoYWN0dWFsU3ViICE9PSBleHBlY3RlZFN1Yikge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xyXG4gICAgICAgICAgICBwcmludGY6IFsnc3ViIG1pc21hdGNoLCBleHBlY3RlZCAlcywgZ290OiAlcycsIGV4cGVjdGVkU3ViLCBhY3R1YWxTdWJdLFxyXG4gICAgICAgICAgICBqd3Q6IHRva2Vuc2V0LmlkX3Rva2VuLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRva2Vuc2V0O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcmVxdWVzdFJlc291cmNlKFxyXG4gICAgcmVzb3VyY2VVcmwsXHJcbiAgICBhY2Nlc3NUb2tlbixcclxuICAgIHtcclxuICAgICAgbWV0aG9kLFxyXG4gICAgICBoZWFkZXJzLFxyXG4gICAgICBib2R5LFxyXG4gICAgICBEUG9QLFxyXG4gICAgICB0b2tlblR5cGUgPSBEUG9QXHJcbiAgICAgICAgPyAnRFBvUCdcclxuICAgICAgICA6IGFjY2Vzc1Rva2VuIGluc3RhbmNlb2YgVG9rZW5TZXRcclxuICAgICAgICA/IGFjY2Vzc1Rva2VuLnRva2VuX3R5cGVcclxuICAgICAgICA6ICdCZWFyZXInLFxyXG4gICAgfSA9IHt9LFxyXG4gICAgcmV0cnksXHJcbiAgKSB7XHJcbiAgICBpZiAoYWNjZXNzVG9rZW4gaW5zdGFuY2VvZiBUb2tlblNldCkge1xyXG4gICAgICBpZiAoIWFjY2Vzc1Rva2VuLmFjY2Vzc190b2tlbikge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FjY2Vzc190b2tlbiBub3QgcHJlc2VudCBpbiBUb2tlblNldCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW4uYWNjZXNzX3Rva2VuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghYWNjZXNzVG9rZW4pIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gYWNjZXNzIHRva2VuIHByb3ZpZGVkJyk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhY2Nlc3NUb2tlbiAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhY2Nlc3MgdG9rZW4gcHJvdmlkZWQnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZXF1ZXN0T3B0cyA9IHtcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgIEF1dGhvcml6YXRpb246IGF1dGhvcml6YXRpb25IZWFkZXJWYWx1ZShhY2Nlc3NUb2tlbiwgdG9rZW5UeXBlKSxcclxuICAgICAgICAuLi5oZWFkZXJzLFxyXG4gICAgICB9LFxyXG4gICAgICBib2R5LFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBtVExTID0gISF0aGlzLnRsc19jbGllbnRfY2VydGlmaWNhdGVfYm91bmRfYWNjZXNzX3Rva2VucztcclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QuY2FsbChcclxuICAgICAgdGhpcyxcclxuICAgICAge1xyXG4gICAgICAgIC4uLnJlcXVlc3RPcHRzLFxyXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2J1ZmZlcicsXHJcbiAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgIHVybDogcmVzb3VyY2VVcmwsXHJcbiAgICAgIH0sXHJcbiAgICAgIHsgYWNjZXNzVG9rZW4sIG1UTFMsIERQb1AgfSxcclxuICAgICk7XHJcblxyXG4gICAgY29uc3Qgd3d3QXV0aGVudGljYXRlID0gcmVzcG9uc2UuaGVhZGVyc1snd3d3LWF1dGhlbnRpY2F0ZSddO1xyXG4gICAgaWYgKFxyXG4gICAgICByZXRyeSAhPT0gcmV0cnlBdHRlbXB0ICYmXHJcbiAgICAgIHd3d0F1dGhlbnRpY2F0ZSAmJlxyXG4gICAgICB3d3dBdXRoZW50aWNhdGUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdkcG9wICcpICYmXHJcbiAgICAgIHBhcnNlV3d3QXV0aGVudGljYXRlKHd3d0F1dGhlbnRpY2F0ZSkuZXJyb3IgPT09ICd1c2VfZHBvcF9ub25jZSdcclxuICAgICkge1xyXG4gICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0UmVzb3VyY2UocmVzb3VyY2VVcmwsIGFjY2Vzc1Rva2VuLCB7XHJcbiAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgIGhlYWRlcnMsXHJcbiAgICAgICAgYm9keSxcclxuICAgICAgICBEUG9QLFxyXG4gICAgICAgIHRva2VuVHlwZSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgdXNlcmluZm8oYWNjZXNzVG9rZW4sIHsgbWV0aG9kID0gJ0dFVCcsIHZpYSA9ICdoZWFkZXInLCB0b2tlblR5cGUsIHBhcmFtcywgRFBvUCB9ID0ge30pIHtcclxuICAgIGFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24odGhpcy5pc3N1ZXIsICd1c2VyaW5mb19lbmRwb2ludCcpO1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgdG9rZW5UeXBlLFxyXG4gICAgICBtZXRob2Q6IFN0cmluZyhtZXRob2QpLnRvVXBwZXJDYXNlKCksXHJcbiAgICAgIERQb1AsXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChvcHRpb25zLm1ldGhvZCAhPT0gJ0dFVCcgJiYgb3B0aW9ucy5tZXRob2QgIT09ICdQT1NUJykge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcjdXNlcmluZm8oKSBtZXRob2QgY2FuIG9ubHkgYmUgUE9TVCBvciBhIEdFVCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh2aWEgPT09ICdib2R5JyAmJiBvcHRpb25zLm1ldGhvZCAhPT0gJ1BPU1QnKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbiBvbmx5IHNlbmQgYm9keSBvbiBQT1NUJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgand0ID0gISEodGhpcy51c2VyaW5mb19zaWduZWRfcmVzcG9uc2VfYWxnIHx8IHRoaXMudXNlcmluZm9fZW5jcnlwdGVkX3Jlc3BvbnNlX2FsZyk7XHJcblxyXG4gICAgaWYgKGp3dCkge1xyXG4gICAgICBvcHRpb25zLmhlYWRlcnMgPSB7IEFjY2VwdDogJ2FwcGxpY2F0aW9uL2p3dCcgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG9wdGlvbnMuaGVhZGVycyA9IHsgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IG1UTFMgPSAhIXRoaXMudGxzX2NsaWVudF9jZXJ0aWZpY2F0ZV9ib3VuZF9hY2Nlc3NfdG9rZW5zO1xyXG5cclxuICAgIGxldCB0YXJnZXRVcmw7XHJcbiAgICBpZiAobVRMUyAmJiB0aGlzLmlzc3Vlci5tdGxzX2VuZHBvaW50X2FsaWFzZXMpIHtcclxuICAgICAgdGFyZ2V0VXJsID0gdGhpcy5pc3N1ZXIubXRsc19lbmRwb2ludF9hbGlhc2VzLnVzZXJpbmZvX2VuZHBvaW50O1xyXG4gICAgfVxyXG5cclxuICAgIHRhcmdldFVybCA9IG5ldyBVUkwodGFyZ2V0VXJsIHx8IHRoaXMuaXNzdWVyLnVzZXJpbmZvX2VuZHBvaW50KTtcclxuXHJcbiAgICBpZiAodmlhID09PSAnYm9keScpIHtcclxuICAgICAgb3B0aW9ucy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSB1bmRlZmluZWQ7XHJcbiAgICAgIG9wdGlvbnMuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcclxuICAgICAgb3B0aW9ucy5ib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xyXG4gICAgICBvcHRpb25zLmJvZHkuYXBwZW5kKFxyXG4gICAgICAgICdhY2Nlc3NfdG9rZW4nLFxyXG4gICAgICAgIGFjY2Vzc1Rva2VuIGluc3RhbmNlb2YgVG9rZW5TZXQgPyBhY2Nlc3NUb2tlbi5hY2Nlc3NfdG9rZW4gOiBhY2Nlc3NUb2tlbixcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBoYW5kbGUgYWRkaXRpb25hbCBwYXJhbWV0ZXJzLCBHRVQgdmlhIHF1ZXJ5c3RyaW5nLCBQT1NUIHZpYSB1cmxlbmNvZGVkIGJvZHlcclxuICAgIGlmIChwYXJhbXMpIHtcclxuICAgICAgaWYgKG9wdGlvbnMubWV0aG9kID09PSAnR0VUJykge1xyXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHBhcmFtcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XHJcbiAgICAgICAgICB0YXJnZXRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmJvZHkpIHtcclxuICAgICAgICAvLyBQT1NUICYmIHZpYSBib2R5XHJcbiAgICAgICAgT2JqZWN0LmVudHJpZXMocGFyYW1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcclxuICAgICAgICAgIG9wdGlvbnMuYm9keS5hcHBlbmQoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gUE9TVCAmJiB2aWEgaGVhZGVyXHJcbiAgICAgICAgb3B0aW9ucy5ib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xyXG4gICAgICAgIG9wdGlvbnMuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcclxuICAgICAgICBPYmplY3QuZW50cmllcyhwYXJhbXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICAgICAgb3B0aW9ucy5ib2R5LmFwcGVuZChrZXksIHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChvcHRpb25zLmJvZHkpIHtcclxuICAgICAgb3B0aW9ucy5ib2R5ID0gb3B0aW9ucy5ib2R5LnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlcXVlc3RSZXNvdXJjZSh0YXJnZXRVcmwsIGFjY2Vzc1Rva2VuLCBvcHRpb25zKTtcclxuXHJcbiAgICBsZXQgcGFyc2VkID0gcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlLCB7IGJlYXJlcjogdHJ1ZSB9KTtcclxuXHJcbiAgICBpZiAoand0KSB7XHJcbiAgICAgIGlmICghL15hcHBsaWNhdGlvblxcL2p3dC8udGVzdChyZXNwb25zZS5oZWFkZXJzWydjb250ZW50LXR5cGUnXSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgICAgICBtZXNzYWdlOiAnZXhwZWN0ZWQgYXBwbGljYXRpb24vand0IHJlc3BvbnNlIGZyb20gdGhlIHVzZXJpbmZvX2VuZHBvaW50JyxcclxuICAgICAgICAgIHJlc3BvbnNlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBib2R5ID0gcmVzcG9uc2UuYm9keS50b1N0cmluZygpO1xyXG4gICAgICBjb25zdCB1c2VyaW5mbyA9IGF3YWl0IHRoaXMuZGVjcnlwdEpXVFVzZXJpbmZvKGJvZHkpO1xyXG4gICAgICBpZiAoIXRoaXMudXNlcmluZm9fc2lnbmVkX3Jlc3BvbnNlX2FsZykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKHVzZXJpbmZvKTtcclxuICAgICAgICAgIGFzc2VydChpc1BsYWluT2JqZWN0KHBhcnNlZCkpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xyXG4gICAgICAgICAgICBtZXNzYWdlOiAnZmFpbGVkIHRvIHBhcnNlIHVzZXJpbmZvIEpXRSBwYXlsb2FkIGFzIEpTT04nLFxyXG4gICAgICAgICAgICBqd3Q6IHVzZXJpbmZvLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgICh7IHBheWxvYWQ6IHBhcnNlZCB9ID0gYXdhaXQgdGhpcy52YWxpZGF0ZUpXVFVzZXJpbmZvKHVzZXJpbmZvKSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcGFyc2VkID0gSlNPTi5wYXJzZShyZXNwb25zZS5ib2R5KTtcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgJ3Jlc3BvbnNlJywgeyB2YWx1ZTogcmVzcG9uc2UgfSk7XHJcbiAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGFjY2Vzc1Rva2VuIGluc3RhbmNlb2YgVG9rZW5TZXQgJiYgYWNjZXNzVG9rZW4uaWRfdG9rZW4pIHtcclxuICAgICAgY29uc3QgZXhwZWN0ZWRTdWIgPSBhY2Nlc3NUb2tlbi5jbGFpbXMoKS5zdWI7XHJcbiAgICAgIGlmIChwYXJzZWQuc3ViICE9PSBleHBlY3RlZFN1Yikge1xyXG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcclxuICAgICAgICAgIHByaW50ZjogWyd1c2VyaW5mbyBzdWIgbWlzbWF0Y2gsIGV4cGVjdGVkICVzLCBnb3Q6ICVzJywgZXhwZWN0ZWRTdWIsIHBhcnNlZC5zdWJdLFxyXG4gICAgICAgICAgYm9keTogcGFyc2VkLFxyXG4gICAgICAgICAgand0OiBhY2Nlc3NUb2tlbi5pZF90b2tlbixcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwYXJzZWQ7XHJcbiAgfVxyXG5cclxuICBlbmNyeXB0aW9uU2VjcmV0KGxlbikge1xyXG4gICAgY29uc3QgaGFzaCA9IGxlbiA8PSAyNTYgPyAnc2hhMjU2JyA6IGxlbiA8PSAzODQgPyAnc2hhMzg0JyA6IGxlbiA8PSA1MTIgPyAnc2hhNTEyJyA6IGZhbHNlO1xyXG4gICAgaWYgKCFoYXNoKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgc3ltbWV0cmljIGVuY3J5cHRpb24ga2V5IGRlcml2YXRpb24nKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY3J5cHRvXHJcbiAgICAgIC5jcmVhdGVIYXNoKGhhc2gpXHJcbiAgICAgIC51cGRhdGUodGhpcy5jbGllbnRfc2VjcmV0KVxyXG4gICAgICAuZGlnZXN0KClcclxuICAgICAgLnNsaWNlKDAsIGxlbiAvIDgpO1xyXG4gIH1cclxuXHJcbiAgc2VjcmV0Rm9yQWxnKGFsZykge1xyXG4gICAgaWYgKCF0aGlzLmNsaWVudF9zZWNyZXQpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2xpZW50X3NlY3JldCBpcyByZXF1aXJlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgvXkEoXFxkezN9KSg/OkdDTSk/S1ckLy50ZXN0KGFsZykpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdGlvblNlY3JldChwYXJzZUludChSZWdFeHAuJDEsIDEwKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKC9eQShcXGR7M30pKD86R0NNfENCQy1IUyhcXGR7M30pKSQvLnRlc3QoYWxnKSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5lbmNyeXB0aW9uU2VjcmV0KHBhcnNlSW50KFJlZ0V4cC4kMiB8fCBSZWdFeHAuJDEsIDEwKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0aGlzLmNsaWVudF9zZWNyZXQpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ3JhbnQoYm9keSwgeyBjbGllbnRBc3NlcnRpb25QYXlsb2FkLCBEUG9QIH0gPSB7fSwgcmV0cnkpIHtcclxuICAgIGFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24odGhpcy5pc3N1ZXIsICd0b2tlbl9lbmRwb2ludCcpO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhdXRoZW50aWNhdGVkUG9zdC5jYWxsKFxyXG4gICAgICB0aGlzLFxyXG4gICAgICAndG9rZW4nLFxyXG4gICAgICB7XHJcbiAgICAgICAgZm9ybTogYm9keSxcclxuICAgICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcclxuICAgICAgfSxcclxuICAgICAgeyBjbGllbnRBc3NlcnRpb25QYXlsb2FkLCBEUG9QIH0sXHJcbiAgICApO1xyXG4gICAgbGV0IHJlc3BvbnNlQm9keTtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJlc3BvbnNlQm9keSA9IHByb2Nlc3NSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgaWYgKHJldHJ5ICE9PSByZXRyeUF0dGVtcHQgJiYgZXJyIGluc3RhbmNlb2YgT1BFcnJvciAmJiBlcnIuZXJyb3IgPT09ICd1c2VfZHBvcF9ub25jZScpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ncmFudChib2R5LCB7IGNsaWVudEFzc2VydGlvblBheWxvYWQsIERQb1AgfSwgcmV0cnlBdHRlbXB0KTtcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBlcnI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUb2tlblNldChyZXNwb25zZUJvZHkpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZGV2aWNlQXV0aG9yaXphdGlvbihwYXJhbXMgPSB7fSwgeyBleGNoYW5nZUJvZHksIGNsaWVudEFzc2VydGlvblBheWxvYWQsIERQb1AgfSA9IHt9KSB7XHJcbiAgICBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uKHRoaXMuaXNzdWVyLCAnZGV2aWNlX2F1dGhvcml6YXRpb25fZW5kcG9pbnQnKTtcclxuICAgIGFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24odGhpcy5pc3N1ZXIsICd0b2tlbl9lbmRwb2ludCcpO1xyXG5cclxuICAgIGNvbnN0IGJvZHkgPSBhdXRob3JpemF0aW9uUGFyYW1zLmNhbGwodGhpcywge1xyXG4gICAgICBjbGllbnRfaWQ6IHRoaXMuY2xpZW50X2lkLFxyXG4gICAgICByZWRpcmVjdF91cmk6IG51bGwsXHJcbiAgICAgIHJlc3BvbnNlX3R5cGU6IG51bGwsXHJcbiAgICAgIC4uLnBhcmFtcyxcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXV0aGVudGljYXRlZFBvc3QuY2FsbChcclxuICAgICAgdGhpcyxcclxuICAgICAgJ2RldmljZV9hdXRob3JpemF0aW9uJyxcclxuICAgICAge1xyXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxyXG4gICAgICAgIGZvcm06IGJvZHksXHJcbiAgICAgIH0sXHJcbiAgICAgIHsgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCwgZW5kcG9pbnRBdXRoTWV0aG9kOiAndG9rZW4nIH0sXHJcbiAgICApO1xyXG4gICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IERldmljZUZsb3dIYW5kbGUoe1xyXG4gICAgICBjbGllbnQ6IHRoaXMsXHJcbiAgICAgIGV4Y2hhbmdlQm9keSxcclxuICAgICAgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCxcclxuICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlQm9keSxcclxuICAgICAgbWF4QWdlOiBwYXJhbXMubWF4X2FnZSxcclxuICAgICAgRFBvUCxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcmV2b2tlKHRva2VuLCBoaW50LCB7IHJldm9rZUJvZHksIGNsaWVudEFzc2VydGlvblBheWxvYWQgfSA9IHt9KSB7XHJcbiAgICBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uKHRoaXMuaXNzdWVyLCAncmV2b2NhdGlvbl9lbmRwb2ludCcpO1xyXG4gICAgaWYgKGhpbnQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgaGludCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaGludCBtdXN0IGJlIGEgc3RyaW5nJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZm9ybSA9IHsgLi4ucmV2b2tlQm9keSwgdG9rZW4gfTtcclxuXHJcbiAgICBpZiAoaGludCkge1xyXG4gICAgICBmb3JtLnRva2VuX3R5cGVfaGludCA9IGhpbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhdXRoZW50aWNhdGVkUG9zdC5jYWxsKFxyXG4gICAgICB0aGlzLFxyXG4gICAgICAncmV2b2NhdGlvbicsXHJcbiAgICAgIHtcclxuICAgICAgICBmb3JtLFxyXG4gICAgICB9LFxyXG4gICAgICB7IGNsaWVudEFzc2VydGlvblBheWxvYWQgfSxcclxuICAgICk7XHJcbiAgICBwcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UsIHsgYm9keTogZmFsc2UgfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBpbnRyb3NwZWN0KHRva2VuLCBoaW50LCB7IGludHJvc3BlY3RCb2R5LCBjbGllbnRBc3NlcnRpb25QYXlsb2FkIH0gPSB7fSkge1xyXG4gICAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbih0aGlzLmlzc3VlciwgJ2ludHJvc3BlY3Rpb25fZW5kcG9pbnQnKTtcclxuICAgIGlmIChoaW50ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGhpbnQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2hpbnQgbXVzdCBiZSBhIHN0cmluZycpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGZvcm0gPSB7IC4uLmludHJvc3BlY3RCb2R5LCB0b2tlbiB9O1xyXG4gICAgaWYgKGhpbnQpIHtcclxuICAgICAgZm9ybS50b2tlbl90eXBlX2hpbnQgPSBoaW50O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXV0aGVudGljYXRlZFBvc3QuY2FsbChcclxuICAgICAgdGhpcyxcclxuICAgICAgJ2ludHJvc3BlY3Rpb24nLFxyXG4gICAgICB7IGZvcm0sIHJlc3BvbnNlVHlwZTogJ2pzb24nIH0sXHJcbiAgICAgIHsgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCB9LFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCByZXNwb25zZUJvZHkgPSBwcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UpO1xyXG5cclxuICAgIHJldHVybiByZXNwb25zZUJvZHk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgYXN5bmMgcmVnaXN0ZXIobWV0YWRhdGEsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3QgeyBpbml0aWFsQWNjZXNzVG9rZW4sIGp3a3MsIC4uLmNsaWVudE9wdGlvbnMgfSA9IG9wdGlvbnM7XHJcblxyXG4gICAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbih0aGlzLmlzc3VlciwgJ3JlZ2lzdHJhdGlvbl9lbmRwb2ludCcpO1xyXG5cclxuICAgIGlmIChqd2tzICE9PSB1bmRlZmluZWQgJiYgIShtZXRhZGF0YS5qd2tzIHx8IG1ldGFkYXRhLmp3a3NfdXJpKSkge1xyXG4gICAgICBjb25zdCBrZXlzdG9yZSA9IGF3YWl0IGdldEtleXN0b3JlLmNhbGwodGhpcywgandrcyk7XHJcbiAgICAgIG1ldGFkYXRhLmp3a3MgPSBrZXlzdG9yZS50b0pXS1MoKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QuY2FsbCh0aGlzLCB7XHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAuLi4oaW5pdGlhbEFjY2Vzc1Rva2VuXHJcbiAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBhdXRob3JpemF0aW9uSGVhZGVyVmFsdWUoaW5pdGlhbEFjY2Vzc1Rva2VuKSxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgOiB1bmRlZmluZWQpLFxyXG4gICAgICB9LFxyXG4gICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcclxuICAgICAganNvbjogbWV0YWRhdGEsXHJcbiAgICAgIHVybDogdGhpcy5pc3N1ZXIucmVnaXN0cmF0aW9uX2VuZHBvaW50LFxyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlLCB7IHN0YXR1c0NvZGU6IDIwMSwgYmVhcmVyOiB0cnVlIH0pO1xyXG5cclxuICAgIHJldHVybiBuZXcgdGhpcyhyZXNwb25zZUJvZHksIGp3a3MsIGNsaWVudE9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IG1ldGFkYXRhKCkge1xyXG4gICAgcmV0dXJuIGNsb25lKE9iamVjdC5mcm9tRW50cmllcyh0aGlzLiNtZXRhZGF0YS5lbnRyaWVzKCkpKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBhc3luYyBmcm9tVXJpKHJlZ2lzdHJhdGlvbkNsaWVudFVyaSwgcmVnaXN0cmF0aW9uQWNjZXNzVG9rZW4sIGp3a3MsIGNsaWVudE9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdC5jYWxsKHRoaXMsIHtcclxuICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgdXJsOiByZWdpc3RyYXRpb25DbGllbnRVcmksXHJcbiAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYXV0aG9yaXphdGlvbkhlYWRlclZhbHVlKHJlZ2lzdHJhdGlvbkFjY2Vzc1Rva2VuKSxcclxuICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlLCB7IGJlYXJlcjogdHJ1ZSB9KTtcclxuXHJcbiAgICByZXR1cm4gbmV3IHRoaXMocmVzcG9uc2VCb2R5LCBqd2tzLCBjbGllbnRPcHRpb25zKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHJlcXVlc3RPYmplY3QoXHJcbiAgICByZXF1ZXN0T2JqZWN0ID0ge30sXHJcbiAgICB7XHJcbiAgICAgIHNpZ246IHNpZ25pbmdBbGdvcml0aG0gPSB0aGlzLnJlcXVlc3Rfb2JqZWN0X3NpZ25pbmdfYWxnIHx8ICdub25lJyxcclxuICAgICAgZW5jcnlwdDoge1xyXG4gICAgICAgIGFsZzogZUtleU1hbmFnZW1lbnQgPSB0aGlzLnJlcXVlc3Rfb2JqZWN0X2VuY3J5cHRpb25fYWxnLFxyXG4gICAgICAgIGVuYzogZUNvbnRlbnRFbmNyeXB0aW9uID0gdGhpcy5yZXF1ZXN0X29iamVjdF9lbmNyeXB0aW9uX2VuYyB8fCAnQTEyOENCQy1IUzI1NicsXHJcbiAgICAgIH0gPSB7fSxcclxuICAgIH0gPSB7fSxcclxuICApIHtcclxuICAgIGlmICghaXNQbGFpbk9iamVjdChyZXF1ZXN0T2JqZWN0KSkge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZXF1ZXN0T2JqZWN0IG11c3QgYmUgYSBwbGFpbiBvYmplY3QnKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgc2lnbmVkO1xyXG4gICAgbGV0IGtleTtcclxuICAgIGNvbnN0IHVuaXggPSBub3coKTtcclxuICAgIGNvbnN0IGhlYWRlciA9IHsgYWxnOiBzaWduaW5nQWxnb3JpdGhtLCB0eXA6ICdvYXV0aC1hdXRoei1yZXErand0JyB9O1xyXG4gICAgY29uc3QgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KFxyXG4gICAgICBkZWZhdWx0cyh7fSwgcmVxdWVzdE9iamVjdCwge1xyXG4gICAgICAgIGlzczogdGhpcy5jbGllbnRfaWQsXHJcbiAgICAgICAgYXVkOiB0aGlzLmlzc3Vlci5pc3N1ZXIsXHJcbiAgICAgICAgY2xpZW50X2lkOiB0aGlzLmNsaWVudF9pZCxcclxuICAgICAgICBqdGk6IHJhbmRvbSgpLFxyXG4gICAgICAgIGlhdDogdW5peCxcclxuICAgICAgICBleHA6IHVuaXggKyAzMDAsXHJcbiAgICAgICAgLi4uKHRoaXMuZmFwaSgpID8geyBuYmY6IHVuaXggfSA6IHVuZGVmaW5lZCksXHJcbiAgICAgIH0pLFxyXG4gICAgKTtcclxuICAgIGlmIChzaWduaW5nQWxnb3JpdGhtID09PSAnbm9uZScpIHtcclxuICAgICAgc2lnbmVkID0gW2Jhc2U2NHVybC5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoaGVhZGVyKSksIGJhc2U2NHVybC5lbmNvZGUocGF5bG9hZCksICcnXS5qb2luKCcuJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBzeW1tZXRyaWMgPSBzaWduaW5nQWxnb3JpdGhtLnN0YXJ0c1dpdGgoJ0hTJyk7XHJcbiAgICAgIGlmIChzeW1tZXRyaWMpIHtcclxuICAgICAgICBrZXkgPSB0aGlzLnNlY3JldEZvckFsZyhzaWduaW5nQWxnb3JpdGhtKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBrZXlzdG9yZSA9IGF3YWl0IGtleXN0b3Jlcy5nZXQodGhpcyk7XHJcblxyXG4gICAgICAgIGlmICgha2V5c3RvcmUpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXHJcbiAgICAgICAgICAgIGBubyBrZXlzdG9yZSBwcmVzZW50IGZvciBjbGllbnQsIGNhbm5vdCBzaWduIHVzaW5nIGFsZyAke3NpZ25pbmdBbGdvcml0aG19YCxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGtleSA9IGtleXN0b3JlLmdldCh7IGFsZzogc2lnbmluZ0FsZ29yaXRobSwgdXNlOiAnc2lnJyB9KTtcclxuICAgICAgICBpZiAoIWtleSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgbm8ga2V5IHRvIHNpZ24gd2l0aCBmb3VuZCBmb3IgYWxnICR7c2lnbmluZ0FsZ29yaXRobX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNpZ25lZCA9IGF3YWl0IG5ldyBqb3NlLkNvbXBhY3RTaWduKG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShwYXlsb2FkKSlcclxuICAgICAgICAuc2V0UHJvdGVjdGVkSGVhZGVyKHtcclxuICAgICAgICAgIC4uLmhlYWRlcixcclxuICAgICAgICAgIGtpZDogc3ltbWV0cmljID8gdW5kZWZpbmVkIDoga2V5Lmp3ay5raWQsXHJcbiAgICAgICAgfSlcclxuICAgICAgICAuc2lnbihzeW1tZXRyaWMgPyBrZXkgOiBhd2FpdCBrZXkua2V5T2JqZWN0KHNpZ25pbmdBbGdvcml0aG0pKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWVLZXlNYW5hZ2VtZW50KSB7XHJcbiAgICAgIHJldHVybiBzaWduZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZmllbGRzID0geyBhbGc6IGVLZXlNYW5hZ2VtZW50LCBlbmM6IGVDb250ZW50RW5jcnlwdGlvbiwgY3R5OiAnb2F1dGgtYXV0aHotcmVxK2p3dCcgfTtcclxuXHJcbiAgICBpZiAoZmllbGRzLmFsZy5tYXRjaCgvXihSU0F8RUNESCkvKSkge1xyXG4gICAgICBba2V5XSA9IGF3YWl0IHF1ZXJ5S2V5U3RvcmUuY2FsbChcclxuICAgICAgICB0aGlzLmlzc3VlcixcclxuICAgICAgICB7IGFsZzogZmllbGRzLmFsZywgdXNlOiAnZW5jJyB9LFxyXG4gICAgICAgIHsgYWxsb3dNdWx0aTogdHJ1ZSB9LFxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAga2V5ID0gdGhpcy5zZWNyZXRGb3JBbGcoZmllbGRzLmFsZyA9PT0gJ2RpcicgPyBmaWVsZHMuZW5jIDogZmllbGRzLmFsZyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBqb3NlLkNvbXBhY3RFbmNyeXB0KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzaWduZWQpKVxyXG4gICAgICAuc2V0UHJvdGVjdGVkSGVhZGVyKHtcclxuICAgICAgICAuLi5maWVsZHMsXHJcbiAgICAgICAga2lkOiBrZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gdW5kZWZpbmVkIDoga2V5Lmp3ay5raWQsXHJcbiAgICAgIH0pXHJcbiAgICAgIC5lbmNyeXB0KGtleSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBrZXkgOiBhd2FpdCBrZXkua2V5T2JqZWN0KGZpZWxkcy5hbGcpKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHB1c2hlZEF1dGhvcml6YXRpb25SZXF1ZXN0KHBhcmFtcyA9IHt9LCB7IGNsaWVudEFzc2VydGlvblBheWxvYWQgfSA9IHt9KSB7XHJcbiAgICBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uKHRoaXMuaXNzdWVyLCAncHVzaGVkX2F1dGhvcml6YXRpb25fcmVxdWVzdF9lbmRwb2ludCcpO1xyXG5cclxuICAgIGNvbnN0IGJvZHkgPSB7XHJcbiAgICAgIC4uLigncmVxdWVzdCcgaW4gcGFyYW1zID8gcGFyYW1zIDogYXV0aG9yaXphdGlvblBhcmFtcy5jYWxsKHRoaXMsIHBhcmFtcykpLFxyXG4gICAgICBjbGllbnRfaWQ6IHRoaXMuY2xpZW50X2lkLFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF1dGhlbnRpY2F0ZWRQb3N0LmNhbGwoXHJcbiAgICAgIHRoaXMsXHJcbiAgICAgICdwdXNoZWRfYXV0aG9yaXphdGlvbl9yZXF1ZXN0JyxcclxuICAgICAge1xyXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxyXG4gICAgICAgIGZvcm06IGJvZHksXHJcbiAgICAgIH0sXHJcbiAgICAgIHsgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCwgZW5kcG9pbnRBdXRoTWV0aG9kOiAndG9rZW4nIH0sXHJcbiAgICApO1xyXG4gICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlLCB7IHN0YXR1c0NvZGU6IDIwMSB9KTtcclxuXHJcbiAgICBpZiAoISgnZXhwaXJlc19pbicgaW4gcmVzcG9uc2VCb2R5KSkge1xyXG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgICAgbWVzc2FnZTogJ2V4cGVjdGVkIGV4cGlyZXNfaW4gaW4gUHVzaGVkIEF1dGhvcml6YXRpb24gU3VjY2Vzc2Z1bCBSZXNwb25zZScsXHJcbiAgICAgICAgcmVzcG9uc2UsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiByZXNwb25zZUJvZHkuZXhwaXJlc19pbiAhPT0gJ251bWJlcicpIHtcclxuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdpbnZhbGlkIGV4cGlyZXNfaW4gdmFsdWUgaW4gUHVzaGVkIEF1dGhvcml6YXRpb24gU3VjY2Vzc2Z1bCBSZXNwb25zZScsXHJcbiAgICAgICAgcmVzcG9uc2UsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKCEoJ3JlcXVlc3RfdXJpJyBpbiByZXNwb25zZUJvZHkpKSB7XHJcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcclxuICAgICAgICBtZXNzYWdlOiAnZXhwZWN0ZWQgcmVxdWVzdF91cmkgaW4gUHVzaGVkIEF1dGhvcml6YXRpb24gU3VjY2Vzc2Z1bCBSZXNwb25zZScsXHJcbiAgICAgICAgcmVzcG9uc2UsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiByZXNwb25zZUJvZHkucmVxdWVzdF91cmkgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcclxuICAgICAgICBtZXNzYWdlOiAnaW52YWxpZCByZXF1ZXN0X3VyaSB2YWx1ZSBpbiBQdXNoZWQgQXV0aG9yaXphdGlvbiBTdWNjZXNzZnVsIFJlc3BvbnNlJyxcclxuICAgICAgICByZXNwb25zZSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3BvbnNlQm9keTtcclxuICB9XHJcblxyXG4gIGdldCBpc3N1ZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy4jaXNzdWVyO1xyXG4gIH1cclxuXHJcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICBbaW5zcGVjdC5jdXN0b21dKCkge1xyXG4gICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gJHtpbnNwZWN0KHRoaXMubWV0YWRhdGEsIHtcclxuICAgICAgZGVwdGg6IEluZmluaXR5LFxyXG4gICAgICBjb2xvcnM6IHByb2Nlc3Muc3Rkb3V0LmlzVFRZLFxyXG4gICAgICBjb21wYWN0OiBmYWxzZSxcclxuICAgICAgc29ydGVkOiB0cnVlLFxyXG4gICAgfSl9YDtcclxuICB9XHJcblxyXG4gIGZhcGkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lID09PSAnRkFQSTFDbGllbnQnO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgdmFsaWRhdGVKQVJNKHJlc3BvbnNlKSB7XHJcbiAgICBjb25zdCBleHBlY3RlZEFsZyA9IHRoaXMuYXV0aG9yaXphdGlvbl9zaWduZWRfcmVzcG9uc2VfYWxnO1xyXG4gICAgY29uc3QgeyBwYXlsb2FkIH0gPSBhd2FpdCB0aGlzLnZhbGlkYXRlSldUKHJlc3BvbnNlLCBleHBlY3RlZEFsZywgWydpc3MnLCAnZXhwJywgJ2F1ZCddKTtcclxuICAgIHJldHVybiBwaWNrQ2IocGF5bG9hZCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbmFtZSBkcG9wUHJvb2ZcclxuICAgKiBAYXBpIHByaXZhdGVcclxuICAgKi9cclxuICBhc3luYyBkcG9wUHJvb2YocGF5bG9hZCwgcHJpdmF0ZUtleUlucHV0LCBhY2Nlc3NUb2tlbikge1xyXG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHBheWxvYWQpKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BheWxvYWQgbXVzdCBiZSBhIHBsYWluIG9iamVjdCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBwcml2YXRlS2V5O1xyXG4gICAgaWYgKGlzS2V5T2JqZWN0KHByaXZhdGVLZXlJbnB1dCkpIHtcclxuICAgICAgcHJpdmF0ZUtleSA9IHByaXZhdGVLZXlJbnB1dDtcclxuICAgIH0gZWxzZSBpZiAocHJpdmF0ZUtleUlucHV0W1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdDcnlwdG9LZXknKSB7XHJcbiAgICAgIHByaXZhdGVLZXkgPSBwcml2YXRlS2V5SW5wdXQ7XHJcbiAgICB9IGVsc2UgaWYgKGpvc2UuY3J5cHRvUnVudGltZSA9PT0gJ25vZGU6Y3J5cHRvJykge1xyXG4gICAgICBwcml2YXRlS2V5ID0gY3J5cHRvLmNyZWF0ZVByaXZhdGVLZXkocHJpdmF0ZUtleUlucHV0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VucmVjb2duaXplZCBjcnlwdG8gcnVudGltZScpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChwcml2YXRlS2V5LnR5cGUgIT09ICdwcml2YXRlJykge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIkRQb1BcIiBvcHRpb24gbXVzdCBiZSBhIHByaXZhdGUga2V5Jyk7XHJcbiAgICB9XHJcbiAgICBsZXQgYWxnID0gZGV0ZXJtaW5lRFBvUEFsZ29yaXRobS5jYWxsKHRoaXMsIHByaXZhdGVLZXksIHByaXZhdGVLZXlJbnB1dCk7XHJcblxyXG4gICAgaWYgKCFhbGcpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY291bGQgbm90IGRldGVybWluZSBEUG9QIEpXUyBBbGdvcml0aG0nKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IGpvc2UuU2lnbkpXVCh7XHJcbiAgICAgIGF0aDogYWNjZXNzVG9rZW5cclxuICAgICAgICA/IGJhc2U2NHVybC5lbmNvZGUoY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShhY2Nlc3NUb2tlbikuZGlnZXN0KCkpXHJcbiAgICAgICAgOiB1bmRlZmluZWQsXHJcbiAgICAgIC4uLnBheWxvYWQsXHJcbiAgICB9KVxyXG4gICAgICAuc2V0UHJvdGVjdGVkSGVhZGVyKHtcclxuICAgICAgICBhbGcsXHJcbiAgICAgICAgdHlwOiAnZHBvcCtqd3QnLFxyXG4gICAgICAgIGp3azogYXdhaXQgZ2V0SndrKHByaXZhdGVLZXksIHByaXZhdGVLZXlJbnB1dCksXHJcbiAgICAgIH0pXHJcbiAgICAgIC5zZXRJc3N1ZWRBdCgpXHJcbiAgICAgIC5zZXRKdGkocmFuZG9tKCkpXHJcbiAgICAgIC5zaWduKHByaXZhdGVLZXkpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGV0ZXJtaW5lRFBvUEFsZ29yaXRobUZyb21DcnlwdG9LZXkoY3J5cHRvS2V5KSB7XHJcbiAgc3dpdGNoIChjcnlwdG9LZXkuYWxnb3JpdGhtLm5hbWUpIHtcclxuICAgIGNhc2UgJ0VkMjU1MTknOlxyXG4gICAgY2FzZSAnRWQ0NDgnOlxyXG4gICAgICByZXR1cm4gJ0VkRFNBJztcclxuICAgIGNhc2UgJ0VDRFNBJzoge1xyXG4gICAgICBzd2l0Y2ggKGNyeXB0b0tleS5hbGdvcml0aG0ubmFtZWRDdXJ2ZSkge1xyXG4gICAgICAgIGNhc2UgJ1AtMjU2JzpcclxuICAgICAgICAgIHJldHVybiAnRVMyNTYnO1xyXG4gICAgICAgIGNhc2UgJ1AtMzg0JzpcclxuICAgICAgICAgIHJldHVybiAnRVMzODQnO1xyXG4gICAgICAgIGNhc2UgJ1AtNTIxJzpcclxuICAgICAgICAgIHJldHVybiAnRVM1MTInO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGNhc2UgJ1JTQVNTQS1QS0NTMS12MV81JzpcclxuICAgICAgcmV0dXJuIGBSUyR7Y3J5cHRvS2V5LmFsZ29yaXRobS5oYXNoLm5hbWUuc2xpY2UoNCl9YDtcclxuICAgIGNhc2UgJ1JTQS1QU1MnOlxyXG4gICAgICByZXR1cm4gYFBTJHtjcnlwdG9LZXkuYWxnb3JpdGhtLmhhc2gubmFtZS5zbGljZSg0KX1gO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5zdXBwb3J0ZWQgRFBvUCBwcml2YXRlIGtleScpO1xyXG4gIH1cclxufVxyXG5cclxubGV0IGRldGVybWluZURQb1BBbGdvcml0aG07XHJcbmlmIChqb3NlLmNyeXB0b1J1bnRpbWUgPT09ICdub2RlOmNyeXB0bycpIHtcclxuICBkZXRlcm1pbmVEUG9QQWxnb3JpdGhtID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIHByaXZhdGVLZXlJbnB1dCkge1xyXG4gICAgaWYgKHByaXZhdGVLZXlJbnB1dFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnQ3J5cHRvS2V5Jykge1xyXG4gICAgICByZXR1cm4gZGV0ZXJtaW5lRFBvUEFsZ29yaXRobUZyb21DcnlwdG9LZXkocHJpdmF0ZUtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3dpdGNoIChwcml2YXRlS2V5LmFzeW1tZXRyaWNLZXlUeXBlKSB7XHJcbiAgICAgIGNhc2UgJ2VkMjU1MTknOlxyXG4gICAgICBjYXNlICdlZDQ0OCc6XHJcbiAgICAgICAgcmV0dXJuICdFZERTQSc7XHJcbiAgICAgIGNhc2UgJ2VjJzpcclxuICAgICAgICByZXR1cm4gZGV0ZXJtaW5lRWNBbGdvcml0aG0ocHJpdmF0ZUtleSwgcHJpdmF0ZUtleUlucHV0KTtcclxuICAgICAgY2FzZSAncnNhJzpcclxuICAgICAgY2FzZSByc2FQc3NQYXJhbXMgJiYgJ3JzYS1wc3MnOlxyXG4gICAgICAgIHJldHVybiBkZXRlcm1pbmVSc2FBbGdvcml0aG0oXHJcbiAgICAgICAgICBwcml2YXRlS2V5LFxyXG4gICAgICAgICAgcHJpdmF0ZUtleUlucHV0LFxyXG4gICAgICAgICAgdGhpcy5pc3N1ZXIuZHBvcF9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkLFxyXG4gICAgICAgICk7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5zdXBwb3J0ZWQgRFBvUCBwcml2YXRlIGtleScpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IFJTUFMgPSAvXig/OlJTfFBTKSg/OjI1NnwzODR8NTEyKSQvO1xyXG4gIGZ1bmN0aW9uIGRldGVybWluZVJzYUFsZ29yaXRobShwcml2YXRlS2V5LCBwcml2YXRlS2V5SW5wdXQsIHZhbHVlc1N1cHBvcnRlZCkge1xyXG4gICAgaWYgKFxyXG4gICAgICB0eXBlb2YgcHJpdmF0ZUtleUlucHV0ID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICBwcml2YXRlS2V5SW5wdXQuZm9ybWF0ID09PSAnandrJyAmJlxyXG4gICAgICBwcml2YXRlS2V5SW5wdXQua2V5ICYmXHJcbiAgICAgIHByaXZhdGVLZXlJbnB1dC5rZXkuYWxnXHJcbiAgICApIHtcclxuICAgICAgcmV0dXJuIHByaXZhdGVLZXlJbnB1dC5rZXkuYWxnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlc1N1cHBvcnRlZCkpIHtcclxuICAgICAgbGV0IGNhbmRpZGF0ZXMgPSB2YWx1ZXNTdXBwb3J0ZWQuZmlsdGVyKFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKFJTUFMpKTtcclxuICAgICAgaWYgKHByaXZhdGVLZXkuYXN5bW1ldHJpY0tleVR5cGUgPT09ICdyc2EtcHNzJykge1xyXG4gICAgICAgIGNhbmRpZGF0ZXMgPSBjYW5kaWRhdGVzLmZpbHRlcigodmFsdWUpID0+IHZhbHVlLnN0YXJ0c1dpdGgoJ1BTJykpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBbJ1BTMjU2JywgJ1BTMzg0JywgJ1BTNTEyJywgJ1JTMjU2JywgJ1JTMzg0JywgJ1JTMzg0J10uZmluZCgocHJlZmVycmVkKSA9PlxyXG4gICAgICAgIGNhbmRpZGF0ZXMuaW5jbHVkZXMocHJlZmVycmVkKSxcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gJ1BTMjU2JztcclxuICB9XHJcblxyXG4gIGNvbnN0IHAyNTYgPSBCdWZmZXIuZnJvbShbNDIsIDEzNCwgNzIsIDIwNiwgNjEsIDMsIDEsIDddKTtcclxuICBjb25zdCBwMzg0ID0gQnVmZmVyLmZyb20oWzQzLCAxMjksIDQsIDAsIDM0XSk7XHJcbiAgY29uc3QgcDUyMSA9IEJ1ZmZlci5mcm9tKFs0MywgMTI5LCA0LCAwLCAzNV0pO1xyXG4gIGNvbnN0IHNlY3AyNTZrMSA9IEJ1ZmZlci5mcm9tKFs0MywgMTI5LCA0LCAwLCAxMF0pO1xyXG5cclxuICBmdW5jdGlvbiBkZXRlcm1pbmVFY0FsZ29yaXRobShwcml2YXRlS2V5LCBwcml2YXRlS2V5SW5wdXQpIHtcclxuICAgIC8vIElmIGlucHV0IHdhcyBhIEpXS1xyXG4gICAgc3dpdGNoIChcclxuICAgICAgdHlwZW9mIHByaXZhdGVLZXlJbnB1dCA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgdHlwZW9mIHByaXZhdGVLZXlJbnB1dC5rZXkgPT09ICdvYmplY3QnICYmXHJcbiAgICAgIHByaXZhdGVLZXlJbnB1dC5rZXkuY3J2XHJcbiAgICApIHtcclxuICAgICAgY2FzZSAnUC0yNTYnOlxyXG4gICAgICAgIHJldHVybiAnRVMyNTYnO1xyXG4gICAgICBjYXNlICdzZWNwMjU2azEnOlxyXG4gICAgICAgIHJldHVybiAnRVMyNTZLJztcclxuICAgICAgY2FzZSAnUC0zODQnOlxyXG4gICAgICAgIHJldHVybiAnRVMzODQnO1xyXG4gICAgICBjYXNlICdQLTUxMic6XHJcbiAgICAgICAgcmV0dXJuICdFUzUxMic7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYnVmID0gcHJpdmF0ZUtleS5leHBvcnQoeyBmb3JtYXQ6ICdkZXInLCB0eXBlOiAncGtjczgnIH0pO1xyXG4gICAgY29uc3QgaSA9IGJ1ZlsxXSA8IDEyOCA/IDE3IDogMTg7XHJcbiAgICBjb25zdCBsZW4gPSBidWZbaV07XHJcbiAgICBjb25zdCBjdXJ2ZU9pZCA9IGJ1Zi5zbGljZShpICsgMSwgaSArIDEgKyBsZW4pO1xyXG4gICAgaWYgKGN1cnZlT2lkLmVxdWFscyhwMjU2KSkge1xyXG4gICAgICByZXR1cm4gJ0VTMjU2JztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY3VydmVPaWQuZXF1YWxzKHAzODQpKSB7XHJcbiAgICAgIHJldHVybiAnRVMzODQnO1xyXG4gICAgfVxyXG4gICAgaWYgKGN1cnZlT2lkLmVxdWFscyhwNTIxKSkge1xyXG4gICAgICByZXR1cm4gJ0VTNTEyJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY3VydmVPaWQuZXF1YWxzKHNlY3AyNTZrMSkpIHtcclxuICAgICAgcmV0dXJuICdFUzI1NksnO1xyXG4gICAgfVxyXG5cclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Vuc3VwcG9ydGVkIERQb1AgcHJpdmF0ZSBrZXkgY3VydmUnKTtcclxuICB9XHJcbn0gZWxzZSB7XHJcbiAgZGV0ZXJtaW5lRFBvUEFsZ29yaXRobSA9IGRldGVybWluZURQb1BBbGdvcml0aG1Gcm9tQ3J5cHRvS2V5O1xyXG59XHJcblxyXG5jb25zdCBqd2tDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XHJcbmFzeW5jIGZ1bmN0aW9uIGdldEp3ayhrZXlPYmplY3QsIHByaXZhdGVLZXlJbnB1dCkge1xyXG4gIGlmIChcclxuICAgIGpvc2UuY3J5cHRvUnVudGltZSA9PT0gJ25vZGU6Y3J5cHRvJyAmJlxyXG4gICAgdHlwZW9mIHByaXZhdGVLZXlJbnB1dCA9PT0gJ29iamVjdCcgJiZcclxuICAgIHR5cGVvZiBwcml2YXRlS2V5SW5wdXQua2V5ID09PSAnb2JqZWN0JyAmJlxyXG4gICAgcHJpdmF0ZUtleUlucHV0LmZvcm1hdCA9PT0gJ2p3aydcclxuICApIHtcclxuICAgIHJldHVybiBwaWNrKHByaXZhdGVLZXlJbnB1dC5rZXksICdrdHknLCAnY3J2JywgJ3gnLCAneScsICdlJywgJ24nKTtcclxuICB9XHJcblxyXG4gIGlmIChqd2tDYWNoZS5oYXMocHJpdmF0ZUtleUlucHV0KSkge1xyXG4gICAgcmV0dXJuIGp3a0NhY2hlLmdldChwcml2YXRlS2V5SW5wdXQpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgandrID0gcGljayhhd2FpdCBqb3NlLmV4cG9ydEpXSyhrZXlPYmplY3QpLCAna3R5JywgJ2NydicsICd4JywgJ3knLCAnZScsICduJyk7XHJcblxyXG4gIGlmIChpc0tleU9iamVjdChwcml2YXRlS2V5SW5wdXQpIHx8IGpvc2UuY3J5cHRvUnVudGltZSA9PT0gJ1dlYkNyeXB0b0FQSScpIHtcclxuICAgIGp3a0NhY2hlLnNldChwcml2YXRlS2V5SW5wdXQsIGp3ayk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gandrO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChpc3N1ZXIsIGFhZElzc1ZhbGlkYXRpb24gPSBmYWxzZSkgPT5cclxuICBjbGFzcyBDbGllbnQgZXh0ZW5kcyBCYXNlQ2xpZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcclxuICAgICAgc3VwZXIoaXNzdWVyLCBhYWRJc3NWYWxpZGF0aW9uLCAuLi5hcmdzKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZ2V0IGlzc3VlcigpIHtcclxuICAgICAgcmV0dXJuIGlzc3VlcjtcclxuICAgIH1cclxuICB9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMuQmFzZUNsaWVudCA9IEJhc2VDbGllbnQ7XHJcbiJdLCJuYW1lcyI6WyJpbnNwZWN0IiwicmVxdWlyZSIsInN0ZGh0dHAiLCJjcnlwdG8iLCJzdHJpY3QiLCJhc3NlcnQiLCJxdWVyeXN0cmluZyIsInVybCIsIlVSTCIsIlVSTFNlYXJjaFBhcmFtcyIsImpvc2UiLCJ0b2tlbkhhc2giLCJpc0tleU9iamVjdCIsImRlY29kZUpXVCIsImJhc2U2NHVybCIsImRlZmF1bHRzIiwicGFyc2VXd3dBdXRoZW50aWNhdGUiLCJhc3NlcnRTaWduaW5nQWxnVmFsdWVzU3VwcG9ydCIsImFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24iLCJwaWNrIiwiaXNQbGFpbk9iamVjdCIsInByb2Nlc3NSZXNwb25zZSIsIlRva2VuU2V0IiwiT1BFcnJvciIsIlJQRXJyb3IiLCJub3ciLCJyYW5kb20iLCJyZXF1ZXN0IiwiQ0xPQ0tfVE9MRVJBTkNFIiwia2V5c3RvcmVzIiwiS2V5U3RvcmUiLCJjbG9uZSIsImF1dGhlbnRpY2F0ZWRQb3N0IiwicmVzb2x2ZVJlc3BvbnNlVHlwZSIsInJlc29sdmVSZWRpcmVjdFVyaSIsInF1ZXJ5S2V5U3RvcmUiLCJEZXZpY2VGbG93SGFuZGxlIiwibWFqb3IiLCJtaW5vciIsInByb2Nlc3MiLCJ2ZXJzaW9uIiwic2xpY2UiLCJzcGxpdCIsIm1hcCIsInN0ciIsInBhcnNlSW50IiwicnNhUHNzUGFyYW1zIiwicmV0cnlBdHRlbXB0IiwiU3ltYm9sIiwic2tpcE5vbmNlQ2hlY2siLCJza2lwTWF4QWdlQ2hlY2siLCJwaWNrQ2IiLCJpbnB1dCIsImF1dGhvcml6YXRpb25IZWFkZXJWYWx1ZSIsInRva2VuIiwidG9rZW5UeXBlIiwiZ2V0U2VhcmNoUGFyYW1zIiwicGFyc2VkIiwicGFyc2UiLCJzZWFyY2giLCJzdWJzdHJpbmciLCJ2ZXJpZnlQcmVzZW5jZSIsInBheWxvYWQiLCJqd3QiLCJwcm9wIiwidW5kZWZpbmVkIiwibWVzc2FnZSIsImF1dGhvcml6YXRpb25QYXJhbXMiLCJwYXJhbXMiLCJhdXRoUGFyYW1zIiwiY2xpZW50X2lkIiwic2NvcGUiLCJyZXNwb25zZV90eXBlIiwiY2FsbCIsInJlZGlyZWN0X3VyaSIsIk9iamVjdCIsImVudHJpZXMiLCJmb3JFYWNoIiwia2V5IiwidmFsdWUiLCJKU09OIiwic3RyaW5naWZ5IiwiQXJyYXkiLCJpc0FycmF5IiwiU3RyaW5nIiwiZ2V0S2V5c3RvcmUiLCJqd2tzIiwia2V5cyIsInNvbWUiLCJrIiwiVHlwZUVycm9yIiwiZnJvbUpXS1MiLCJvbmx5UHJpdmF0ZSIsImNoZWNrQmFzaWNTdXBwb3J0IiwiY2xpZW50IiwicHJvcGVydGllcyIsInN1cHBvcnRlZCIsImlzc3VlciIsInRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kc19zdXBwb3J0ZWQiLCJpbmNsdWRlcyIsInRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kIiwiZXJyIiwiaGFuZGxlQ29tbW9uTWlzdGFrZXMiLCJtZXRhZGF0YSIsInJlZGlyZWN0X3VyaXMiLCJyZXNwb25zZV90eXBlcyIsImdldERlZmF1bHRzRm9yRW5kcG9pbnQiLCJlbmRwb2ludCIsInRva2VuRW5kcG9pbnRBdXRoTWV0aG9kIiwidG9rZW5FbmRwb2ludEF1dGhTaWduaW5nQWxnIiwidG9rZW5fZW5kcG9pbnRfYXV0aF9zaWduaW5nX2FsZyIsImVhbSIsImVhc2EiLCJCYXNlQ2xpZW50IiwiYWFkSXNzVmFsaWRhdGlvbiIsImFkZGl0aW9uYWxBdXRob3JpemVkUGFydGllcyIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsIk1hcCIsImdyYW50X3R5cGVzIiwiaWRfdG9rZW5fc2lnbmVkX3Jlc3BvbnNlX2FsZyIsImF1dGhvcml6YXRpb25fc2lnbmVkX3Jlc3BvbnNlX2FsZyIsImZhcGkiLCJ0bHNfY2xpZW50X2NlcnRpZmljYXRlX2JvdW5kX2FjY2Vzc190b2tlbnMiLCJzZXQiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImVudW1lcmFibGUiLCJrZXlzdG9yZSIsImF1dGhvcml6YXRpb25VcmwiLCJ0YXJnZXQiLCJhdXRob3JpemF0aW9uX2VuZHBvaW50IiwibmFtZSIsInNlYXJjaFBhcmFtcyIsImRlbGV0ZSIsIm1lbWJlciIsImFwcGVuZCIsImhyZWYiLCJyZXBsYWNlIiwiYXV0aG9yaXphdGlvblBvc3QiLCJpbnB1dHMiLCJmb3JtSW5wdXRzIiwiam9pbiIsImVuZFNlc3Npb25VcmwiLCJwb3N0TG9nb3V0IiwibGVuZ3RoIiwicG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpcyIsInBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSIsImlkX3Rva2VuX2hpbnQiLCJpZF90b2tlbiIsImVuZF9zZXNzaW9uX2VuZHBvaW50IiwicXVlcnkiLCJmb3JtYXQiLCJjYWxsYmFja1BhcmFtcyIsImlzSW5jb21pbmdNZXNzYWdlIiwiSW5jb21pbmdNZXNzYWdlIiwibWV0aG9kIiwiaXNTdHJpbmciLCJib2R5IiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJ0b1N0cmluZyIsImNhbGxiYWNrIiwicmVkaXJlY3RVcmkiLCJwYXJhbWV0ZXJzIiwiY2hlY2tzIiwiZXhjaGFuZ2VCb2R5IiwiY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCIsIkRQb1AiLCJqYXJtIiwiZGVjcnlwdGVkIiwiZGVjcnlwdEpBUk0iLCJyZXNwb25zZSIsInZhbGlkYXRlSkFSTSIsImRlZmF1bHRfbWF4X2FnZSIsIm1heF9hZ2UiLCJzdGF0ZSIsInByaW50ZiIsImlzcyIsImF1dGhvcml6YXRpb25fcmVzcG9uc2VfaXNzX3BhcmFtZXRlcl9zdXBwb3J0ZWQiLCJlcnJvciIsIlJFU1BPTlNFX1RZUEVfUkVRVUlSRURfUEFSQU1TIiwiY29kZSIsInR5cGUiLCJhY2Nlc3NfdG9rZW4iLCJwYXJhbSIsInRva2Vuc2V0IiwiZGVjcnlwdElkVG9rZW4iLCJ2YWxpZGF0ZUlkVG9rZW4iLCJub25jZSIsImdyYW50IiwiZ3JhbnRfdHlwZSIsImNvZGVfdmVyaWZpZXIiLCJzZXNzaW9uX3N0YXRlIiwib2F1dGhDYWxsYmFjayIsImlkX3Rva2VuX2VuY3J5cHRlZF9yZXNwb25zZV9hbGciLCJpZFRva2VuIiwiZXhwZWN0ZWRBbGciLCJleHBlY3RlZEVuYyIsImlkX3Rva2VuX2VuY3J5cHRlZF9yZXNwb25zZV9lbmMiLCJyZXN1bHQiLCJkZWNyeXB0SldFIiwidmFsaWRhdGVKV1RVc2VyaW5mbyIsInVzZXJpbmZvX3NpZ25lZF9yZXNwb25zZV9hbGciLCJ2YWxpZGF0ZUpXVCIsImF1dGhvcml6YXRpb25fZW5jcnlwdGVkX3Jlc3BvbnNlX2FsZyIsImF1dGhvcml6YXRpb25fZW5jcnlwdGVkX3Jlc3BvbnNlX2VuYyIsImRlY3J5cHRKV1RVc2VyaW5mbyIsInVzZXJpbmZvX2VuY3J5cHRlZF9yZXNwb25zZV9hbGciLCJ1c2VyaW5mb19lbmNyeXB0ZWRfcmVzcG9uc2VfZW5jIiwiandlIiwiaGVhZGVyIiwiZGVjb2RlIiwiYWxnIiwiZW5jIiwiZ2V0UGxhaW50ZXh0IiwiVGV4dERlY29kZXIiLCJwbGFpbnRleHQiLCJtYXRjaCIsInByb3RlY3RlZEhlYWRlciIsImRlY29kZVByb3RlY3RlZEhlYWRlciIsImFsbCIsInVzZSIsImNvbXBhY3REZWNyeXB0Iiwia2V5T2JqZWN0IiwidGhlbiIsInNlY3JldEZvckFsZyIsInRva2VuU2V0IiwicmV0dXJuZWRCeSIsIm1heEFnZSIsImlzVG9rZW5TZXQiLCJ0aW1lc3RhbXAiLCJwcm90ZWN0ZWQiLCJyZXF1aXJlX2F1dGhfdGltZSIsImF1dGhfdGltZSIsInRvbGVyYW5jZSIsImF0X2hhc2giLCJjX2hhc2giLCJzX2hhc2giLCJ2YWxpZGF0ZSIsImNsYWltIiwic291cmNlIiwiandrIiwiY3J2IiwiaWF0IiwicmVxdWlyZWQiLCJpc1NlbGZJc3N1ZWQiLCJjb21wbGV0ZSIsImJpbmQiLCJleHBlY3RlZElzcyIsInRpZCIsIm5iZiIsImV4cCIsImF1ZCIsImF6cCIsInN1Yl9qd2siLCJpbXBvcnRKV0siLCJlcXVhbCIsImNhbGN1bGF0ZUp3a1RodW1icHJpbnQiLCJzdWIiLCJzdGFydHNXaXRoIiwidmVyaWZpZWQiLCJjb21wYWN0VmVyaWZ5IiwiVWludDhBcnJheSIsImNhdGNoIiwicmVmcmVzaCIsInJlZnJlc2hUb2tlbiIsInJlZnJlc2hfdG9rZW4iLCJleHBlY3RlZFN1YiIsImNsYWltcyIsImFjdHVhbFN1YiIsInJlcXVlc3RSZXNvdXJjZSIsInJlc291cmNlVXJsIiwiYWNjZXNzVG9rZW4iLCJoZWFkZXJzIiwidG9rZW5fdHlwZSIsInJldHJ5IiwicmVxdWVzdE9wdHMiLCJBdXRob3JpemF0aW9uIiwibVRMUyIsInJlc3BvbnNlVHlwZSIsInd3d0F1dGhlbnRpY2F0ZSIsInRvTG93ZXJDYXNlIiwidXNlcmluZm8iLCJ2aWEiLCJ0b1VwcGVyQ2FzZSIsIkFjY2VwdCIsInRhcmdldFVybCIsIm10bHNfZW5kcG9pbnRfYWxpYXNlcyIsInVzZXJpbmZvX2VuZHBvaW50IiwiYmVhcmVyIiwidGVzdCIsImVuY3J5cHRpb25TZWNyZXQiLCJsZW4iLCJoYXNoIiwiRXJyb3IiLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwiY2xpZW50X3NlY3JldCIsImRpZ2VzdCIsIlJlZ0V4cCIsIiQxIiwiJDIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImZvcm0iLCJyZXNwb25zZUJvZHkiLCJkZXZpY2VBdXRob3JpemF0aW9uIiwiZW5kcG9pbnRBdXRoTWV0aG9kIiwicmV2b2tlIiwiaGludCIsInJldm9rZUJvZHkiLCJ0b2tlbl90eXBlX2hpbnQiLCJpbnRyb3NwZWN0IiwiaW50cm9zcGVjdEJvZHkiLCJyZWdpc3RlciIsImluaXRpYWxBY2Nlc3NUb2tlbiIsImNsaWVudE9wdGlvbnMiLCJqd2tzX3VyaSIsInRvSldLUyIsImpzb24iLCJyZWdpc3RyYXRpb25fZW5kcG9pbnQiLCJzdGF0dXNDb2RlIiwiZnJvbUVudHJpZXMiLCJmcm9tVXJpIiwicmVnaXN0cmF0aW9uQ2xpZW50VXJpIiwicmVnaXN0cmF0aW9uQWNjZXNzVG9rZW4iLCJyZXF1ZXN0T2JqZWN0Iiwic2lnbiIsInNpZ25pbmdBbGdvcml0aG0iLCJyZXF1ZXN0X29iamVjdF9zaWduaW5nX2FsZyIsImVuY3J5cHQiLCJlS2V5TWFuYWdlbWVudCIsInJlcXVlc3Rfb2JqZWN0X2VuY3J5cHRpb25fYWxnIiwiZUNvbnRlbnRFbmNyeXB0aW9uIiwicmVxdWVzdF9vYmplY3RfZW5jcnlwdGlvbl9lbmMiLCJzaWduZWQiLCJ1bml4IiwidHlwIiwianRpIiwic3ltbWV0cmljIiwiQ29tcGFjdFNpZ24iLCJzZXRQcm90ZWN0ZWRIZWFkZXIiLCJraWQiLCJmaWVsZHMiLCJjdHkiLCJhbGxvd011bHRpIiwiQ29tcGFjdEVuY3J5cHQiLCJwdXNoZWRBdXRob3JpemF0aW9uUmVxdWVzdCIsImV4cGlyZXNfaW4iLCJyZXF1ZXN0X3VyaSIsImN1c3RvbSIsImRlcHRoIiwiSW5maW5pdHkiLCJjb2xvcnMiLCJzdGRvdXQiLCJpc1RUWSIsImNvbXBhY3QiLCJzb3J0ZWQiLCJkcG9wUHJvb2YiLCJwcml2YXRlS2V5SW5wdXQiLCJwcml2YXRlS2V5IiwidG9TdHJpbmdUYWciLCJjcnlwdG9SdW50aW1lIiwiY3JlYXRlUHJpdmF0ZUtleSIsImRldGVybWluZURQb1BBbGdvcml0aG0iLCJTaWduSldUIiwiYXRoIiwiZ2V0SndrIiwic2V0SXNzdWVkQXQiLCJzZXRKdGkiLCJkZXRlcm1pbmVEUG9QQWxnb3JpdGhtRnJvbUNyeXB0b0tleSIsImNyeXB0b0tleSIsImFsZ29yaXRobSIsIm5hbWVkQ3VydmUiLCJhc3ltbWV0cmljS2V5VHlwZSIsImRldGVybWluZUVjQWxnb3JpdGhtIiwiZGV0ZXJtaW5lUnNhQWxnb3JpdGhtIiwiZHBvcF9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkIiwiUlNQUyIsInZhbHVlc1N1cHBvcnRlZCIsImNhbmRpZGF0ZXMiLCJmaWx0ZXIiLCJwcm90b3R5cGUiLCJmaW5kIiwicHJlZmVycmVkIiwicDI1NiIsImZyb20iLCJwMzg0IiwicDUyMSIsInNlY3AyNTZrMSIsImJ1ZiIsImV4cG9ydCIsImkiLCJjdXJ2ZU9pZCIsImVxdWFscyIsImp3a0NhY2hlIiwiV2Vha01hcCIsImhhcyIsImV4cG9ydEpXSyIsIm1vZHVsZSIsImV4cG9ydHMiLCJDbGllbnQiLCJhcmdzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/device_flow_handle.js":
/*!**************************************************************!*\
  !*** ./node_modules/openid-client/lib/device_flow_handle.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { inspect } = __webpack_require__(/*! util */ \"util\");\nconst { RPError, OPError } = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/openid-client/lib/errors.js\");\nconst now = __webpack_require__(/*! ./helpers/unix_timestamp */ \"(rsc)/./node_modules/openid-client/lib/helpers/unix_timestamp.js\");\nclass DeviceFlowHandle {\n    #aborted;\n    #client;\n    #clientAssertionPayload;\n    #DPoP;\n    #exchangeBody;\n    #expires_at;\n    #interval;\n    #maxAge;\n    #response;\n    constructor({ client, exchangeBody, clientAssertionPayload, response, maxAge, DPoP }){\n        [\n            \"verification_uri\",\n            \"user_code\",\n            \"device_code\"\n        ].forEach((prop)=>{\n            if (typeof response[prop] !== \"string\" || !response[prop]) {\n                throw new RPError(`expected ${prop} string to be returned by Device Authorization Response, got %j`, response[prop]);\n            }\n        });\n        if (!Number.isSafeInteger(response.expires_in)) {\n            throw new RPError(\"expected expires_in number to be returned by Device Authorization Response, got %j\", response.expires_in);\n        }\n        this.#expires_at = now() + response.expires_in;\n        this.#client = client;\n        this.#DPoP = DPoP;\n        this.#maxAge = maxAge;\n        this.#exchangeBody = exchangeBody;\n        this.#clientAssertionPayload = clientAssertionPayload;\n        this.#response = response;\n        this.#interval = response.interval * 1000 || 5000;\n    }\n    abort() {\n        this.#aborted = true;\n    }\n    async poll({ signal } = {}) {\n        if (signal && signal.aborted || this.#aborted) {\n            throw new RPError(\"polling aborted\");\n        }\n        if (this.expired()) {\n            throw new RPError(\"the device code %j has expired and the device authorization session has concluded\", this.device_code);\n        }\n        await new Promise((resolve)=>setTimeout(resolve, this.#interval));\n        let tokenset;\n        try {\n            tokenset = await this.#client.grant({\n                ...this.#exchangeBody,\n                grant_type: \"urn:ietf:params:oauth:grant-type:device_code\",\n                device_code: this.device_code\n            }, {\n                clientAssertionPayload: this.#clientAssertionPayload,\n                DPoP: this.#DPoP\n            });\n        } catch (err) {\n            switch(err instanceof OPError && err.error){\n                case \"slow_down\":\n                    this.#interval += 5000;\n                case \"authorization_pending\":\n                    return this.poll({\n                        signal\n                    });\n                default:\n                    throw err;\n            }\n        }\n        if (\"id_token\" in tokenset) {\n            await this.#client.decryptIdToken(tokenset);\n            await this.#client.validateIdToken(tokenset, undefined, \"token\", this.#maxAge);\n        }\n        return tokenset;\n    }\n    get device_code() {\n        return this.#response.device_code;\n    }\n    get user_code() {\n        return this.#response.user_code;\n    }\n    get verification_uri() {\n        return this.#response.verification_uri;\n    }\n    get verification_uri_complete() {\n        return this.#response.verification_uri_complete;\n    }\n    get expires_in() {\n        return Math.max.apply(null, [\n            this.#expires_at - now(),\n            0\n        ]);\n    }\n    expired() {\n        return this.expires_in === 0;\n    }\n    /* istanbul ignore next */ [inspect.custom]() {\n        return `${this.constructor.name} ${inspect(this.#response, {\n            depth: Infinity,\n            colors: process.stdout.isTTY,\n            compact: false,\n            sorted: true\n        })}`;\n    }\n}\nmodule.exports = DeviceFlowHandle;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvZGV2aWNlX2Zsb3dfaGFuZGxlLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU0sRUFBRUEsT0FBTyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBRTVCLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDckMsTUFBTUcsTUFBTUgsbUJBQU9BLENBQUM7QUFFcEIsTUFBTUk7SUFDSixDQUFDQyxPQUFPLENBQUM7SUFDVCxDQUFDQyxNQUFNLENBQUM7SUFDUixDQUFDQyxzQkFBc0IsQ0FBQztJQUN4QixDQUFDQyxJQUFJLENBQUM7SUFDTixDQUFDQyxZQUFZLENBQUM7SUFDZCxDQUFDQyxVQUFVLENBQUM7SUFDWixDQUFDQyxRQUFRLENBQUM7SUFDVixDQUFDQyxNQUFNLENBQUM7SUFDUixDQUFDQyxRQUFRLENBQUM7SUFDVkMsWUFBWSxFQUFFUixNQUFNLEVBQUVHLFlBQVksRUFBRUYsc0JBQXNCLEVBQUVNLFFBQVEsRUFBRUQsTUFBTSxFQUFFSixJQUFJLEVBQUUsQ0FBRTtRQUNwRjtZQUFDO1lBQW9CO1lBQWE7U0FBYyxDQUFDTyxPQUFPLENBQUMsQ0FBQ0M7WUFDeEQsSUFBSSxPQUFPSCxRQUFRLENBQUNHLEtBQUssS0FBSyxZQUFZLENBQUNILFFBQVEsQ0FBQ0csS0FBSyxFQUFFO2dCQUN6RCxNQUFNLElBQUlmLFFBQ1IsQ0FBQyxTQUFTLEVBQUVlLEtBQUssK0RBQStELENBQUMsRUFDakZILFFBQVEsQ0FBQ0csS0FBSztZQUVsQjtRQUNGO1FBRUEsSUFBSSxDQUFDQyxPQUFPQyxhQUFhLENBQUNMLFNBQVNNLFVBQVUsR0FBRztZQUM5QyxNQUFNLElBQUlsQixRQUNSLHNGQUNBWSxTQUFTTSxVQUFVO1FBRXZCO1FBRUEsSUFBSSxDQUFDLENBQUNULFVBQVUsR0FBR1AsUUFBUVUsU0FBU00sVUFBVTtRQUM5QyxJQUFJLENBQUMsQ0FBQ2IsTUFBTSxH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QyxLQUFLO1lBQzVCQyxTQUFTO1lBQ1RDLFFBQVE7UUFDVixHQUFHLENBQUM7SUFDTjtBQUNGO0FBRUFDLE9BQU9DLE9BQU8sR0FBR2pEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvZGV2aWNlX2Zsb3dfaGFuZGxlLmpzPzczNzYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBpbnNwZWN0IH0gPSByZXF1aXJlKCd1dGlsJyk7XHJcblxyXG5jb25zdCB7IFJQRXJyb3IsIE9QRXJyb3IgfSA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XHJcbmNvbnN0IG5vdyA9IHJlcXVpcmUoJy4vaGVscGVycy91bml4X3RpbWVzdGFtcCcpO1xyXG5cclxuY2xhc3MgRGV2aWNlRmxvd0hhbmRsZSB7XHJcbiAgI2Fib3J0ZWQ7XHJcbiAgI2NsaWVudDtcclxuICAjY2xpZW50QXNzZXJ0aW9uUGF5bG9hZDtcclxuICAjRFBvUDtcclxuICAjZXhjaGFuZ2VCb2R5O1xyXG4gICNleHBpcmVzX2F0O1xyXG4gICNpbnRlcnZhbDtcclxuICAjbWF4QWdlO1xyXG4gICNyZXNwb25zZTtcclxuICBjb25zdHJ1Y3Rvcih7IGNsaWVudCwgZXhjaGFuZ2VCb2R5LCBjbGllbnRBc3NlcnRpb25QYXlsb2FkLCByZXNwb25zZSwgbWF4QWdlLCBEUG9QIH0pIHtcclxuICAgIFsndmVyaWZpY2F0aW9uX3VyaScsICd1c2VyX2NvZGUnLCAnZGV2aWNlX2NvZGUnXS5mb3JFYWNoKChwcm9wKSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2VbcHJvcF0gIT09ICdzdHJpbmcnIHx8ICFyZXNwb25zZVtwcm9wXSkge1xyXG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKFxyXG4gICAgICAgICAgYGV4cGVjdGVkICR7cHJvcH0gc3RyaW5nIHRvIGJlIHJldHVybmVkIGJ5IERldmljZSBBdXRob3JpemF0aW9uIFJlc3BvbnNlLCBnb3QgJWpgLFxyXG4gICAgICAgICAgcmVzcG9uc2VbcHJvcF0sXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihyZXNwb25zZS5leHBpcmVzX2luKSkge1xyXG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcihcclxuICAgICAgICAnZXhwZWN0ZWQgZXhwaXJlc19pbiBudW1iZXIgdG8gYmUgcmV0dXJuZWQgYnkgRGV2aWNlIEF1dGhvcml6YXRpb24gUmVzcG9uc2UsIGdvdCAlaicsXHJcbiAgICAgICAgcmVzcG9uc2UuZXhwaXJlc19pbixcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLiNleHBpcmVzX2F0ID0gbm93KCkgKyByZXNwb25zZS5leHBpcmVzX2luO1xyXG4gICAgdGhpcy4jY2xpZW50ID0gY2xpZW50O1xyXG4gICAgdGhpcy4jRFBvUCA9IERQb1A7XHJcbiAgICB0aGlzLiNtYXhBZ2UgPSBtYXhBZ2U7XHJcbiAgICB0aGlzLiNleGNoYW5nZUJvZHkgPSBleGNoYW5nZUJvZHk7XHJcbiAgICB0aGlzLiNjbGllbnRBc3NlcnRpb25QYXlsb2FkID0gY2xpZW50QXNzZXJ0aW9uUGF5bG9hZDtcclxuICAgIHRoaXMuI3Jlc3BvbnNlID0gcmVzcG9uc2U7XHJcbiAgICB0aGlzLiNpbnRlcnZhbCA9IHJlc3BvbnNlLmludGVydmFsICogMTAwMCB8fCA1MDAwO1xyXG4gIH1cclxuXHJcbiAgYWJvcnQoKSB7XHJcbiAgICB0aGlzLiNhYm9ydGVkID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHBvbGwoeyBzaWduYWwgfSA9IHt9KSB7XHJcbiAgICBpZiAoKHNpZ25hbCAmJiBzaWduYWwuYWJvcnRlZCkgfHwgdGhpcy4jYWJvcnRlZCkge1xyXG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcigncG9sbGluZyBhYm9ydGVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuZXhwaXJlZCgpKSB7XHJcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKFxyXG4gICAgICAgICd0aGUgZGV2aWNlIGNvZGUgJWogaGFzIGV4cGlyZWQgYW5kIHRoZSBkZXZpY2UgYXV0aG9yaXphdGlvbiBzZXNzaW9uIGhhcyBjb25jbHVkZWQnLFxyXG4gICAgICAgIHRoaXMuZGV2aWNlX2NvZGUsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGhpcy4jaW50ZXJ2YWwpKTtcclxuXHJcbiAgICBsZXQgdG9rZW5zZXQ7XHJcbiAgICB0cnkge1xyXG4gICAgICB0b2tlbnNldCA9IGF3YWl0IHRoaXMuI2NsaWVudC5ncmFudChcclxuICAgICAgICB7XHJcbiAgICAgICAgICAuLi50aGlzLiNleGNoYW5nZUJvZHksXHJcbiAgICAgICAgICBncmFudF90eXBlOiAndXJuOmlldGY6cGFyYW1zOm9hdXRoOmdyYW50LXR5cGU6ZGV2aWNlX2NvZGUnLFxyXG4gICAgICAgICAgZGV2aWNlX2NvZGU6IHRoaXMuZGV2aWNlX2NvZGUsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7IGNsaWVudEFzc2VydGlvblBheWxvYWQ6IHRoaXMuI2NsaWVudEFzc2VydGlvblBheWxvYWQsIERQb1A6IHRoaXMuI0RQb1AgfSxcclxuICAgICAgKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBzd2l0Y2ggKGVyciBpbnN0YW5jZW9mIE9QRXJyb3IgJiYgZXJyLmVycm9yKSB7XHJcbiAgICAgICAgY2FzZSAnc2xvd19kb3duJzpcclxuICAgICAgICAgIHRoaXMuI2ludGVydmFsICs9IDUwMDA7XHJcbiAgICAgICAgY2FzZSAnYXV0aG9yaXphdGlvbl9wZW5kaW5nJzpcclxuICAgICAgICAgIHJldHVybiB0aGlzLnBvbGwoeyBzaWduYWwgfSk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICgnaWRfdG9rZW4nIGluIHRva2Vuc2V0KSB7XHJcbiAgICAgIGF3YWl0IHRoaXMuI2NsaWVudC5kZWNyeXB0SWRUb2tlbih0b2tlbnNldCk7XHJcbiAgICAgIGF3YWl0IHRoaXMuI2NsaWVudC52YWxpZGF0ZUlkVG9rZW4odG9rZW5zZXQsIHVuZGVmaW5lZCwgJ3Rva2VuJywgdGhpcy4jbWF4QWdlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdG9rZW5zZXQ7XHJcbiAgfVxyXG5cclxuICBnZXQgZGV2aWNlX2NvZGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy4jcmVzcG9uc2UuZGV2aWNlX2NvZGU7XHJcbiAgfVxyXG5cclxuICBnZXQgdXNlcl9jb2RlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuI3Jlc3BvbnNlLnVzZXJfY29kZTtcclxuICB9XHJcblxyXG4gIGdldCB2ZXJpZmljYXRpb25fdXJpKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuI3Jlc3BvbnNlLnZlcmlmaWNhdGlvbl91cmk7XHJcbiAgfVxyXG5cclxuICBnZXQgdmVyaWZpY2F0aW9uX3VyaV9jb21wbGV0ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLiNyZXNwb25zZS52ZXJpZmljYXRpb25fdXJpX2NvbXBsZXRlO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGV4cGlyZXNfaW4oKSB7XHJcbiAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgW3RoaXMuI2V4cGlyZXNfYXQgLSBub3coKSwgMF0pO1xyXG4gIH1cclxuXHJcbiAgZXhwaXJlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmV4cGlyZXNfaW4gPT09IDA7XHJcbiAgfVxyXG5cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gIFtpbnNwZWN0LmN1c3RvbV0oKSB7XHJcbiAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSAke2luc3BlY3QodGhpcy4jcmVzcG9uc2UsIHtcclxuICAgICAgZGVwdGg6IEluZmluaXR5LFxyXG4gICAgICBjb2xvcnM6IHByb2Nlc3Muc3Rkb3V0LmlzVFRZLFxyXG4gICAgICBjb21wYWN0OiBmYWxzZSxcclxuICAgICAgc29ydGVkOiB0cnVlLFxyXG4gICAgfSl9YDtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGV2aWNlRmxvd0hhbmRsZTtcclxuIl0sIm5hbWVzIjpbImluc3BlY3QiLCJyZXF1aXJlIiwiUlBFcnJvciIsIk9QRXJyb3IiLCJub3ciLCJEZXZpY2VGbG93SGFuZGxlIiwiYWJvcnRlZCIsImNsaWVudCIsImNsaWVudEFzc2VydGlvblBheWxvYWQiLCJEUG9QIiwiZXhjaGFuZ2VCb2R5IiwiZXhwaXJlc19hdCIsImludGVydmFsIiwibWF4QWdlIiwicmVzcG9uc2UiLCJjb25zdHJ1Y3RvciIsImZvckVhY2giLCJwcm9wIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsImV4cGlyZXNfaW4iLCJhYm9ydCIsInBvbGwiLCJzaWduYWwiLCJleHBpcmVkIiwiZGV2aWNlX2NvZGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJ0b2tlbnNldCIsImdyYW50IiwiZ3JhbnRfdHlwZSIsImVyciIsImVycm9yIiwiZGVjcnlwdElkVG9rZW4iLCJ2YWxpZGF0ZUlkVG9rZW4iLCJ1bmRlZmluZWQiLCJ1c2VyX2NvZGUiLCJ2ZXJpZmljYXRpb25fdXJpIiwidmVyaWZpY2F0aW9uX3VyaV9jb21wbGV0ZSIsIk1hdGgiLCJtYXgiLCJhcHBseSIsImN1c3RvbSIsIm5hbWUiLCJkZXB0aCIsIkluZmluaXR5IiwiY29sb3JzIiwicHJvY2VzcyIsInN0ZG91dCIsImlzVFRZIiwiY29tcGFjdCIsInNvcnRlZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/device_flow_handle.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/errors.js":
/*!**************************************************!*\
  !*** ./node_modules/openid-client/lib/errors.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { format } = __webpack_require__(/*! util */ \"util\");\nclass OPError extends Error {\n    constructor({ error_description, error, error_uri, session_state, state, scope }, response){\n        super(!error_description ? error : `${error} (${error_description})`);\n        Object.assign(this, {\n            error\n        }, error_description && {\n            error_description\n        }, error_uri && {\n            error_uri\n        }, state && {\n            state\n        }, scope && {\n            scope\n        }, session_state && {\n            session_state\n        });\n        if (response) {\n            Object.defineProperty(this, \"response\", {\n                value: response\n            });\n        }\n        this.name = this.constructor.name;\n        Error.captureStackTrace(this, this.constructor);\n    }\n}\nclass RPError extends Error {\n    constructor(...args){\n        if (typeof args[0] === \"string\") {\n            super(format(...args));\n        } else {\n            const { message, printf, response, ...rest } = args[0];\n            if (printf) {\n                super(format(...printf));\n            } else {\n                super(message);\n            }\n            Object.assign(this, rest);\n            if (response) {\n                Object.defineProperty(this, \"response\", {\n                    value: response\n                });\n            }\n        }\n        this.name = this.constructor.name;\n        Error.captureStackTrace(this, this.constructor);\n    }\n}\nmodule.exports = {\n    OPError,\n    RPError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU0sRUFBRUEsTUFBTSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBRTNCLE1BQU1DLGdCQUFnQkM7SUFDcEJDLFlBQVksRUFBRUMsaUJBQWlCLEVBQUVDLEtBQUssRUFBRUMsU0FBUyxFQUFFQyxhQUFhLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxFQUFFLEVBQUVDLFFBQVEsQ0FBRTtRQUMxRixLQUFLLENBQUMsQ0FBQ04sb0JBQW9CQyxRQUFRLENBQUMsRUFBRUEsTUFBTSxFQUFFLEVBQUVELGtCQUFrQixDQUFDLENBQUM7UUFFcEVPLE9BQU9DLE1BQU0sQ0FDWCxJQUFJLEVBQ0o7WUFBRVA7UUFBTSxHQUNSRCxxQkFBcUI7WUFBRUE7UUFBa0IsR0FDekNFLGFBQWE7WUFBRUE7UUFBVSxHQUN6QkUsU0FBUztZQUFFQTtRQUFNLEdBQ2pCQyxTQUFTO1lBQUVBO1FBQU0sR0FDakJGLGlCQUFpQjtZQUFFQTtRQUFjO1FBR25DLElBQUlHLFVBQVU7WUFDWkMsT0FBT0UsY0FBYyxDQUFDLElBQUksRUFBRSxZQUFZO2dCQUN0Q0MsT0FBT0o7WUFDVDtRQUNGO1FBRUEsSUFBSSxDQUFDSyxJQUFJLEdBQUcsSUFBSSxDQUFDWixXQUFXLENBQUNZLElBQUk7UUFDakNiLE1BQU1jLGlCQUFpQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUNiLFdBQVc7SUFDaEQ7QUFDRjtBQUVBLE1BQU1jLGdCQUFnQmY7SUFDcEJDLFlBQVksR0FBR2UsSUFBSSxDQUFFO1FBQ25CLElBQUksT0FBT0EsSUFBSSxDQUFDLEVBQUUsS0FBSyxVQUFVO1lBQy9CLEtBQUssQ0FBQ25CLFVBQVVtQjtRQUNsQixPQUFPO1lBQ0wsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLE1BQU0sRUFBRVYsUUFBUSxFQUFFLEdBQUdXLE1BQU0sR0FBR0gsSUFBSSxDQUFDLEVBQUU7WUFDdEQsSUFBSUUsUUFBUTtnQkFDVixLQUFLLENBQUNyQixVQUFVcUI7WUFDbEIsT0FBTztnQkFDTCxLQUFLLENBQUNEO1lBQ1I7WUFDQVIsT0FBT0MsTUFBTSxDQUFDLElBQUksRUFBRVM7WUFDcEIsSUFBSVgsVUFBVTtnQkFDWkMsT0FBT0UsY0FBYyxDQUFDLElBQUksRUFBRSxZQUFZO29CQUN0Q0MsT0FBT0o7Z0JBQ1Q7WUFDRjtRQUNGO1FBRUEsSUFBSSxDQUFDSyxJQUFJLEdBQUcsSUFBSSxDQUFDWixXQUFXLENBQUNZLElBQUk7UUFDakNiLE1BQU1jLGlCQUFpQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUNiLFdBQVc7SUFDaEQ7QUFDRjtBQUVBbUIsT0FBT0MsT0FBTyxHQUFHO0lBQ2Z0QjtJQUNBZ0I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2Vycm9ycy5qcz9hNzQxIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgZm9ybWF0IH0gPSByZXF1aXJlKCd1dGlsJyk7XHJcblxyXG5jbGFzcyBPUEVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKHsgZXJyb3JfZGVzY3JpcHRpb24sIGVycm9yLCBlcnJvcl91cmksIHNlc3Npb25fc3RhdGUsIHN0YXRlLCBzY29wZSB9LCByZXNwb25zZSkge1xyXG4gICAgc3VwZXIoIWVycm9yX2Rlc2NyaXB0aW9uID8gZXJyb3IgOiBgJHtlcnJvcn0gKCR7ZXJyb3JfZGVzY3JpcHRpb259KWApO1xyXG5cclxuICAgIE9iamVjdC5hc3NpZ24oXHJcbiAgICAgIHRoaXMsXHJcbiAgICAgIHsgZXJyb3IgfSxcclxuICAgICAgZXJyb3JfZGVzY3JpcHRpb24gJiYgeyBlcnJvcl9kZXNjcmlwdGlvbiB9LFxyXG4gICAgICBlcnJvcl91cmkgJiYgeyBlcnJvcl91cmkgfSxcclxuICAgICAgc3RhdGUgJiYgeyBzdGF0ZSB9LFxyXG4gICAgICBzY29wZSAmJiB7IHNjb3BlIH0sXHJcbiAgICAgIHNlc3Npb25fc3RhdGUgJiYgeyBzZXNzaW9uX3N0YXRlIH0sXHJcbiAgICApO1xyXG5cclxuICAgIGlmIChyZXNwb25zZSkge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Jlc3BvbnNlJywge1xyXG4gICAgICAgIHZhbHVlOiByZXNwb25zZSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBSUEVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcclxuICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgc3VwZXIoZm9ybWF0KC4uLmFyZ3MpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IHsgbWVzc2FnZSwgcHJpbnRmLCByZXNwb25zZSwgLi4ucmVzdCB9ID0gYXJnc1swXTtcclxuICAgICAgaWYgKHByaW50Zikge1xyXG4gICAgICAgIHN1cGVyKGZvcm1hdCguLi5wcmludGYpKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzdXBlcihtZXNzYWdlKTtcclxuICAgICAgfVxyXG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHJlc3QpO1xyXG4gICAgICBpZiAocmVzcG9uc2UpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Jlc3BvbnNlJywge1xyXG4gICAgICAgICAgdmFsdWU6IHJlc3BvbnNlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBPUEVycm9yLFxyXG4gIFJQRXJyb3IsXHJcbn07XHJcbiJdLCJuYW1lcyI6WyJmb3JtYXQiLCJyZXF1aXJlIiwiT1BFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJlcnJvcl9kZXNjcmlwdGlvbiIsImVycm9yIiwiZXJyb3JfdXJpIiwic2Vzc2lvbl9zdGF0ZSIsInN0YXRlIiwic2NvcGUiLCJyZXNwb25zZSIsIk9iamVjdCIsImFzc2lnbiIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJuYW1lIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJSUEVycm9yIiwiYXJncyIsIm1lc3NhZ2UiLCJwcmludGYiLCJyZXN0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/assert.js":
/*!**********************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/assert.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("function assertSigningAlgValuesSupport(endpoint, issuer, properties) {\n    if (!issuer[`${endpoint}_endpoint`]) return;\n    const eam = `${endpoint}_endpoint_auth_method`;\n    const easa = `${endpoint}_endpoint_auth_signing_alg`;\n    const easavs = `${endpoint}_endpoint_auth_signing_alg_values_supported`;\n    if (properties[eam] && properties[eam].endsWith(\"_jwt\") && !properties[easa] && !issuer[easavs]) {\n        throw new TypeError(`${easavs} must be configured on the issuer if ${easa} is not defined on a client`);\n    }\n}\nfunction assertIssuerConfiguration(issuer, endpoint) {\n    if (!issuer[endpoint]) {\n        throw new TypeError(`${endpoint} must be configured on the issuer`);\n    }\n}\nmodule.exports = {\n    assertSigningAlgValuesSupport,\n    assertIssuerConfiguration\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL2Fzc2VydC5qcz9hZDIyIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGFzc2VydFNpZ25pbmdBbGdWYWx1ZXNTdXBwb3J0KGVuZHBvaW50LCBpc3N1ZXIsIHByb3BlcnRpZXMpIHtcclxuICBpZiAoIWlzc3VlcltgJHtlbmRwb2ludH1fZW5kcG9pbnRgXSkgcmV0dXJuO1xyXG5cclxuICBjb25zdCBlYW0gPSBgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9tZXRob2RgO1xyXG4gIGNvbnN0IGVhc2EgPSBgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9zaWduaW5nX2FsZ2A7XHJcbiAgY29uc3QgZWFzYXZzID0gYCR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZGA7XHJcblxyXG4gIGlmIChwcm9wZXJ0aWVzW2VhbV0gJiYgcHJvcGVydGllc1tlYW1dLmVuZHNXaXRoKCdfand0JykgJiYgIXByb3BlcnRpZXNbZWFzYV0gJiYgIWlzc3VlcltlYXNhdnNdKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxyXG4gICAgICBgJHtlYXNhdnN9IG11c3QgYmUgY29uZmlndXJlZCBvbiB0aGUgaXNzdWVyIGlmICR7ZWFzYX0gaXMgbm90IGRlZmluZWQgb24gYSBjbGllbnRgLFxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24oaXNzdWVyLCBlbmRwb2ludCkge1xyXG4gIGlmICghaXNzdWVyW2VuZHBvaW50XSkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtlbmRwb2ludH0gbXVzdCBiZSBjb25maWd1cmVkIG9uIHRoZSBpc3N1ZXJgKTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIGFzc2VydFNpZ25pbmdBbGdWYWx1ZXNTdXBwb3J0LFxyXG4gIGFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24sXHJcbn07XHJcbiJdLCJuYW1lcyI6WyJhc3NlcnRTaWduaW5nQWxnVmFsdWVzU3VwcG9ydCIsImVuZHBvaW50IiwiaXNzdWVyIiwicHJvcGVydGllcyIsImVhbSIsImVhc2EiLCJlYXNhdnMiLCJlbmRzV2l0aCIsIlR5cGVFcnJvciIsImFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24iLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSw4QkFBOEJDLFFBQVEsRUFBRUMsTUFBTSxFQUFFQyxVQUFVO0lBQ2pFLElBQUksQ0FBQ0QsTUFBTSxDQUFDLENBQUMsRUFBRUQsU0FBUyxTQUFTLENBQUMsQ0FBQyxFQUFFO0lBRXJDLE1BQU1HLE1BQU0sQ0FBQyxFQUFFSCxTQUFTLHFCQUFxQixDQUFDO0lBQzlDLE1BQU1JLE9BQU8sQ0FBQyxFQUFFSixTQUFTLDBCQUEwQixDQUFDO0lBQ3BELE1BQU1LLFNBQVMsQ0FBQyxFQUFFTCxTQUFTLDJDQUEyQyxDQUFDO0lBRXZFLElBQUlFLFVBQVUsQ0FBQ0MsSUFBSSxJQUFJRCxVQUFVLENBQUNDLElBQUksQ0FBQ0csUUFBUSxDQUFDLFdBQVcsQ0FBQ0osVUFBVSxDQUFDRSxLQUFLLElBQUksQ0FBQ0gsTUFBTSxDQUFDSSxPQUFPLEVBQUU7UUFDL0YsTUFBTSxJQUFJRSxVQUNSLENBQUMsRUFBRUYsT0FBTyxxQ0FBcUMsRUFBRUQsS0FBSywyQkFBMkIsQ0FBQztJQUV0RjtBQUNGO0FBRUEsU0FBU0ksMEJBQTBCUCxNQUFNLEVBQUVELFFBQVE7SUFDakQsSUFBSSxDQUFDQyxNQUFNLENBQUNELFNBQVMsRUFBRTtRQUNyQixNQUFNLElBQUlPLFVBQVUsQ0FBQyxFQUFFUCxTQUFTLGlDQUFpQyxDQUFDO0lBQ3BFO0FBQ0Y7QUFFQVMsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZYO0lBQ0FTO0FBQ0YiLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9hc3NlcnQuanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/assert.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/base64url.js":
/*!*************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/base64url.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("let encode;\nif (Buffer.isEncoding(\"base64url\")) {\n    encode = (input, encoding = \"utf8\")=>Buffer.from(input, encoding).toString(\"base64url\");\n} else {\n    const fromBase64 = (base64)=>base64.replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n    encode = (input, encoding = \"utf8\")=>fromBase64(Buffer.from(input, encoding).toString(\"base64\"));\n}\nconst decode = (input)=>Buffer.from(input, \"base64\");\nmodule.exports.decode = decode;\nmodule.exports.encode = encode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9iYXNlNjR1cmwuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUE7QUFDSixJQUFJQyxPQUFPQyxVQUFVLENBQUMsY0FBYztJQUNsQ0YsU0FBUyxDQUFDRyxPQUFPQyxXQUFXLE1BQU0sR0FBS0gsT0FBT0ksSUFBSSxDQUFDRixPQUFPQyxVQUFVRSxRQUFRLENBQUM7QUFDL0UsT0FBTztJQUNMLE1BQU1DLGFBQWEsQ0FBQ0MsU0FBV0EsT0FBT0MsT0FBTyxDQUFDLE1BQU0sSUFBSUEsT0FBTyxDQUFDLE9BQU8sS0FBS0EsT0FBTyxDQUFDLE9BQU87SUFDM0ZULFNBQVMsQ0FBQ0csT0FBT0MsV0FBVyxNQUFNLEdBQ2hDRyxXQUFXTixPQUFPSSxJQUFJLENBQUNGLE9BQU9DLFVBQVVFLFFBQVEsQ0FBQztBQUNyRDtBQUVBLE1BQU1JLFNBQVMsQ0FBQ1AsUUFBVUYsT0FBT0ksSUFBSSxDQUFDRixPQUFPO0FBRTdDUSxxQkFBcUIsR0FBR0Q7QUFDeEJDLHFCQUFxQixHQUFHWCIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvYmFzZTY0dXJsLmpzPzNiNWUiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IGVuY29kZTtcclxuaWYgKEJ1ZmZlci5pc0VuY29kaW5nKCdiYXNlNjR1cmwnKSkge1xyXG4gIGVuY29kZSA9IChpbnB1dCwgZW5jb2RpbmcgPSAndXRmOCcpID0+IEJ1ZmZlci5mcm9tKGlucHV0LCBlbmNvZGluZykudG9TdHJpbmcoJ2Jhc2U2NHVybCcpO1xyXG59IGVsc2Uge1xyXG4gIGNvbnN0IGZyb21CYXNlNjQgPSAoYmFzZTY0KSA9PiBiYXNlNjQucmVwbGFjZSgvPS9nLCAnJykucmVwbGFjZSgvXFwrL2csICctJykucmVwbGFjZSgvXFwvL2csICdfJyk7XHJcbiAgZW5jb2RlID0gKGlucHV0LCBlbmNvZGluZyA9ICd1dGY4JykgPT5cclxuICAgIGZyb21CYXNlNjQoQnVmZmVyLmZyb20oaW5wdXQsIGVuY29kaW5nKS50b1N0cmluZygnYmFzZTY0JykpO1xyXG59XHJcblxyXG5jb25zdCBkZWNvZGUgPSAoaW5wdXQpID0+IEJ1ZmZlci5mcm9tKGlucHV0LCAnYmFzZTY0Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XHJcbm1vZHVsZS5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcclxuIl0sIm5hbWVzIjpbImVuY29kZSIsIkJ1ZmZlciIsImlzRW5jb2RpbmciLCJpbnB1dCIsImVuY29kaW5nIiwiZnJvbSIsInRvU3RyaW5nIiwiZnJvbUJhc2U2NCIsImJhc2U2NCIsInJlcGxhY2UiLCJkZWNvZGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/base64url.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/client.js":
/*!**********************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/client.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const jose = __webpack_require__(/*! jose */ \"(rsc)/./node_modules/jose/dist/node/cjs/index.js\");\nconst { RPError } = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/openid-client/lib/errors.js\");\nconst { assertIssuerConfiguration } = __webpack_require__(/*! ./assert */ \"(rsc)/./node_modules/openid-client/lib/helpers/assert.js\");\nconst { random } = __webpack_require__(/*! ./generators */ \"(rsc)/./node_modules/openid-client/lib/helpers/generators.js\");\nconst now = __webpack_require__(/*! ./unix_timestamp */ \"(rsc)/./node_modules/openid-client/lib/helpers/unix_timestamp.js\");\nconst request = __webpack_require__(/*! ./request */ \"(rsc)/./node_modules/openid-client/lib/helpers/request.js\");\nconst { keystores } = __webpack_require__(/*! ./weak_cache */ \"(rsc)/./node_modules/openid-client/lib/helpers/weak_cache.js\");\nconst merge = __webpack_require__(/*! ./merge */ \"(rsc)/./node_modules/openid-client/lib/helpers/merge.js\");\nconst formUrlEncode = (value)=>encodeURIComponent(value).replace(/%20/g, \"+\");\nasync function clientAssertion(endpoint, payload) {\n    let alg = this[`${endpoint}_endpoint_auth_signing_alg`];\n    if (!alg) {\n        assertIssuerConfiguration(this.issuer, `${endpoint}_endpoint_auth_signing_alg_values_supported`);\n    }\n    if (this[`${endpoint}_endpoint_auth_method`] === \"client_secret_jwt\") {\n        if (!alg) {\n            const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];\n            alg = Array.isArray(supported) && supported.find((signAlg)=>/^HS(?:256|384|512)/.test(signAlg));\n        }\n        if (!alg) {\n            throw new RPError(`failed to determine a JWS Algorithm to use for ${this[`${endpoint}_endpoint_auth_method`]} Client Assertion`);\n        }\n        return new jose.CompactSign(Buffer.from(JSON.stringify(payload))).setProtectedHeader({\n            alg\n        }).sign(this.secretForAlg(alg));\n    }\n    const keystore = await keystores.get(this);\n    if (!keystore) {\n        throw new TypeError(\"no client jwks provided for signing a client assertion with\");\n    }\n    if (!alg) {\n        const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];\n        alg = Array.isArray(supported) && supported.find((signAlg)=>keystore.get({\n                alg: signAlg,\n                use: \"sig\"\n            }));\n    }\n    if (!alg) {\n        throw new RPError(`failed to determine a JWS Algorithm to use for ${this[`${endpoint}_endpoint_auth_method`]} Client Assertion`);\n    }\n    const key = keystore.get({\n        alg,\n        use: \"sig\"\n    });\n    if (!key) {\n        throw new RPError(`no key found in client jwks to sign a client assertion with using alg ${alg}`);\n    }\n    return new jose.CompactSign(Buffer.from(JSON.stringify(payload))).setProtectedHeader({\n        alg,\n        kid: key.jwk && key.jwk.kid\n    }).sign(await key.keyObject(alg));\n}\nasync function authFor(endpoint, { clientAssertionPayload } = {}) {\n    const authMethod = this[`${endpoint}_endpoint_auth_method`];\n    switch(authMethod){\n        case \"self_signed_tls_client_auth\":\n        case \"tls_client_auth\":\n        case \"none\":\n            return {\n                form: {\n                    client_id: this.client_id\n                }\n            };\n        case \"client_secret_post\":\n            if (typeof this.client_secret !== \"string\") {\n                throw new TypeError(\"client_secret_post client authentication method requires a client_secret\");\n            }\n            return {\n                form: {\n                    client_id: this.client_id,\n                    client_secret: this.client_secret\n                }\n            };\n        case \"private_key_jwt\":\n        case \"client_secret_jwt\":\n            {\n                const timestamp = now();\n                const audience = [\n                    ...new Set([\n                        this.issuer.issuer,\n                        this.issuer.token_endpoint\n                    ].filter(Boolean))\n                ];\n                const assertion = await clientAssertion.call(this, endpoint, {\n                    iat: timestamp,\n                    exp: timestamp + 60,\n                    jti: random(),\n                    iss: this.client_id,\n                    sub: this.client_id,\n                    aud: audience,\n                    ...clientAssertionPayload\n                });\n                return {\n                    form: {\n                        client_id: this.client_id,\n                        client_assertion: assertion,\n                        client_assertion_type: \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"\n                    }\n                };\n            }\n        case \"client_secret_basic\":\n            {\n                // This is correct behaviour, see https://tools.ietf.org/html/rfc6749#section-2.3.1 and the\n                // related appendix. (also https://github.com/panva/node-openid-client/pull/91)\n                // > The client identifier is encoded using the\n                // > \"application/x-www-form-urlencoded\" encoding algorithm per\n                // > Appendix B, and the encoded value is used as the username; the client\n                // > password is encoded using the same algorithm and used as the\n                // > password.\n                if (typeof this.client_secret !== \"string\") {\n                    throw new TypeError(\"client_secret_basic client authentication method requires a client_secret\");\n                }\n                const encoded = `${formUrlEncode(this.client_id)}:${formUrlEncode(this.client_secret)}`;\n                const value = Buffer.from(encoded).toString(\"base64\");\n                return {\n                    headers: {\n                        Authorization: `Basic ${value}`\n                    }\n                };\n            }\n        default:\n            {\n                throw new TypeError(`missing, or unsupported, ${endpoint}_endpoint_auth_method`);\n            }\n    }\n}\nfunction resolveResponseType() {\n    const { length, 0: value } = this.response_types;\n    if (length === 1) {\n        return value;\n    }\n    return undefined;\n}\nfunction resolveRedirectUri() {\n    const { length, 0: value } = this.redirect_uris || [];\n    if (length === 1) {\n        return value;\n    }\n    return undefined;\n}\nasync function authenticatedPost(endpoint, opts, { clientAssertionPayload, endpointAuthMethod = endpoint, DPoP } = {}) {\n    const auth = await authFor.call(this, endpointAuthMethod, {\n        clientAssertionPayload\n    });\n    const requestOpts = merge(opts, auth);\n    const mTLS = this[`${endpointAuthMethod}_endpoint_auth_method`].includes(\"tls_client_auth\") || endpoint === \"token\" && this.tls_client_certificate_bound_access_tokens;\n    let targetUrl;\n    if (mTLS && this.issuer.mtls_endpoint_aliases) {\n        targetUrl = this.issuer.mtls_endpoint_aliases[`${endpoint}_endpoint`];\n    }\n    targetUrl = targetUrl || this.issuer[`${endpoint}_endpoint`];\n    if (\"form\" in requestOpts) {\n        for (const [key, value] of Object.entries(requestOpts.form)){\n            if (typeof value === \"undefined\") {\n                delete requestOpts.form[key];\n            }\n        }\n    }\n    return request.call(this, {\n        ...requestOpts,\n        method: \"POST\",\n        url: targetUrl,\n        headers: {\n            ...endpoint !== \"revocation\" ? {\n                Accept: \"application/json\"\n            } : undefined,\n            ...requestOpts.headers\n        }\n    }, {\n        mTLS,\n        DPoP\n    });\n}\nmodule.exports = {\n    resolveResponseType,\n    resolveRedirectUri,\n    authFor,\n    authenticatedPost\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQUEsTUFBTUEsT0FBT0MsbUJBQU9BLENBQUM7QUFFckIsTUFBTSxFQUFFQyxPQUFPLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFFNUIsTUFBTSxFQUFFRSx5QkFBeUIsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUM5QyxNQUFNLEVBQUVHLE1BQU0sRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQztBQUMzQixNQUFNSSxNQUFNSixtQkFBT0EsQ0FBQztBQUNwQixNQUFNSyxVQUFVTCxtQkFBT0EsQ0FBQztBQUN4QixNQUFNLEVBQUVNLFNBQVMsRUFBRSxHQUFHTixtQkFBT0EsQ0FBQztBQUM5QixNQUFNTyxRQUFRUCxtQkFBT0EsQ0FBQztBQUV0QixNQUFNUSxnQkFBZ0IsQ0FBQ0MsUUFBVUMsbUJBQW1CRCxPQUFPRSxPQUFPLENBQUMsUUFBUTtBQUUzRSxlQUFlQyxnQkFBZ0JDLFFBQVEsRUFBRUMsT0FBTztJQUM5QyxJQUFJQyxNQUFNLElBQUksQ0FBQyxDQUFDLEVBQUVGLFNBQVMsMEJBQTBCLENBQUMsQ0FBQztJQUN2RCxJQUFJLENBQUNFLEtBQUs7UUFDUmIsMEJBQ0UsSUFBSSxDQUFDYyxNQUFNLEVBQ1gsQ0FBQyxFQUFFSCxTQUFTLDJDQUEyQyxDQUFDO0lBRTVEO0lBRUEsSUFBSSxJQUFJLENBQUMsQ0FBQyxFQUFFQSxTQUFTLHFCQUFxQixDQUFDLENBQUMsS0FBSyxxQkFBcUI7UUFDcEUsSUFBSSxDQUFDRSxLQUFLO1lBQ1IsTUFBTUUsWUFBWSxJQUFJLENBQUNELE1BQU0sQ0FBQyxDQUFDLEVBQUVILFNBQVMsMkNBQTJDLENBQUMsQ0FBQztZQUN2RkUsTUFDRUcsTUFBTUMsT0FBTyxDQUFDRixjQUFjQSxVQUFVRyxJQUFJLENBQUMsQ0FBQ0MsVUFBWSxxQkFBcUJDLElBQUksQ0FBQ0Q7UUFDdEY7UUFFQSxJQUFJLENBQUNOLEtB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RWM7UUFBTUg7SUFBSztBQUVqQjtBQUVBYSxPQUFPQyxPQUFPLEdBQUc7SUFDZnZCO0lBQ0FJO0lBQ0E5QjtJQUNBZ0M7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvY2xpZW50LmpzPzIzNzkiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgam9zZSA9IHJlcXVpcmUoJ2pvc2UnKTtcclxuXHJcbmNvbnN0IHsgUlBFcnJvciB9ID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XHJcblxyXG5jb25zdCB7IGFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24gfSA9IHJlcXVpcmUoJy4vYXNzZXJ0Jyk7XHJcbmNvbnN0IHsgcmFuZG9tIH0gPSByZXF1aXJlKCcuL2dlbmVyYXRvcnMnKTtcclxuY29uc3Qgbm93ID0gcmVxdWlyZSgnLi91bml4X3RpbWVzdGFtcCcpO1xyXG5jb25zdCByZXF1ZXN0ID0gcmVxdWlyZSgnLi9yZXF1ZXN0Jyk7XHJcbmNvbnN0IHsga2V5c3RvcmVzIH0gPSByZXF1aXJlKCcuL3dlYWtfY2FjaGUnKTtcclxuY29uc3QgbWVyZ2UgPSByZXF1aXJlKCcuL21lcmdlJyk7XHJcblxyXG5jb25zdCBmb3JtVXJsRW5jb2RlID0gKHZhbHVlKSA9PiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpLnJlcGxhY2UoLyUyMC9nLCAnKycpO1xyXG5cclxuYXN5bmMgZnVuY3Rpb24gY2xpZW50QXNzZXJ0aW9uKGVuZHBvaW50LCBwYXlsb2FkKSB7XHJcbiAgbGV0IGFsZyA9IHRoaXNbYCR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfc2lnbmluZ19hbGdgXTtcclxuICBpZiAoIWFsZykge1xyXG4gICAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbihcclxuICAgICAgdGhpcy5pc3N1ZXIsXHJcbiAgICAgIGAke2VuZHBvaW50fV9lbmRwb2ludF9hdXRoX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWRgLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGlmICh0aGlzW2Ake2VuZHBvaW50fV9lbmRwb2ludF9hdXRoX21ldGhvZGBdID09PSAnY2xpZW50X3NlY3JldF9qd3QnKSB7XHJcbiAgICBpZiAoIWFsZykge1xyXG4gICAgICBjb25zdCBzdXBwb3J0ZWQgPSB0aGlzLmlzc3VlcltgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkYF07XHJcbiAgICAgIGFsZyA9XHJcbiAgICAgICAgQXJyYXkuaXNBcnJheShzdXBwb3J0ZWQpICYmIHN1cHBvcnRlZC5maW5kKChzaWduQWxnKSA9PiAvXkhTKD86MjU2fDM4NHw1MTIpLy50ZXN0KHNpZ25BbGcpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWFsZykge1xyXG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcihcclxuICAgICAgICBgZmFpbGVkIHRvIGRldGVybWluZSBhIEpXUyBBbGdvcml0aG0gdG8gdXNlIGZvciAke1xyXG4gICAgICAgICAgdGhpc1tgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9tZXRob2RgXVxyXG4gICAgICAgIH0gQ2xpZW50IEFzc2VydGlvbmAsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBqb3NlLkNvbXBhY3RTaWduKEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKSlcclxuICAgICAgLnNldFByb3RlY3RlZEhlYWRlcih7IGFsZyB9KVxyXG4gICAgICAuc2lnbih0aGlzLnNlY3JldEZvckFsZyhhbGcpKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGtleXN0b3JlID0gYXdhaXQga2V5c3RvcmVzLmdldCh0aGlzKTtcclxuXHJcbiAgaWYgKCFrZXlzdG9yZSkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gY2xpZW50IGp3a3MgcHJvdmlkZWQgZm9yIHNpZ25pbmcgYSBjbGllbnQgYXNzZXJ0aW9uIHdpdGgnKTtcclxuICB9XHJcblxyXG4gIGlmICghYWxnKSB7XHJcbiAgICBjb25zdCBzdXBwb3J0ZWQgPSB0aGlzLmlzc3VlcltgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkYF07XHJcbiAgICBhbGcgPVxyXG4gICAgICBBcnJheS5pc0FycmF5KHN1cHBvcnRlZCkgJiZcclxuICAgICAgc3VwcG9ydGVkLmZpbmQoKHNpZ25BbGcpID0+IGtleXN0b3JlLmdldCh7IGFsZzogc2lnbkFsZywgdXNlOiAnc2lnJyB9KSk7XHJcbiAgfVxyXG5cclxuICBpZiAoIWFsZykge1xyXG4gICAgdGhyb3cgbmV3IFJQRXJyb3IoXHJcbiAgICAgIGBmYWlsZWQgdG8gZGV0ZXJtaW5lIGEgSldTIEFsZ29yaXRobSB0byB1c2UgZm9yICR7XHJcbiAgICAgICAgdGhpc1tgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9tZXRob2RgXVxyXG4gICAgICB9IENsaWVudCBBc3NlcnRpb25gLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGtleSA9IGtleXN0b3JlLmdldCh7IGFsZywgdXNlOiAnc2lnJyB9KTtcclxuICBpZiAoIWtleSkge1xyXG4gICAgdGhyb3cgbmV3IFJQRXJyb3IoXHJcbiAgICAgIGBubyBrZXkgZm91bmQgaW4gY2xpZW50IGp3a3MgdG8gc2lnbiBhIGNsaWVudCBhc3NlcnRpb24gd2l0aCB1c2luZyBhbGcgJHthbGd9YCxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3IGpvc2UuQ29tcGFjdFNpZ24oQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpKVxyXG4gICAgLnNldFByb3RlY3RlZEhlYWRlcih7IGFsZywga2lkOiBrZXkuandrICYmIGtleS5qd2sua2lkIH0pXHJcbiAgICAuc2lnbihhd2FpdCBrZXkua2V5T2JqZWN0KGFsZykpO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBhdXRoRm9yKGVuZHBvaW50LCB7IGNsaWVudEFzc2VydGlvblBheWxvYWQgfSA9IHt9KSB7XHJcbiAgY29uc3QgYXV0aE1ldGhvZCA9IHRoaXNbYCR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfbWV0aG9kYF07XHJcbiAgc3dpdGNoIChhdXRoTWV0aG9kKSB7XHJcbiAgICBjYXNlICdzZWxmX3NpZ25lZF90bHNfY2xpZW50X2F1dGgnOlxyXG4gICAgY2FzZSAndGxzX2NsaWVudF9hdXRoJzpcclxuICAgIGNhc2UgJ25vbmUnOlxyXG4gICAgICByZXR1cm4geyBmb3JtOiB7IGNsaWVudF9pZDogdGhpcy5jbGllbnRfaWQgfSB9O1xyXG4gICAgY2FzZSAnY2xpZW50X3NlY3JldF9wb3N0JzpcclxuICAgICAgaWYgKHR5cGVvZiB0aGlzLmNsaWVudF9zZWNyZXQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcclxuICAgICAgICAgICdjbGllbnRfc2VjcmV0X3Bvc3QgY2xpZW50IGF1dGhlbnRpY2F0aW9uIG1ldGhvZCByZXF1aXJlcyBhIGNsaWVudF9zZWNyZXQnLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHsgZm9ybTogeyBjbGllbnRfaWQ6IHRoaXMuY2xpZW50X2lkLCBjbGllbnRfc2VjcmV0OiB0aGlzLmNsaWVudF9zZWNyZXQgfSB9O1xyXG4gICAgY2FzZSAncHJpdmF0ZV9rZXlfand0JzpcclxuICAgIGNhc2UgJ2NsaWVudF9zZWNyZXRfand0Jzoge1xyXG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSBub3coKTtcclxuICAgICAgY29uc3QgYXVkaWVuY2UgPSBbXHJcbiAgICAgICAgLi4ubmV3IFNldChbdGhpcy5pc3N1ZXIuaXNzdWVyLCB0aGlzLmlzc3Vlci50b2tlbl9lbmRwb2ludF0uZmlsdGVyKEJvb2xlYW4pKSxcclxuICAgICAgXTtcclxuXHJcbiAgICAgIGNvbnN0IGFzc2VydGlvbiA9IGF3YWl0IGNsaWVudEFzc2VydGlvbi5jYWxsKHRoaXMsIGVuZHBvaW50LCB7XHJcbiAgICAgICAgaWF0OiB0aW1lc3RhbXAsXHJcbiAgICAgICAgZXhwOiB0aW1lc3RhbXAgKyA2MCxcclxuICAgICAgICBqdGk6IHJhbmRvbSgpLFxyXG4gICAgICAgIGlzczogdGhpcy5jbGllbnRfaWQsXHJcbiAgICAgICAgc3ViOiB0aGlzLmNsaWVudF9pZCxcclxuICAgICAgICBhdWQ6IGF1ZGllbmNlLFxyXG4gICAgICAgIC4uLmNsaWVudEFzc2VydGlvblBheWxvYWQsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBmb3JtOiB7XHJcbiAgICAgICAgICBjbGllbnRfaWQ6IHRoaXMuY2xpZW50X2lkLFxyXG4gICAgICAgICAgY2xpZW50X2Fzc2VydGlvbjogYXNzZXJ0aW9uLFxyXG4gICAgICAgICAgY2xpZW50X2Fzc2VydGlvbl90eXBlOiAndXJuOmlldGY6cGFyYW1zOm9hdXRoOmNsaWVudC1hc3NlcnRpb24tdHlwZTpqd3QtYmVhcmVyJyxcclxuICAgICAgICB9LFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgY2FzZSAnY2xpZW50X3NlY3JldF9iYXNpYyc6IHtcclxuICAgICAgLy8gVGhpcyBpcyBjb3JyZWN0IGJlaGF2aW91ciwgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NzQ5I3NlY3Rpb24tMi4zLjEgYW5kIHRoZVxyXG4gICAgICAvLyByZWxhdGVkIGFwcGVuZGl4LiAoYWxzbyBodHRwczovL2dpdGh1Yi5jb20vcGFudmEvbm9kZS1vcGVuaWQtY2xpZW50L3B1bGwvOTEpXHJcbiAgICAgIC8vID4gVGhlIGNsaWVudCBpZGVudGlmaWVyIGlzIGVuY29kZWQgdXNpbmcgdGhlXHJcbiAgICAgIC8vID4gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiBlbmNvZGluZyBhbGdvcml0aG0gcGVyXHJcbiAgICAgIC8vID4gQXBwZW5kaXggQiwgYW5kIHRoZSBlbmNvZGVkIHZhbHVlIGlzIHVzZWQgYXMgdGhlIHVzZXJuYW1lOyB0aGUgY2xpZW50XHJcbiAgICAgIC8vID4gcGFzc3dvcmQgaXMgZW5jb2RlZCB1c2luZyB0aGUgc2FtZSBhbGdvcml0aG0gYW5kIHVzZWQgYXMgdGhlXHJcbiAgICAgIC8vID4gcGFzc3dvcmQuXHJcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5jbGllbnRfc2VjcmV0ICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXHJcbiAgICAgICAgICAnY2xpZW50X3NlY3JldF9iYXNpYyBjbGllbnQgYXV0aGVudGljYXRpb24gbWV0aG9kIHJlcXVpcmVzIGEgY2xpZW50X3NlY3JldCcsXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBlbmNvZGVkID0gYCR7Zm9ybVVybEVuY29kZSh0aGlzLmNsaWVudF9pZCl9OiR7Zm9ybVVybEVuY29kZSh0aGlzLmNsaWVudF9zZWNyZXQpfWA7XHJcbiAgICAgIGNvbnN0IHZhbHVlID0gQnVmZmVyLmZyb20oZW5jb2RlZCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xyXG4gICAgICByZXR1cm4geyBoZWFkZXJzOiB7IEF1dGhvcml6YXRpb246IGBCYXNpYyAke3ZhbHVlfWAgfSB9O1xyXG4gICAgfVxyXG4gICAgZGVmYXVsdDoge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBtaXNzaW5nLCBvciB1bnN1cHBvcnRlZCwgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9tZXRob2RgKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVSZXNwb25zZVR5cGUoKSB7XHJcbiAgY29uc3QgeyBsZW5ndGgsIDA6IHZhbHVlIH0gPSB0aGlzLnJlc3BvbnNlX3R5cGVzO1xyXG5cclxuICBpZiAobGVuZ3RoID09PSAxKSB7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlUmVkaXJlY3RVcmkoKSB7XHJcbiAgY29uc3QgeyBsZW5ndGgsIDA6IHZhbHVlIH0gPSB0aGlzLnJlZGlyZWN0X3VyaXMgfHwgW107XHJcblxyXG4gIGlmIChsZW5ndGggPT09IDEpIHtcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcblxyXG4gIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGF1dGhlbnRpY2F0ZWRQb3N0KFxyXG4gIGVuZHBvaW50LFxyXG4gIG9wdHMsXHJcbiAgeyBjbGllbnRBc3NlcnRpb25QYXlsb2FkLCBlbmRwb2ludEF1dGhNZXRob2QgPSBlbmRwb2ludCwgRFBvUCB9ID0ge30sXHJcbikge1xyXG4gIGNvbnN0IGF1dGggPSBhd2FpdCBhdXRoRm9yLmNhbGwodGhpcywgZW5kcG9pbnRBdXRoTWV0aG9kLCB7IGNsaWVudEFzc2VydGlvblBheWxvYWQgfSk7XHJcbiAgY29uc3QgcmVxdWVzdE9wdHMgPSBtZXJnZShvcHRzLCBhdXRoKTtcclxuXHJcbiAgY29uc3QgbVRMUyA9XHJcbiAgICB0aGlzW2Ake2VuZHBvaW50QXV0aE1ldGhvZH1fZW5kcG9pbnRfYXV0aF9tZXRob2RgXS5pbmNsdWRlcygndGxzX2NsaWVudF9hdXRoJykgfHxcclxuICAgIChlbmRwb2ludCA9PT0gJ3Rva2VuJyAmJiB0aGlzLnRsc19jbGllbnRfY2VydGlmaWNhdGVfYm91bmRfYWNjZXNzX3Rva2Vucyk7XHJcblxyXG4gIGxldCB0YXJnZXRVcmw7XHJcbiAgaWYgKG1UTFMgJiYgdGhpcy5pc3N1ZXIubXRsc19lbmRwb2ludF9hbGlhc2VzKSB7XHJcbiAgICB0YXJnZXRVcmwgPSB0aGlzLmlzc3Vlci5tdGxzX2VuZHBvaW50X2FsaWFzZXNbYCR7ZW5kcG9pbnR9X2VuZHBvaW50YF07XHJcbiAgfVxyXG5cclxuICB0YXJnZXRVcmwgPSB0YXJnZXRVcmwgfHwgdGhpcy5pc3N1ZXJbYCR7ZW5kcG9pbnR9X2VuZHBvaW50YF07XHJcblxyXG4gIGlmICgnZm9ybScgaW4gcmVxdWVzdE9wdHMpIHtcclxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJlcXVlc3RPcHRzLmZvcm0pKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgZGVsZXRlIHJlcXVlc3RPcHRzLmZvcm1ba2V5XTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlcXVlc3QuY2FsbChcclxuICAgIHRoaXMsXHJcbiAgICB7XHJcbiAgICAgIC4uLnJlcXVlc3RPcHRzLFxyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgdXJsOiB0YXJnZXRVcmwsXHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAuLi4oZW5kcG9pbnQgIT09ICdyZXZvY2F0aW9uJ1xyXG4gICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIDogdW5kZWZpbmVkKSxcclxuICAgICAgICAuLi5yZXF1ZXN0T3B0cy5oZWFkZXJzLFxyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICAgIHsgbVRMUywgRFBvUCB9LFxyXG4gICk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIHJlc29sdmVSZXNwb25zZVR5cGUsXHJcbiAgcmVzb2x2ZVJlZGlyZWN0VXJpLFxyXG4gIGF1dGhGb3IsXHJcbiAgYXV0aGVudGljYXRlZFBvc3QsXHJcbn07XHJcbiJdLCJuYW1lcyI6WyJqb3NlIiwicmVxdWlyZSIsIlJQRXJyb3IiLCJhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uIiwicmFuZG9tIiwibm93IiwicmVxdWVzdCIsImtleXN0b3JlcyIsIm1lcmdlIiwiZm9ybVVybEVuY29kZSIsInZhbHVlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVwbGFjZSIsImNsaWVudEFzc2VydGlvbiIsImVuZHBvaW50IiwicGF5bG9hZCIsImFsZyIsImlzc3VlciIsInN1cHBvcnRlZCIsIkFycmF5IiwiaXNBcnJheSIsImZpbmQiLCJzaWduQWxnIiwidGVzdCIsIkNvbXBhY3RTaWduIiwiQnVmZmVyIiwiZnJvbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzZXRQcm90ZWN0ZWRIZWFkZXIiLCJzaWduIiwic2VjcmV0Rm9yQWxnIiwia2V5c3RvcmUiLCJnZXQiLCJUeXBlRXJyb3IiLCJ1c2UiLCJrZXkiLCJraWQiLCJqd2siLCJrZXlPYmplY3QiLCJhdXRoRm9yIiwiY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCIsImF1dGhNZXRob2QiLCJmb3JtIiwiY2xpZW50X2lkIiwiY2xpZW50X3NlY3JldCIsInRpbWVzdGFtcCIsImF1ZGllbmNlIiwiU2V0IiwidG9rZW5fZW5kcG9pbnQiLCJmaWx0ZXIiLCJCb29sZWFuIiwiYXNzZXJ0aW9uIiwiY2FsbCIsImlhdCIsImV4cCIsImp0aSIsImlzcyIsInN1YiIsImF1ZCIsImNsaWVudF9hc3NlcnRpb24iLCJjbGllbnRfYXNzZXJ0aW9uX3R5cGUiLCJlbmNvZGVkIiwidG9TdHJpbmciLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsInJlc29sdmVSZXNwb25zZVR5cGUiLCJsZW5ndGgiLCJyZXNwb25zZV90eXBlcyIsInVuZGVmaW5lZCIsInJlc29sdmVSZWRpcmVjdFVyaSIsInJlZGlyZWN0X3VyaXMiLCJhdXRoZW50aWNhdGVkUG9zdCIsIm9wdHMiLCJlbmRwb2ludEF1dGhNZXRob2QiLCJEUG9QIiwiYXV0aCIsInJlcXVlc3RPcHRzIiwibVRMUyIsImluY2x1ZGVzIiwidGxzX2NsaWVudF9jZXJ0aWZpY2F0ZV9ib3VuZF9hY2Nlc3NfdG9rZW5zIiwidGFyZ2V0VXJsIiwibXRsc19lbmRwb2ludF9hbGlhc2VzIiwiT2JqZWN0IiwiZW50cmllcyIsIm1ldGhvZCIsInVybCIsIkFjY2VwdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/consts.js":
/*!**********************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/consts.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("const HTTP_OPTIONS = Symbol();\nconst CLOCK_TOLERANCE = Symbol();\nmodule.exports = {\n    CLOCK_TOLERANCE,\n    HTTP_OPTIONS\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL2NvbnN0cy5qcz9lMDUzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEhUVFBfT1BUSU9OUyA9IFN5bWJvbCgpO1xyXG5jb25zdCBDTE9DS19UT0xFUkFOQ0UgPSBTeW1ib2woKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIENMT0NLX1RPTEVSQU5DRSxcclxuICBIVFRQX09QVElPTlMsXHJcbn07XHJcbiJdLCJuYW1lcyI6WyJIVFRQX09QVElPTlMiLCJTeW1ib2wiLCJDTE9DS19UT0xFUkFOQ0UiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQSxNQUFNQSxlQUFlQztBQUNyQixNQUFNQyxrQkFBa0JEO0FBRXhCRSxPQUFPQyxPQUFPLEdBQUc7SUFDZkY7SUFDQUY7QUFDRiIsImZpbGUiOiIocnNjKS8uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL2NvbnN0cy5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/consts.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/decode_jwt.js":
/*!**************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/decode_jwt.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const base64url = __webpack_require__(/*! ./base64url */ \"(rsc)/./node_modules/openid-client/lib/helpers/base64url.js\");\nmodule.exports = (token)=>{\n    if (typeof token !== \"string\" || !token) {\n        throw new TypeError(\"JWT must be a string\");\n    }\n    const { 0: header, 1: payload, 2: signature, length } = token.split(\".\");\n    if (length === 5) {\n        throw new TypeError(\"encrypted JWTs cannot be decoded\");\n    }\n    if (length !== 3) {\n        throw new Error(\"JWTs must have three components\");\n    }\n    try {\n        return {\n            header: JSON.parse(base64url.decode(header)),\n            payload: JSON.parse(base64url.decode(payload)),\n            signature\n        };\n    } catch (err) {\n        throw new Error(\"JWT is malformed\");\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9kZWNvZGVfand0LmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLFlBQVlDLG1CQUFPQSxDQUFDO0FBRTFCQyxPQUFPQyxPQUFPLEdBQUcsQ0FBQ0M7SUFDaEIsSUFBSSxPQUFPQSxVQUFVLFlBQVksQ0FBQ0EsT0FBTztRQUN2QyxNQUFNLElBQUlDLFVBQVU7SUFDdEI7SUFFQSxNQUFNLEVBQUUsR0FBR0MsTUFBTSxFQUFFLEdBQUdDLE9BQU8sRUFBRSxHQUFHQyxTQUFTLEVBQUVDLE1BQU0sRUFBRSxHQUFHTCxNQUFNTSxLQUFLLENBQUM7SUFFcEUsSUFBSUQsV0FBVyxHQUFHO1FBQ2hCLE1BQU0sSUFBSUosVUFBVTtJQUN0QjtJQUVBLElBQUlJLFdBQVcsR0FBRztRQUNoQixNQUFNLElBQUlFLE1BQU07SUFDbEI7SUFFQSxJQUFJO1FBQ0YsT0FBTztZQUNMTCxRQUFRTSxLQUFLQyxLQUFLLENBQUNiLFVBQVVjLE1BQU0sQ0FBQ1I7WUFDcENDLFNBQVNLLEtBQUtDLEtBQUssQ0FBQ2IsVUFBVWMsTUFBTSxDQUFDUDtZQUNyQ0M7UUFDRjtJQUNGLEVBQUUsT0FBT08sS0FBSztRQUNaLE1BQU0sSUFBSUosTUFBTTtJQUNsQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9kZWNvZGVfand0LmpzPzU2MDMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYmFzZTY0dXJsID0gcmVxdWlyZSgnLi9iYXNlNjR1cmwnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKHRva2VuKSA9PiB7XHJcbiAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ3N0cmluZycgfHwgIXRva2VuKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdKV1QgbXVzdCBiZSBhIHN0cmluZycpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgeyAwOiBoZWFkZXIsIDE6IHBheWxvYWQsIDI6IHNpZ25hdHVyZSwgbGVuZ3RoIH0gPSB0b2tlbi5zcGxpdCgnLicpO1xyXG5cclxuICBpZiAobGVuZ3RoID09PSA1KSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNyeXB0ZWQgSldUcyBjYW5ub3QgYmUgZGVjb2RlZCcpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGxlbmd0aCAhPT0gMykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdKV1RzIG11c3QgaGF2ZSB0aHJlZSBjb21wb25lbnRzJyk7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaGVhZGVyOiBKU09OLnBhcnNlKGJhc2U2NHVybC5kZWNvZGUoaGVhZGVyKSksXHJcbiAgICAgIHBheWxvYWQ6IEpTT04ucGFyc2UoYmFzZTY0dXJsLmRlY29kZShwYXlsb2FkKSksXHJcbiAgICAgIHNpZ25hdHVyZSxcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0pXVCBpcyBtYWxmb3JtZWQnKTtcclxuICB9XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJiYXNlNjR1cmwiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsInRva2VuIiwiVHlwZUVycm9yIiwiaGVhZGVyIiwicGF5bG9hZCIsInNpZ25hdHVyZSIsImxlbmd0aCIsInNwbGl0IiwiRXJyb3IiLCJKU09OIiwicGFyc2UiLCJkZWNvZGUiLCJlcnIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/decode_jwt.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/deep_clone.js":
/*!**************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/deep_clone.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("module.exports = globalThis.structuredClone || ((obj)=>JSON.parse(JSON.stringify(obj)));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL2RlZXBfY2xvbmUuanM/OGU0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbFRoaXMuc3RydWN0dXJlZENsb25lIHx8ICgob2JqKSA9PiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpKTtcclxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJnbG9iYWxUaGlzIiwic3RydWN0dXJlZENsb25lIiwib2JqIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5Il0sIm1hcHBpbmdzIjoiQUFBQUEsT0FBT0MsT0FBTyxHQUFHQyxXQUFXQyxlQUFlLElBQUssQ0FBQSxDQUFDQyxNQUFRQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLFNBQVMsQ0FBQ0gsS0FBSSIsImZpbGUiOiIocnNjKS8uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL2RlZXBfY2xvbmUuanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/deep_clone.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/defaults.js":
/*!************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/defaults.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const isPlainObject = __webpack_require__(/*! ./is_plain_object */ \"(rsc)/./node_modules/openid-client/lib/helpers/is_plain_object.js\");\nfunction defaults(deep, target, ...sources) {\n    for (const source of sources){\n        if (!isPlainObject(source)) {\n            continue;\n        }\n        for (const [key, value] of Object.entries(source)){\n            /* istanbul ignore if */ if (key === \"__proto__\" || key === \"constructor\") {\n                continue;\n            }\n            if (typeof target[key] === \"undefined\" && typeof value !== \"undefined\") {\n                target[key] = value;\n            }\n            if (deep && isPlainObject(target[key]) && isPlainObject(value)) {\n                defaults(true, target[key], value);\n            }\n        }\n    }\n    return target;\n}\nmodule.exports = defaults.bind(undefined, false);\nmodule.exports.deep = defaults.bind(undefined, true);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9kZWZhdWx0cy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxNQUFNQSxnQkFBZ0JDLG1CQUFPQSxDQUFDO0FBRTlCLFNBQVNDLFNBQVNDLElBQUksRUFBRUMsTUFBTSxFQUFFLEdBQUdDLE9BQU87SUFDeEMsS0FBSyxNQUFNQyxVQUFVRCxRQUFTO1FBQzVCLElBQUksQ0FBQ0wsY0FBY00sU0FBUztZQUMxQjtRQUNGO1FBQ0EsS0FBSyxNQUFNLENBQUNDLEtBQUtDLE1BQU0sSUFBSUMsT0FBT0MsT0FBTyxDQUFDSixRQUFTO1lBQ2pELHNCQUFzQixHQUN0QixJQUFJQyxRQUFRLGVBQWVBLFFBQVEsZUFBZTtnQkFDaEQ7WUFDRjtZQUNBLElBQUksT0FBT0gsTUFBTSxDQUFDRyxJQUFJLEtBQUssZUFBZSxPQUFPQyxVQUFVLGFBQWE7Z0JBQ3RFSixNQUFNLENBQUNHLElBQUksR0FBR0M7WUFDaEI7WUFFQSxJQUFJTCxRQUFRSCxjQUFjSSxNQUFNLENBQUNHLElBQUksS0FBS1AsY0FBY1EsUUFBUTtnQkFDOUROLFNBQVMsTUFBTUUsTUFBTSxDQUFDRyxJQUFJLEVBQUVDO1lBQzlCO1FBQ0Y7SUFDRjtJQUVBLE9BQU9KO0FBQ1Q7QUFFQU8sT0FBT0MsT0FBTyxHQUFHVixTQUFTVyxJQUFJLENBQUNDLFdBQVc7QUFDMUNILG1CQUFtQixHQUFHVCxTQUFTVyxJQUFJLENBQUNDLFdBQVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL2RlZmF1bHRzLmpzPzBjYjEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaXNfcGxhaW5fb2JqZWN0Jyk7XHJcblxyXG5mdW5jdGlvbiBkZWZhdWx0cyhkZWVwLCB0YXJnZXQsIC4uLnNvdXJjZXMpIHtcclxuICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XHJcbiAgICBpZiAoIWlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHNvdXJjZSkpIHtcclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nIHx8IGtleSA9PT0gJ2NvbnN0cnVjdG9yJykge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0eXBlb2YgdGFyZ2V0W2tleV0gPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZGVlcCAmJiBpc1BsYWluT2JqZWN0KHRhcmdldFtrZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgIGRlZmF1bHRzKHRydWUsIHRhcmdldFtrZXldLCB2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHMuYmluZCh1bmRlZmluZWQsIGZhbHNlKTtcclxubW9kdWxlLmV4cG9ydHMuZGVlcCA9IGRlZmF1bHRzLmJpbmQodW5kZWZpbmVkLCB0cnVlKTtcclxuIl0sIm5hbWVzIjpbImlzUGxhaW5PYmplY3QiLCJyZXF1aXJlIiwiZGVmYXVsdHMiLCJkZWVwIiwidGFyZ2V0Iiwic291cmNlcyIsInNvdXJjZSIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJiaW5kIiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/defaults.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/generators.js":
/*!**************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/generators.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { createHash, randomBytes } = __webpack_require__(/*! crypto */ \"crypto\");\nconst base64url = __webpack_require__(/*! ./base64url */ \"(rsc)/./node_modules/openid-client/lib/helpers/base64url.js\");\nconst random = (bytes = 32)=>base64url.encode(randomBytes(bytes));\nmodule.exports = {\n    random,\n    state: random,\n    nonce: random,\n    codeVerifier: random,\n    codeChallenge: (codeVerifier)=>base64url.encode(createHash(\"sha256\").update(codeVerifier).digest())\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9nZW5lcmF0b3JzLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU0sRUFBRUEsVUFBVSxFQUFFQyxXQUFXLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFFNUMsTUFBTUMsWUFBWUQsbUJBQU9BLENBQUM7QUFFMUIsTUFBTUUsU0FBUyxDQUFDQyxRQUFRLEVBQUUsR0FBS0YsVUFBVUcsTUFBTSxDQUFDTCxZQUFZSTtBQUU1REUsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZKO0lBQ0FLLE9BQU9MO0lBQ1BNLE9BQU9OO0lBQ1BPLGNBQWNQO0lBQ2RRLGVBQWUsQ0FBQ0QsZUFDZFIsVUFBVUcsTUFBTSxDQUFDTixXQUFXLFVBQVVhLE1BQU0sQ0FBQ0YsY0FBY0csTUFBTTtBQUNyRSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvZ2VuZXJhdG9ycy5qcz84MmY4Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgY3JlYXRlSGFzaCwgcmFuZG9tQnl0ZXMgfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xyXG5cclxuY29uc3QgYmFzZTY0dXJsID0gcmVxdWlyZSgnLi9iYXNlNjR1cmwnKTtcclxuXHJcbmNvbnN0IHJhbmRvbSA9IChieXRlcyA9IDMyKSA9PiBiYXNlNjR1cmwuZW5jb2RlKHJhbmRvbUJ5dGVzKGJ5dGVzKSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICByYW5kb20sXHJcbiAgc3RhdGU6IHJhbmRvbSxcclxuICBub25jZTogcmFuZG9tLFxyXG4gIGNvZGVWZXJpZmllcjogcmFuZG9tLFxyXG4gIGNvZGVDaGFsbGVuZ2U6IChjb2RlVmVyaWZpZXIpID0+XHJcbiAgICBiYXNlNjR1cmwuZW5jb2RlKGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShjb2RlVmVyaWZpZXIpLmRpZ2VzdCgpKSxcclxufTtcclxuIl0sIm5hbWVzIjpbImNyZWF0ZUhhc2giLCJyYW5kb21CeXRlcyIsInJlcXVpcmUiLCJiYXNlNjR1cmwiLCJyYW5kb20iLCJieXRlcyIsImVuY29kZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJzdGF0ZSIsIm5vbmNlIiwiY29kZVZlcmlmaWVyIiwiY29kZUNoYWxsZW5nZSIsInVwZGF0ZSIsImRpZ2VzdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/generators.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/is_key_object.js":
/*!*****************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/is_key_object.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const util = __webpack_require__(/*! util */ \"util\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nmodule.exports = util.types.isKeyObject || ((obj)=>obj && obj instanceof crypto.KeyObject);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9pc19rZXlfb2JqZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLE9BQU9DLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDO0FBRXZCRSxPQUFPQyxPQUFPLEdBQUdKLEtBQUtLLEtBQUssQ0FBQ0MsV0FBVyxJQUFLLEVBQUNDLE1BQVFBLE9BQU9BLGVBQWVMLE9BQU9NLFNBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL2lzX2tleV9vYmplY3QuanM/YTAwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xyXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gdXRpbC50eXBlcy5pc0tleU9iamVjdCB8fCAoKG9iaikgPT4gb2JqICYmIG9iaiBpbnN0YW5jZW9mIGNyeXB0by5LZXlPYmplY3QpO1xyXG4iXSwibmFtZXMiOlsidXRpbCIsInJlcXVpcmUiLCJjcnlwdG8iLCJtb2R1bGUiLCJleHBvcnRzIiwidHlwZXMiLCJpc0tleU9iamVjdCIsIm9iaiIsIktleU9iamVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/is_key_object.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/is_plain_object.js":
/*!*******************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/is_plain_object.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("module.exports = (a)=>!!a && a.constructor === Object;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL2lzX3BsYWluX29iamVjdC5qcz9lM2U4Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gKGEpID0+ICEhYSAmJiBhLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XHJcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiYSIsImNvbnN0cnVjdG9yIiwiT2JqZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsT0FBT0MsT0FBTyxHQUFHLENBQUNDLElBQU0sQ0FBQyxDQUFDQSxLQUFLQSxFQUFFQyxXQUFXLEtBQUtDIiwiZmlsZSI6Iihyc2MpLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvaXNfcGxhaW5fb2JqZWN0LmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/is_plain_object.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/issuer.js":
/*!**********************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/issuer.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const objectHash = __webpack_require__(/*! object-hash */ \"(rsc)/./node_modules/openid-client/node_modules/object-hash/index.js\");\nconst LRU = __webpack_require__(/*! lru-cache */ \"(rsc)/./node_modules/lru-cache/index.js\");\nconst { RPError } = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/openid-client/lib/errors.js\");\nconst { assertIssuerConfiguration } = __webpack_require__(/*! ./assert */ \"(rsc)/./node_modules/openid-client/lib/helpers/assert.js\");\nconst KeyStore = __webpack_require__(/*! ./keystore */ \"(rsc)/./node_modules/openid-client/lib/helpers/keystore.js\");\nconst { keystores } = __webpack_require__(/*! ./weak_cache */ \"(rsc)/./node_modules/openid-client/lib/helpers/weak_cache.js\");\nconst processResponse = __webpack_require__(/*! ./process_response */ \"(rsc)/./node_modules/openid-client/lib/helpers/process_response.js\");\nconst request = __webpack_require__(/*! ./request */ \"(rsc)/./node_modules/openid-client/lib/helpers/request.js\");\nconst inFlight = new WeakMap();\nconst caches = new WeakMap();\nconst lrus = (ctx)=>{\n    if (!caches.has(ctx)) {\n        caches.set(ctx, new LRU({\n            max: 100\n        }));\n    }\n    return caches.get(ctx);\n};\nasync function getKeyStore(reload = false) {\n    assertIssuerConfiguration(this, \"jwks_uri\");\n    const keystore = keystores.get(this);\n    const cache = lrus(this);\n    if (reload || !keystore) {\n        if (inFlight.has(this)) {\n            return inFlight.get(this);\n        }\n        cache.reset();\n        inFlight.set(this, (async ()=>{\n            const response = await request.call(this, {\n                method: \"GET\",\n                responseType: \"json\",\n                url: this.jwks_uri,\n                headers: {\n                    Accept: \"application/json, application/jwk-set+json\"\n                }\n            }).finally(()=>{\n                inFlight.delete(this);\n            });\n            const jwks = processResponse(response);\n            const joseKeyStore = KeyStore.fromJWKS(jwks, {\n                onlyPublic: true\n            });\n            cache.set(\"throttle\", true, 60 * 1000);\n            keystores.set(this, joseKeyStore);\n            return joseKeyStore;\n        })());\n        return inFlight.get(this);\n    }\n    return keystore;\n}\nasync function queryKeyStore({ kid, kty, alg, use }, { allowMulti = false } = {}) {\n    const cache = lrus(this);\n    const def = {\n        kid,\n        kty,\n        alg,\n        use\n    };\n    const defHash = objectHash(def, {\n        algorithm: \"sha256\",\n        ignoreUnknown: true,\n        unorderedArrays: true,\n        unorderedSets: true\n    });\n    // refresh keystore on every unknown key but also only upto once every minute\n    const freshJwksUri = cache.get(defHash) || cache.get(\"throttle\");\n    const keystore = await getKeyStore.call(this, !freshJwksUri);\n    const keys = keystore.all(def);\n    delete def.use;\n    if (keys.length === 0) {\n        throw new RPError({\n            printf: [\n                \"no valid key found in issuer's jwks_uri for key parameters %j\",\n                def\n            ],\n            jwks: keystore\n        });\n    }\n    if (!allowMulti && keys.length > 1 && !kid) {\n        throw new RPError({\n            printf: [\n                \"multiple matching keys found in issuer's jwks_uri for key parameters %j, kid must be provided in this case\",\n                def\n            ],\n            jwks: keystore\n        });\n    }\n    cache.set(defHash, true);\n    return keys;\n}\nmodule.exports.queryKeyStore = queryKeyStore;\nmodule.exports.keystore = getKeyStore;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9pc3N1ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsTUFBTUEsYUFBYUMsbUJBQU9BLENBQUM7QUFDM0IsTUFBTUMsTUFBTUQsbUJBQU9BLENBQUM7QUFFcEIsTUFBTSxFQUFFRSxPQUFPLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFFNUIsTUFBTSxFQUFFRyx5QkFBeUIsRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQztBQUM5QyxNQUFNSSxXQUFXSixtQkFBT0EsQ0FBQztBQUN6QixNQUFNLEVBQUVLLFNBQVMsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUM5QixNQUFNTSxrQkFBa0JOLG1CQUFPQSxDQUFDO0FBQ2hDLE1BQU1PLFVBQVVQLG1CQUFPQSxDQUFDO0FBRXhCLE1BQU1RLFdBQVcsSUFBSUM7QUFDckIsTUFBTUMsU0FBUyxJQUFJRDtBQUNuQixNQUFNRSxPQUFPLENBQUNDO0lBQ1osSUFBSSxDQUFDRixPQUFPRyxHQUFHLENBQUNELE1BQU07UUFDcEJGLE9BQU9JLEdBQUcsQ0FBQ0YsS0FBSyxJQUFJWCxJQUFJO1lBQUVjLEtBQUs7UUFBSTtJQUNyQztJQUNBLE9BQU9MLE9BQU9NLEdBQUcsQ0FBQ0o7QUFDcEI7QUFFQSxlQUFlSyxZQUFZQyxTQUFTLEtBQUs7SUFDdkNmLDBCQUEwQixJQUFJLEVBQUU7SUFFaEMsTUFBTWdCLFdBQVdkLFVBQVVXLEdBQUcsQ0FBQyxJQUFJO0lBQ25DLE1BQU1JLFFBQVFULEtBQUssSUFBSTtJQUV2QixJQUFJTyxVQUFVLENBQUNDLFVBQVU7UUFDdkIsSUFBSVgsU0FBU0ssR0FBRyxDQUFDLElBQUksR0FBRztZQUN0QixPQUFPTCxTQUFTUSxHQUFHLENBQUMsSUFBSTtRQUMxQjtRQUNBSSxNQUFNQyxLQUFLO1FBQ1hiLFNBQVNNLEdBQUcsQ0FDVixJQUFJLEVBQ0osQ0FBQztZQUNDLE1BQU1RLFdBQVcsTUFBTWYsUUFDcEJnQixJQUFJLENBQUMsSUFBSSxFQUFFO2dCQUNWQyxRQUFRO2dCQUNSQyxjQUFjO2dCQUNkQyxLQUFLLElBQUksQ0FBQ0MsUUFBUTtnQkFDbEJDLFNBQVM7b0JBQ1BDLFFBQVE7Z0JBQ1Y7WUFDRixHQUNDQyxPQUFPLENBQUM7Z0JBQ1B0QixTQUFTdUIsTUFBTSxDQUFDLElBQUk7WUFDdEI7WUFDRixNQUFNQyxPQUFPMUIsZ0JBQWdCZ0I7WUFFN0IsTUFBTVcsZUFBZTdCLFNBQVM4QixRQUFRLENBQUNGLE1BQU07Z0JBQUVHLFlBQVk7WUFBSztZQUNoRWYsTUFBTU4sR0FBRyxDQUFDLFlBQVksTUFBTSxLQUFLO1lBQ2pDVCxVQUFVUyxHQUFHLENBQUMsSUFBSSxFQUFFbUI7WUFFcEIsT0FBT0E7UUFDVDtRQUdGLE9BQU96QixTQUFTUSxHQUFHLENBQUMsSUFBSTtJQUMxQjtJQUVBLE9BQU9HO0FBQ1Q7QUFFQSxlQUFlaUIsY0FBYyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUUsRUFBRSxFQUFFQyxhQUFhLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztJQUM5RSxNQUFNckIsUUFBUVQsS0FBSyxJQUFJO0lBRXZCLE1BQU0rQixNQUFNO1FBQ1ZMO1FBQ0FDO1FBQ0FDO1FBQ0FDO0lBQ0Y7SUFFQSxNQUFNRyxVQUFVNUMsV0FBVzJDLEtBQUs7UUFDOUJFLFdBQVc7UUFDWEMsZUFBZTtRQUNmQyxpQkFBaUI7UUFDakJDLGVBQWU7SUFDakI7SUFFQSw2RUFBNkU7SUFDN0UsTUFBTUMsZUFBZTVCLE1BQU1KLEdBQUcsQ0FBQzJCLFlBQVl2QixNQUFNSixHQUFHLENBQUM7SUFFckQsTUFBTUcsV0FBVyxNQUFNRixZQUFZTSxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUN5QjtJQUMvQyxNQUFNQyxPQUFPOUIsU0FBUytCLEdBQUcsQ0FBQ1I7SUFFMUIsT0FBT0EsSUFBSUYsR0FBRztJQUNkLElBQUlTLEtBQUtFLE1BQU0sS0FBSyxHQUFHO1FBQ3JCLE1BQU0sSUFBSWpELFFBQVE7WUFDaEJrRCxRQUFRO2dCQUFDO2dCQUFpRVY7YUFBSTtZQUM5RVYsTUFBTWI7UUFDUjtJQUNGO0lBRUEsSUFBSSxDQUFDc0IsY0FBY1EsS0FBS0UsTUFBTSxHQUFHLEtBQUssQ0FBQ2QsS0FBSztRQUMxQyxNQUFNLElBQUluQyxRQUFRO1lBQ2hCa0QsUUFBUTtnQkFDTjtnQkFDQVY7YUFDRDtZQUNEVixNQUFNYjtRQUNSO0lBQ0Y7SUFFQUMsTUFBTU4sR0FBRyxDQUFDNkIsU0FBUztJQUVuQixPQUFPTTtBQUNUO0FBRUFJLDRCQUE0QixHQUFHakI7QUFDL0JpQix1QkFBdUIsR0FBR3BDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9pc3N1ZXIuanM/NGE3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBvYmplY3RIYXNoID0gcmVxdWlyZSgnb2JqZWN0LWhhc2gnKTtcclxuY29uc3QgTFJVID0gcmVxdWlyZSgnbHJ1LWNhY2hlJyk7XHJcblxyXG5jb25zdCB7IFJQRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xyXG5cclxuY29uc3QgeyBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uIH0gPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xyXG5jb25zdCBLZXlTdG9yZSA9IHJlcXVpcmUoJy4va2V5c3RvcmUnKTtcclxuY29uc3QgeyBrZXlzdG9yZXMgfSA9IHJlcXVpcmUoJy4vd2Vha19jYWNoZScpO1xyXG5jb25zdCBwcm9jZXNzUmVzcG9uc2UgPSByZXF1aXJlKCcuL3Byb2Nlc3NfcmVzcG9uc2UnKTtcclxuY29uc3QgcmVxdWVzdCA9IHJlcXVpcmUoJy4vcmVxdWVzdCcpO1xyXG5cclxuY29uc3QgaW5GbGlnaHQgPSBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCBjYWNoZXMgPSBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCBscnVzID0gKGN0eCkgPT4ge1xyXG4gIGlmICghY2FjaGVzLmhhcyhjdHgpKSB7XHJcbiAgICBjYWNoZXMuc2V0KGN0eCwgbmV3IExSVSh7IG1heDogMTAwIH0pKTtcclxuICB9XHJcbiAgcmV0dXJuIGNhY2hlcy5nZXQoY3R4KTtcclxufTtcclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGdldEtleVN0b3JlKHJlbG9hZCA9IGZhbHNlKSB7XHJcbiAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbih0aGlzLCAnandrc191cmknKTtcclxuXHJcbiAgY29uc3Qga2V5c3RvcmUgPSBrZXlzdG9yZXMuZ2V0KHRoaXMpO1xyXG4gIGNvbnN0IGNhY2hlID0gbHJ1cyh0aGlzKTtcclxuXHJcbiAgaWYgKHJlbG9hZCB8fCAha2V5c3RvcmUpIHtcclxuICAgIGlmIChpbkZsaWdodC5oYXModGhpcykpIHtcclxuICAgICAgcmV0dXJuIGluRmxpZ2h0LmdldCh0aGlzKTtcclxuICAgIH1cclxuICAgIGNhY2hlLnJlc2V0KCk7XHJcbiAgICBpbkZsaWdodC5zZXQoXHJcbiAgICAgIHRoaXMsXHJcbiAgICAgIChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0XHJcbiAgICAgICAgICAuY2FsbCh0aGlzLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxyXG4gICAgICAgICAgICB1cmw6IHRoaXMuandrc191cmksXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uLCBhcHBsaWNhdGlvbi9qd2stc2V0K2pzb24nLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcclxuICAgICAgICAgICAgaW5GbGlnaHQuZGVsZXRlKHRoaXMpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgandrcyA9IHByb2Nlc3NSZXNwb25zZShyZXNwb25zZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGpvc2VLZXlTdG9yZSA9IEtleVN0b3JlLmZyb21KV0tTKGp3a3MsIHsgb25seVB1YmxpYzogdHJ1ZSB9KTtcclxuICAgICAgICBjYWNoZS5zZXQoJ3Rocm90dGxlJywgdHJ1ZSwgNjAgKiAxMDAwKTtcclxuICAgICAgICBrZXlzdG9yZXMuc2V0KHRoaXMsIGpvc2VLZXlTdG9yZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBqb3NlS2V5U3RvcmU7XHJcbiAgICAgIH0pKCksXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiBpbkZsaWdodC5nZXQodGhpcyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ga2V5c3RvcmU7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHF1ZXJ5S2V5U3RvcmUoeyBraWQsIGt0eSwgYWxnLCB1c2UgfSwgeyBhbGxvd011bHRpID0gZmFsc2UgfSA9IHt9KSB7XHJcbiAgY29uc3QgY2FjaGUgPSBscnVzKHRoaXMpO1xyXG5cclxuICBjb25zdCBkZWYgPSB7XHJcbiAgICBraWQsXHJcbiAgICBrdHksXHJcbiAgICBhbGcsXHJcbiAgICB1c2UsXHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZGVmSGFzaCA9IG9iamVjdEhhc2goZGVmLCB7XHJcbiAgICBhbGdvcml0aG06ICdzaGEyNTYnLFxyXG4gICAgaWdub3JlVW5rbm93bjogdHJ1ZSxcclxuICAgIHVub3JkZXJlZEFycmF5czogdHJ1ZSxcclxuICAgIHVub3JkZXJlZFNldHM6IHRydWUsXHJcbiAgfSk7XHJcblxyXG4gIC8vIHJlZnJlc2gga2V5c3RvcmUgb24gZXZlcnkgdW5rbm93biBrZXkgYnV0IGFsc28gb25seSB1cHRvIG9uY2UgZXZlcnkgbWludXRlXHJcbiAgY29uc3QgZnJlc2hKd2tzVXJpID0gY2FjaGUuZ2V0KGRlZkhhc2gpIHx8IGNhY2hlLmdldCgndGhyb3R0bGUnKTtcclxuXHJcbiAgY29uc3Qga2V5c3RvcmUgPSBhd2FpdCBnZXRLZXlTdG9yZS5jYWxsKHRoaXMsICFmcmVzaEp3a3NVcmkpO1xyXG4gIGNvbnN0IGtleXMgPSBrZXlzdG9yZS5hbGwoZGVmKTtcclxuXHJcbiAgZGVsZXRlIGRlZi51c2U7XHJcbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgIHByaW50ZjogW1wibm8gdmFsaWQga2V5IGZvdW5kIGluIGlzc3VlcidzIGp3a3NfdXJpIGZvciBrZXkgcGFyYW1ldGVycyAlalwiLCBkZWZdLFxyXG4gICAgICBqd2tzOiBrZXlzdG9yZSxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFhbGxvd011bHRpICYmIGtleXMubGVuZ3RoID4gMSAmJiAha2lkKSB7XHJcbiAgICB0aHJvdyBuZXcgUlBFcnJvcih7XHJcbiAgICAgIHByaW50ZjogW1xyXG4gICAgICAgIFwibXVsdGlwbGUgbWF0Y2hpbmcga2V5cyBmb3VuZCBpbiBpc3N1ZXIncyBqd2tzX3VyaSBmb3Iga2V5IHBhcmFtZXRlcnMgJWosIGtpZCBtdXN0IGJlIHByb3ZpZGVkIGluIHRoaXMgY2FzZVwiLFxyXG4gICAgICAgIGRlZixcclxuICAgICAgXSxcclxuICAgICAgandrczoga2V5c3RvcmUsXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGNhY2hlLnNldChkZWZIYXNoLCB0cnVlKTtcclxuXHJcbiAgcmV0dXJuIGtleXM7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzLnF1ZXJ5S2V5U3RvcmUgPSBxdWVyeUtleVN0b3JlO1xyXG5tb2R1bGUuZXhwb3J0cy5rZXlzdG9yZSA9IGdldEtleVN0b3JlO1xyXG4iXSwibmFtZXMiOlsib2JqZWN0SGFzaCIsInJlcXVpcmUiLCJMUlUiLCJSUEVycm9yIiwiYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbiIsIktleVN0b3JlIiwia2V5c3RvcmVzIiwicHJvY2Vzc1Jlc3BvbnNlIiwicmVxdWVzdCIsImluRmxpZ2h0IiwiV2Vha01hcCIsImNhY2hlcyIsImxydXMiLCJjdHgiLCJoYXMiLCJzZXQiLCJtYXgiLCJnZXQiLCJnZXRLZXlTdG9yZSIsInJlbG9hZCIsImtleXN0b3JlIiwiY2FjaGUiLCJyZXNldCIsInJlc3BvbnNlIiwiY2FsbCIsIm1ldGhvZCIsInJlc3BvbnNlVHlwZSIsInVybCIsImp3a3NfdXJpIiwiaGVhZGVycyIsIkFjY2VwdCIsImZpbmFsbHkiLCJkZWxldGUiLCJqd2tzIiwiam9zZUtleVN0b3JlIiwiZnJvbUpXS1MiLCJvbmx5UHVibGljIiwicXVlcnlLZXlTdG9yZSIsImtpZCIsImt0eSIsImFsZyIsInVzZSIsImFsbG93TXVsdGkiLCJkZWYiLCJkZWZIYXNoIiwiYWxnb3JpdGhtIiwiaWdub3JlVW5rbm93biIsInVub3JkZXJlZEFycmF5cyIsInVub3JkZXJlZFNldHMiLCJmcmVzaEp3a3NVcmkiLCJrZXlzIiwiYWxsIiwibGVuZ3RoIiwicHJpbnRmIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/issuer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/keystore.js":
/*!************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/keystore.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const jose = __webpack_require__(/*! jose */ \"(rsc)/./node_modules/jose/dist/node/cjs/index.js\");\nconst clone = __webpack_require__(/*! ./deep_clone */ \"(rsc)/./node_modules/openid-client/lib/helpers/deep_clone.js\");\nconst isPlainObject = __webpack_require__(/*! ./is_plain_object */ \"(rsc)/./node_modules/openid-client/lib/helpers/is_plain_object.js\");\nconst internal = Symbol();\nfunction fauxAlg(kty) {\n    switch(kty){\n        case \"RSA\":\n            return \"RSA-OAEP\";\n        case \"EC\":\n            return \"ECDH-ES\";\n        case \"OKP\":\n            return \"ECDH-ES\";\n        case \"oct\":\n            return \"HS256\";\n        default:\n            return undefined;\n    }\n}\nconst keyscore = (key, { alg, use })=>{\n    let score = 0;\n    if (alg && key.alg) {\n        score++;\n    }\n    if (use && key.use) {\n        score++;\n    }\n    return score;\n};\nfunction getKtyFromAlg(alg) {\n    switch(typeof alg === \"string\" && alg.slice(0, 2)){\n        case \"RS\":\n        case \"PS\":\n            return \"RSA\";\n        case \"ES\":\n            return \"EC\";\n        case \"Ed\":\n            return \"OKP\";\n        default:\n            return undefined;\n    }\n}\nfunction getAlgorithms(use, alg, kty, crv) {\n    // Ed25519, Ed448, and secp256k1 always have \"alg\"\n    // OKP always has \"use\"\n    if (alg) {\n        return new Set([\n            alg\n        ]);\n    }\n    switch(kty){\n        case \"EC\":\n            {\n                let algs = [];\n                if (use === \"enc\" || use === undefined) {\n                    algs = algs.concat([\n                        \"ECDH-ES\",\n                        \"ECDH-ES+A128KW\",\n                        \"ECDH-ES+A192KW\",\n                        \"ECDH-ES+A256KW\"\n                    ]);\n                }\n                if (use === \"sig\" || use === undefined) {\n                    switch(crv){\n                        case \"P-256\":\n                        case \"P-384\":\n                            algs = algs.concat([\n                                `ES${crv.slice(-3)}`.replace(\"21\", \"12\")\n                            ]);\n                            break;\n                        case \"P-521\":\n                            algs = algs.concat([\n                                \"ES512\"\n                            ]);\n                            break;\n                        case \"secp256k1\":\n                            if (jose.cryptoRuntime === \"node:crypto\") {\n                                algs = algs.concat([\n                                    \"ES256K\"\n                                ]);\n                            }\n                            break;\n                    }\n                }\n                return new Set(algs);\n            }\n        case \"OKP\":\n            {\n                return new Set([\n                    \"ECDH-ES\",\n                    \"ECDH-ES+A128KW\",\n                    \"ECDH-ES+A192KW\",\n                    \"ECDH-ES+A256KW\"\n                ]);\n            }\n        case \"RSA\":\n            {\n                let algs = [];\n                if (use === \"enc\" || use === undefined) {\n                    algs = algs.concat([\n                        \"RSA-OAEP\",\n                        \"RSA-OAEP-256\",\n                        \"RSA-OAEP-384\",\n                        \"RSA-OAEP-512\"\n                    ]);\n                    if (jose.cryptoRuntime === \"node:crypto\") {\n                        algs = algs.concat([\n                            \"RSA1_5\"\n                        ]);\n                    }\n                }\n                if (use === \"sig\" || use === undefined) {\n                    algs = algs.concat([\n                        \"PS256\",\n                        \"PS384\",\n                        \"PS512\",\n                        \"RS256\",\n                        \"RS384\",\n                        \"RS512\"\n                    ]);\n                }\n                return new Set(algs);\n            }\n        default:\n            throw new Error(\"unreachable\");\n    }\n}\nmodule.exports = class KeyStore {\n    #keys;\n    constructor(i, keys){\n        if (i !== internal) throw new Error(\"invalid constructor call\");\n        this.#keys = keys;\n    }\n    toJWKS() {\n        return {\n            keys: this.map(({ jwk: { d, p, q, dp, dq, qi, ...jwk } })=>jwk)\n        };\n    }\n    all({ alg, kid, use } = {}) {\n        if (!use || !alg) {\n            throw new Error();\n        }\n        const kty = getKtyFromAlg(alg);\n        const search = {\n            alg,\n            use\n        };\n        return this.filter((key)=>{\n            let candidate = true;\n            if (candidate && kty !== undefined && key.jwk.kty !== kty) {\n                candidate = false;\n            }\n            if (candidate && kid !== undefined && key.jwk.kid !== kid) {\n                candidate = false;\n            }\n            if (candidate && use !== undefined && key.jwk.use !== undefined && key.jwk.use !== use) {\n                candidate = false;\n            }\n            if (candidate && key.jwk.alg && key.jwk.alg !== alg) {\n                candidate = false;\n            } else if (!key.algorithms.has(alg)) {\n                candidate = false;\n            }\n            return candidate;\n        }).sort((first, second)=>keyscore(second, search) - keyscore(first, search));\n    }\n    get(...args) {\n        return this.all(...args)[0];\n    }\n    static async fromJWKS(jwks, { onlyPublic = false, onlyPrivate = false } = {}) {\n        if (!isPlainObject(jwks) || !Array.isArray(jwks.keys) || jwks.keys.some((k)=>!isPlainObject(k) || !(\"kty\" in k))) {\n            throw new TypeError(\"jwks must be a JSON Web Key Set formatted object\");\n        }\n        const keys = [];\n        for (let jwk of jwks.keys){\n            jwk = clone(jwk);\n            const { kty, kid, crv } = jwk;\n            let { alg, use } = jwk;\n            if (typeof kty !== \"string\" || !kty) {\n                continue;\n            }\n            if (use !== undefined && use !== \"sig\" && use !== \"enc\") {\n                continue;\n            }\n            if (typeof alg !== \"string\" && alg !== undefined) {\n                continue;\n            }\n            if (typeof kid !== \"string\" && kid !== undefined) {\n                continue;\n            }\n            if (kty === \"EC\" && use === \"sig\") {\n                switch(crv){\n                    case \"P-256\":\n                        alg = \"ES256\";\n                        break;\n                    case \"P-384\":\n                        alg = \"ES384\";\n                        break;\n                    case \"P-521\":\n                        alg = \"ES512\";\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (crv === \"secp256k1\") {\n                use = \"sig\";\n                alg = \"ES256K\";\n            }\n            if (kty === \"OKP\") {\n                switch(crv){\n                    case \"Ed25519\":\n                    case \"Ed448\":\n                        use = \"sig\";\n                        alg = \"EdDSA\";\n                        break;\n                    case \"X25519\":\n                    case \"X448\":\n                        use = \"enc\";\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (alg && !use) {\n                switch(true){\n                    case alg.startsWith(\"ECDH\"):\n                        use = \"enc\";\n                        break;\n                    case alg.startsWith(\"RSA\"):\n                        use = \"enc\";\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (onlyPrivate && (jwk.kty === \"oct\" || !jwk.d)) {\n                throw new Error(\"jwks must only contain private keys\");\n            }\n            if (onlyPublic && (jwk.d || jwk.k)) {\n                continue;\n            }\n            keys.push({\n                jwk: {\n                    ...jwk,\n                    alg,\n                    use\n                },\n                async keyObject (alg) {\n                    if (this[alg]) {\n                        return this[alg];\n                    }\n                    const keyObject = await jose.importJWK(this.jwk, alg);\n                    this[alg] = keyObject;\n                    return keyObject;\n                },\n                get algorithms () {\n                    Object.defineProperty(this, \"algorithms\", {\n                        value: getAlgorithms(this.jwk.use, this.jwk.alg, this.jwk.kty, this.jwk.crv),\n                        enumerable: true,\n                        configurable: false\n                    });\n                    return this.algorithms;\n                }\n            });\n        }\n        return new this(internal, keys);\n    }\n    filter(...args) {\n        return this.#keys.filter(...args);\n    }\n    find(...args) {\n        return this.#keys.find(...args);\n    }\n    every(...args) {\n        return this.#keys.every(...args);\n    }\n    some(...args) {\n        return this.#keys.some(...args);\n    }\n    map(...args) {\n        return this.#keys.map(...args);\n    }\n    forEach(...args) {\n        return this.#keys.forEach(...args);\n    }\n    reduce(...args) {\n        return this.#keys.reduce(...args);\n    }\n    sort(...args) {\n        return this.#keys.sort(...args);\n    }\n    *[Symbol.iterator]() {\n        for (const key of this.#keys){\n            yield key;\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9rZXlzdG9yZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxNQUFNQSxPQUFPQyxtQkFBT0EsQ0FBQztBQUVyQixNQUFNQyxRQUFRRCxtQkFBT0EsQ0FBQztBQUN0QixNQUFNRSxnQkFBZ0JGLG1CQUFPQSxDQUFDO0FBRTlCLE1BQU1HLFdBQVdDO0FBRWpCLFNBQVNDLFFBQVFDLEdBQUc7SUFDbEIsT0FBUUE7UUFDTixLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNUO1lBQ0UsT0FBT0M7SUFDWDtBQUNGO0FBRUEsTUFBTUMsV0FBVyxDQUFDQyxLQUFLLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFO0lBQ2pDLElBQUlDLFFBQVE7SUFFWixJQUFJRixPQUFPRCxJQUFJQyxHQUFHLEVBQUU7UUFDbEJFO0lBQ0Y7SUFFQSxJQUFJRCxPQUFPRixJQUFJRSxHQUFHLEVBQUU7UUFDbEJDO0lBQ0Y7SUFFQSxPQUFPQTtBQUNUO0FBRUEsU0FBU0MsY0FBY0gsR0FBRztJQUN4QixPQUFRLE9BQU9BLFFBQVEsWUFBWUEsSUFBSUksS0FBSyxDQUFDLEdBQUc7UUFDOUMsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNUO1lBQ0UsT0FBT1A7SUFDWDtBQUNGO0FBRUEsU0FBU1EsY0FBY0osR0FBRyxFQUFFRCxHQUFHLEVBQUVKLEdBQUcsRUFBRVUsR0FBRztJQUN2QyxrREFBa0Q7SUFDbEQsdUJBQXVCO0lBQ3ZCLElBQUlOLEtBQUs7UUFDUCxPQUFPLElBQUlPLElBQUk7WUFBQ1A7U0FBSTtJQUN0QjtJQUVBLE9BQVFKO1FBQ04sS0FBSztZQUFNO2dCQUNULElBQUlZLE9BQU8sRUFBRTtnQkFFYixJQUFJUCxRQUFRLFNBQVNBLFFBQVFK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SSxDQUFDSSxHQUFHLElBQUltQjtJQUMzQjtJQUVBcUIsUUFBUSxHQUFHckIsSUFBSSxFQUFFO1FBQ2YsT0FBTyxJQUFJLENBQUMsQ0FBQ3ZCLElBQUksQ0FBQzRDLE9BQU8sSUFBSXJCO0lBQy9CO0lBRUFzQixPQUFPLEdBQUd0QixJQUFJLEVBQUU7UUFDZCxPQUFPLElBQUksQ0FBQyxDQUFDdkIsSUFBSSxDQUFDNkMsTUFBTSxJQUFJdEI7SUFDOUI7SUFFQUosS0FBSyxHQUFHSSxJQUFJLEVBQUU7UUFDWixPQUFPLElBQUksQ0FBQyxDQUFDdkIsSUFBSSxDQUFDbUIsSUFBSSxJQUFJSTtJQUM1QjtJQUVBLENBQUMsQ0FBQzdDLE9BQU9vRSxRQUFRLENBQUMsR0FBRztRQUNuQixLQUFLLE1BQU0vRCxPQUFPLElBQUksQ0FBQyxDQUFDaUIsSUFBSSxDQUFFO1lBQzVCLE1BQU1qQjtRQUNSO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMva2V5c3RvcmUuanM/OGY4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBqb3NlID0gcmVxdWlyZSgnam9zZScpO1xyXG5cclxuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuL2RlZXBfY2xvbmUnKTtcclxuY29uc3QgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaXNfcGxhaW5fb2JqZWN0Jyk7XHJcblxyXG5jb25zdCBpbnRlcm5hbCA9IFN5bWJvbCgpO1xyXG5cclxuZnVuY3Rpb24gZmF1eEFsZyhrdHkpIHtcclxuICBzd2l0Y2ggKGt0eSkge1xyXG4gICAgY2FzZSAnUlNBJzpcclxuICAgICAgcmV0dXJuICdSU0EtT0FFUCc7XHJcbiAgICBjYXNlICdFQyc6XHJcbiAgICAgIHJldHVybiAnRUNESC1FUyc7XHJcbiAgICBjYXNlICdPS1AnOlxyXG4gICAgICByZXR1cm4gJ0VDREgtRVMnO1xyXG4gICAgY2FzZSAnb2N0JzpcclxuICAgICAgcmV0dXJuICdIUzI1Nic7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxufVxyXG5cclxuY29uc3Qga2V5c2NvcmUgPSAoa2V5LCB7IGFsZywgdXNlIH0pID0+IHtcclxuICBsZXQgc2NvcmUgPSAwO1xyXG5cclxuICBpZiAoYWxnICYmIGtleS5hbGcpIHtcclxuICAgIHNjb3JlKys7XHJcbiAgfVxyXG5cclxuICBpZiAodXNlICYmIGtleS51c2UpIHtcclxuICAgIHNjb3JlKys7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc2NvcmU7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBnZXRLdHlGcm9tQWxnKGFsZykge1xyXG4gIHN3aXRjaCAodHlwZW9mIGFsZyA9PT0gJ3N0cmluZycgJiYgYWxnLnNsaWNlKDAsIDIpKSB7XHJcbiAgICBjYXNlICdSUyc6XHJcbiAgICBjYXNlICdQUyc6XHJcbiAgICAgIHJldHVybiAnUlNBJztcclxuICAgIGNhc2UgJ0VTJzpcclxuICAgICAgcmV0dXJuICdFQyc7XHJcbiAgICBjYXNlICdFZCc6XHJcbiAgICAgIHJldHVybiAnT0tQJztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRBbGdvcml0aG1zKHVzZSwgYWxnLCBrdHksIGNydikge1xyXG4gIC8vIEVkMjU1MTksIEVkNDQ4LCBhbmQgc2VjcDI1NmsxIGFsd2F5cyBoYXZlIFwiYWxnXCJcclxuICAvLyBPS1AgYWx3YXlzIGhhcyBcInVzZVwiXHJcbiAgaWYgKGFsZykge1xyXG4gICAgcmV0dXJuIG5ldyBTZXQoW2FsZ10pO1xyXG4gIH1cclxuXHJcbiAgc3dpdGNoIChrdHkpIHtcclxuICAgIGNhc2UgJ0VDJzoge1xyXG4gICAgICBsZXQgYWxncyA9IFtdO1xyXG5cclxuICAgICAgaWYgKHVzZSA9PT0gJ2VuYycgfHwgdXNlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBhbGdzID0gYWxncy5jb25jYXQoWydFQ0RILUVTJywgJ0VDREgtRVMrQTEyOEtXJywgJ0VDREgtRVMrQTE5MktXJywgJ0VDREgtRVMrQTI1NktXJ10pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodXNlID09PSAnc2lnJyB8fCB1c2UgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHN3aXRjaCAoY3J2KSB7XHJcbiAgICAgICAgICBjYXNlICdQLTI1Nic6XHJcbiAgICAgICAgICBjYXNlICdQLTM4NCc6XHJcbiAgICAgICAgICAgIGFsZ3MgPSBhbGdzLmNvbmNhdChbYEVTJHtjcnYuc2xpY2UoLTMpfWAucmVwbGFjZSgnMjEnLCAnMTInKV0pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ1AtNTIxJzpcclxuICAgICAgICAgICAgYWxncyA9IGFsZ3MuY29uY2F0KFsnRVM1MTInXSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnc2VjcDI1NmsxJzpcclxuICAgICAgICAgICAgaWYgKGpvc2UuY3J5cHRvUnVudGltZSA9PT0gJ25vZGU6Y3J5cHRvJykge1xyXG4gICAgICAgICAgICAgIGFsZ3MgPSBhbGdzLmNvbmNhdChbJ0VTMjU2SyddKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuZXcgU2V0KGFsZ3MpO1xyXG4gICAgfVxyXG4gICAgY2FzZSAnT0tQJzoge1xyXG4gICAgICByZXR1cm4gbmV3IFNldChbJ0VDREgtRVMnLCAnRUNESC1FUytBMTI4S1cnLCAnRUNESC1FUytBMTkyS1cnLCAnRUNESC1FUytBMjU2S1cnXSk7XHJcbiAgICB9XHJcbiAgICBjYXNlICdSU0EnOiB7XHJcbiAgICAgIGxldCBhbGdzID0gW107XHJcblxyXG4gICAgICBpZiAodXNlID09PSAnZW5jJyB8fCB1c2UgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGFsZ3MgPSBhbGdzLmNvbmNhdChbJ1JTQS1PQUVQJywgJ1JTQS1PQUVQLTI1NicsICdSU0EtT0FFUC0zODQnLCAnUlNBLU9BRVAtNTEyJ10pO1xyXG4gICAgICAgIGlmIChqb3NlLmNyeXB0b1J1bnRpbWUgPT09ICdub2RlOmNyeXB0bycpIHtcclxuICAgICAgICAgIGFsZ3MgPSBhbGdzLmNvbmNhdChbJ1JTQTFfNSddKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh1c2UgPT09ICdzaWcnIHx8IHVzZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgYWxncyA9IGFsZ3MuY29uY2F0KFsnUFMyNTYnLCAnUFMzODQnLCAnUFM1MTInLCAnUlMyNTYnLCAnUlMzODQnLCAnUlM1MTInXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuZXcgU2V0KGFsZ3MpO1xyXG4gICAgfVxyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZScpO1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBLZXlTdG9yZSB7XHJcbiAgI2tleXM7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGksIGtleXMpIHtcclxuICAgIGlmIChpICE9PSBpbnRlcm5hbCkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNvbnN0cnVjdG9yIGNhbGwnKTtcclxuICAgIHRoaXMuI2tleXMgPSBrZXlzO1xyXG4gIH1cclxuXHJcbiAgdG9KV0tTKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAga2V5czogdGhpcy5tYXAoKHsgandrOiB7IGQsIHAsIHEsIGRwLCBkcSwgcWksIC4uLmp3ayB9IH0pID0+IGp3ayksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgYWxsKHsgYWxnLCBraWQsIHVzZSB9ID0ge30pIHtcclxuICAgIGlmICghdXNlIHx8ICFhbGcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qga3R5ID0gZ2V0S3R5RnJvbUFsZyhhbGcpO1xyXG5cclxuICAgIGNvbnN0IHNlYXJjaCA9IHsgYWxnLCB1c2UgfTtcclxuICAgIHJldHVybiB0aGlzLmZpbHRlcigoa2V5KSA9PiB7XHJcbiAgICAgIGxldCBjYW5kaWRhdGUgPSB0cnVlO1xyXG5cclxuICAgICAgaWYgKGNhbmRpZGF0ZSAmJiBrdHkgIT09IHVuZGVmaW5lZCAmJiBrZXkuandrLmt0eSAhPT0ga3R5KSB7XHJcbiAgICAgICAgY2FuZGlkYXRlID0gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjYW5kaWRhdGUgJiYga2lkICE9PSB1bmRlZmluZWQgJiYga2V5Lmp3ay5raWQgIT09IGtpZCkge1xyXG4gICAgICAgIGNhbmRpZGF0ZSA9IGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY2FuZGlkYXRlICYmIHVzZSAhPT0gdW5kZWZpbmVkICYmIGtleS5qd2sudXNlICE9PSB1bmRlZmluZWQgJiYga2V5Lmp3ay51c2UgIT09IHVzZSkge1xyXG4gICAgICAgIGNhbmRpZGF0ZSA9IGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY2FuZGlkYXRlICYmIGtleS5qd2suYWxnICYmIGtleS5qd2suYWxnICE9PSBhbGcpIHtcclxuICAgICAgICBjYW5kaWRhdGUgPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIGlmICgha2V5LmFsZ29yaXRobXMuaGFzKGFsZykpIHtcclxuICAgICAgICBjYW5kaWRhdGUgPSBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcclxuICAgIH0pLnNvcnQoKGZpcnN0LCBzZWNvbmQpID0+IGtleXNjb3JlKHNlY29uZCwgc2VhcmNoKSAtIGtleXNjb3JlKGZpcnN0LCBzZWFyY2gpKTtcclxuICB9XHJcblxyXG4gIGdldCguLi5hcmdzKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hbGwoLi4uYXJncylbMF07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgYXN5bmMgZnJvbUpXS1MoandrcywgeyBvbmx5UHVibGljID0gZmFsc2UsIG9ubHlQcml2YXRlID0gZmFsc2UgfSA9IHt9KSB7XHJcbiAgICBpZiAoXHJcbiAgICAgICFpc1BsYWluT2JqZWN0KGp3a3MpIHx8XHJcbiAgICAgICFBcnJheS5pc0FycmF5KGp3a3Mua2V5cykgfHxcclxuICAgICAgandrcy5rZXlzLnNvbWUoKGspID0+ICFpc1BsYWluT2JqZWN0KGspIHx8ICEoJ2t0eScgaW4gaykpXHJcbiAgICApIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignandrcyBtdXN0IGJlIGEgSlNPTiBXZWIgS2V5IFNldCBmb3JtYXR0ZWQgb2JqZWN0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qga2V5cyA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IGp3ayBvZiBqd2tzLmtleXMpIHtcclxuICAgICAgandrID0gY2xvbmUoandrKTtcclxuICAgICAgY29uc3QgeyBrdHksIGtpZCwgY3J2IH0gPSBqd2s7XHJcblxyXG4gICAgICBsZXQgeyBhbGcsIHVzZSB9ID0gandrO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBrdHkgIT09ICdzdHJpbmcnIHx8ICFrdHkpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHVzZSAhPT0gdW5kZWZpbmVkICYmIHVzZSAhPT0gJ3NpZycgJiYgdXNlICE9PSAnZW5jJykge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodHlwZW9mIGFsZyAhPT0gJ3N0cmluZycgJiYgYWxnICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHR5cGVvZiBraWQgIT09ICdzdHJpbmcnICYmIGtpZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChrdHkgPT09ICdFQycgJiYgdXNlID09PSAnc2lnJykge1xyXG4gICAgICAgIHN3aXRjaCAoY3J2KSB7XHJcbiAgICAgICAgICBjYXNlICdQLTI1Nic6XHJcbiAgICAgICAgICAgIGFsZyA9ICdFUzI1Nic7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnUC0zODQnOlxyXG4gICAgICAgICAgICBhbGcgPSAnRVMzODQnO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ1AtNTIxJzpcclxuICAgICAgICAgICAgYWxnID0gJ0VTNTEyJztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjcnYgPT09ICdzZWNwMjU2azEnKSB7XHJcbiAgICAgICAgdXNlID0gJ3NpZyc7XHJcbiAgICAgICAgYWxnID0gJ0VTMjU2Syc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChrdHkgPT09ICdPS1AnKSB7XHJcbiAgICAgICAgc3dpdGNoIChjcnYpIHtcclxuICAgICAgICAgIGNhc2UgJ0VkMjU1MTknOlxyXG4gICAgICAgICAgY2FzZSAnRWQ0NDgnOlxyXG4gICAgICAgICAgICB1c2UgPSAnc2lnJztcclxuICAgICAgICAgICAgYWxnID0gJ0VkRFNBJztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdYMjU1MTknOlxyXG4gICAgICAgICAgY2FzZSAnWDQ0OCc6XHJcbiAgICAgICAgICAgIHVzZSA9ICdlbmMnO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGFsZyAmJiAhdXNlKSB7XHJcbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XHJcbiAgICAgICAgICBjYXNlIGFsZy5zdGFydHNXaXRoKCdFQ0RIJyk6XHJcbiAgICAgICAgICAgIHVzZSA9ICdlbmMnO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgYWxnLnN0YXJ0c1dpdGgoJ1JTQScpOlxyXG4gICAgICAgICAgICB1c2UgPSAnZW5jJztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChvbmx5UHJpdmF0ZSAmJiAoandrLmt0eSA9PT0gJ29jdCcgfHwgIWp3ay5kKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignandrcyBtdXN0IG9ubHkgY29udGFpbiBwcml2YXRlIGtleXMnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG9ubHlQdWJsaWMgJiYgKGp3ay5kIHx8IGp3ay5rKSkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBrZXlzLnB1c2goe1xyXG4gICAgICAgIGp3azogeyAuLi5qd2ssIGFsZywgdXNlIH0sXHJcbiAgICAgICAgYXN5bmMga2V5T2JqZWN0KGFsZykge1xyXG4gICAgICAgICAgaWYgKHRoaXNbYWxnXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1thbGddO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbnN0IGtleU9iamVjdCA9IGF3YWl0IGpvc2UuaW1wb3J0SldLKHRoaXMuandrLCBhbGcpO1xyXG4gICAgICAgICAgdGhpc1thbGddID0ga2V5T2JqZWN0O1xyXG4gICAgICAgICAgcmV0dXJuIGtleU9iamVjdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBhbGdvcml0aG1zKCkge1xyXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdhbGdvcml0aG1zJywge1xyXG4gICAgICAgICAgICB2YWx1ZTogZ2V0QWxnb3JpdGhtcyh0aGlzLmp3ay51c2UsIHRoaXMuandrLmFsZywgdGhpcy5qd2sua3R5LCB0aGlzLmp3ay5jcnYpLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5hbGdvcml0aG1zO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgdGhpcyhpbnRlcm5hbCwga2V5cyk7XHJcbiAgfVxyXG5cclxuICBmaWx0ZXIoLi4uYXJncykge1xyXG4gICAgcmV0dXJuIHRoaXMuI2tleXMuZmlsdGVyKC4uLmFyZ3MpO1xyXG4gIH1cclxuXHJcbiAgZmluZCguLi5hcmdzKSB7XHJcbiAgICByZXR1cm4gdGhpcy4ja2V5cy5maW5kKC4uLmFyZ3MpO1xyXG4gIH1cclxuXHJcbiAgZXZlcnkoLi4uYXJncykge1xyXG4gICAgcmV0dXJuIHRoaXMuI2tleXMuZXZlcnkoLi4uYXJncyk7XHJcbiAgfVxyXG5cclxuICBzb21lKC4uLmFyZ3MpIHtcclxuICAgIHJldHVybiB0aGlzLiNrZXlzLnNvbWUoLi4uYXJncyk7XHJcbiAgfVxyXG5cclxuICBtYXAoLi4uYXJncykge1xyXG4gICAgcmV0dXJuIHRoaXMuI2tleXMubWFwKC4uLmFyZ3MpO1xyXG4gIH1cclxuXHJcbiAgZm9yRWFjaCguLi5hcmdzKSB7XHJcbiAgICByZXR1cm4gdGhpcy4ja2V5cy5mb3JFYWNoKC4uLmFyZ3MpO1xyXG4gIH1cclxuXHJcbiAgcmVkdWNlKC4uLmFyZ3MpIHtcclxuICAgIHJldHVybiB0aGlzLiNrZXlzLnJlZHVjZSguLi5hcmdzKTtcclxuICB9XHJcblxyXG4gIHNvcnQoLi4uYXJncykge1xyXG4gICAgcmV0dXJuIHRoaXMuI2tleXMuc29ydCguLi5hcmdzKTtcclxuICB9XHJcblxyXG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcclxuICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMuI2tleXMpIHtcclxuICAgICAgeWllbGQga2V5O1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuIl0sIm5hbWVzIjpbImpvc2UiLCJyZXF1aXJlIiwiY2xvbmUiLCJpc1BsYWluT2JqZWN0IiwiaW50ZXJuYWwiLCJTeW1ib2wiLCJmYXV4QWxnIiwia3R5IiwidW5kZWZpbmVkIiwia2V5c2NvcmUiLCJrZXkiLCJhbGciLCJ1c2UiLCJzY29yZSIsImdldEt0eUZyb21BbGciLCJzbGljZSIsImdldEFsZ29yaXRobXMiLCJjcnYiLCJTZXQiLCJhbGdzIiwiY29uY2F0IiwicmVwbGFjZSIsImNyeXB0b1J1bnRpbWUiLCJFcnJvciIsIm1vZHVsZSIsImV4cG9ydHMiLCJLZXlTdG9yZSIsImtleXMiLCJjb25zdHJ1Y3RvciIsImkiLCJ0b0pXS1MiLCJtYXAiLCJqd2siLCJkIiwicCIsInEiLCJkcCIsImRxIiwicWkiLCJhbGwiLCJraWQiLCJzZWFyY2giLCJmaWx0ZXIiLCJjYW5kaWRhdGUiLCJhbGdvcml0aG1zIiwiaGFzIiwic29ydCIsImZpcnN0Iiwic2Vjb25kIiwiZ2V0IiwiYXJncyIsImZyb21KV0tTIiwiandrcyIsIm9ubHlQdWJsaWMiLCJvbmx5UHJpdmF0ZSIsIkFycmF5IiwiaXNBcnJheSIsInNvbWUiLCJrIiwiVHlwZUVycm9yIiwic3RhcnRzV2l0aCIsInB1c2giLCJrZXlPYmplY3QiLCJpbXBvcnRKV0siLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsImZpbmQiLCJldmVyeSIsImZvckVhY2giLCJyZWR1Y2UiLCJpdGVyYXRvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/keystore.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/merge.js":
/*!*********************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/merge.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const isPlainObject = __webpack_require__(/*! ./is_plain_object */ \"(rsc)/./node_modules/openid-client/lib/helpers/is_plain_object.js\");\nfunction merge(target, ...sources) {\n    for (const source of sources){\n        if (!isPlainObject(source)) {\n            continue;\n        }\n        for (const [key, value] of Object.entries(source)){\n            /* istanbul ignore if */ if (key === \"__proto__\" || key === \"constructor\") {\n                continue;\n            }\n            if (isPlainObject(target[key]) && isPlainObject(value)) {\n                target[key] = merge(target[key], value);\n            } else if (typeof value !== \"undefined\") {\n                target[key] = value;\n            }\n        }\n    }\n    return target;\n}\nmodule.exports = merge;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9tZXJnZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxNQUFNQSxnQkFBZ0JDLG1CQUFPQSxDQUFDO0FBRTlCLFNBQVNDLE1BQU1DLE1BQU0sRUFBRSxHQUFHQyxPQUFPO0lBQy9CLEtBQUssTUFBTUMsVUFBVUQsUUFBUztRQUM1QixJQUFJLENBQUNKLGNBQWNLLFNBQVM7WUFDMUI7UUFDRjtRQUNBLEtBQUssTUFBTSxDQUFDQyxLQUFLQyxNQUFNLElBQUlDLE9BQU9DLE9BQU8sQ0FBQ0osUUFBUztZQUNqRCxzQkFBc0IsR0FDdEIsSUFBSUMsUUFBUSxlQUFlQSxRQUFRLGVBQWU7Z0JBQ2hEO1lBQ0Y7WUFDQSxJQUFJTixjQUFjRyxNQUFNLENBQUNHLElBQUksS0FBS04sY0FBY08sUUFBUTtnQkFDdERKLE1BQU0sQ0FBQ0csSUFBSSxHQUFHSixNQUFNQyxNQUFNLENBQUNHLElBQUksRUFBRUM7WUFDbkMsT0FBTyxJQUFJLE9BQU9BLFVBQVUsYUFBYTtnQkFDdkNKLE1BQU0sQ0FBQ0csSUFBSSxHQUFHQztZQUNoQjtRQUNGO0lBQ0Y7SUFFQSxPQUFPSjtBQUNUO0FBRUFPLE9BQU9DLE9BQU8sR0FBR1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL21lcmdlLmpzP2E1OGYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaXNfcGxhaW5fb2JqZWN0Jyk7XHJcblxyXG5mdW5jdGlvbiBtZXJnZSh0YXJnZXQsIC4uLnNvdXJjZXMpIHtcclxuICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XHJcbiAgICBpZiAoIWlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHNvdXJjZSkpIHtcclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nIHx8IGtleSA9PT0gJ2NvbnN0cnVjdG9yJykge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldFtrZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgIHRhcmdldFtrZXldID0gbWVyZ2UodGFyZ2V0W2tleV0sIHZhbHVlKTtcclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRhcmdldDtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZTtcclxuIl0sIm5hbWVzIjpbImlzUGxhaW5PYmplY3QiLCJyZXF1aXJlIiwibWVyZ2UiLCJ0YXJnZXQiLCJzb3VyY2VzIiwic291cmNlIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/merge.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/pick.js":
/*!********************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/pick.js ***!
  \********************************************************/
/***/ ((module) => {

eval("module.exports = function pick(object, ...paths) {\n    const obj = {};\n    for (const path of paths){\n        if (object[path] !== undefined) {\n            obj[path] = object[path];\n        }\n    }\n    return obj;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL3BpY2suanM/Njg2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBpY2sob2JqZWN0LCAuLi5wYXRocykge1xyXG4gIGNvbnN0IG9iaiA9IHt9O1xyXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xyXG4gICAgaWYgKG9iamVjdFtwYXRoXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIG9ialtwYXRoXSA9IG9iamVjdFtwYXRoXTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufTtcclxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJwaWNrIiwib2JqZWN0IiwicGF0aHMiLCJvYmoiLCJwYXRoIiwidW5kZWZpbmVkIl0sIm1hcHBpbmdzIjoiQUFBQUEsT0FBT0MsT0FBTyxHQUFHLFNBQVNDLEtBQUtDLE1BQU0sRUFBRSxHQUFHQyxLQUFLO0lBQzdDLE1BQU1DLE1BQU0sQ0FBQztJQUNiLEtBQUssTUFBTUMsUUFBUUYsTUFBTztRQUN4QixJQUFJRCxNQUFNLENBQUNHLEtBQUssS0FBS0MsV0FBVztZQUM5QkYsR0FBRyxDQUFDQyxLQUFLLEdBQUdILE1BQU0sQ0FBQ0csS0FBSztRQUMxQjtJQUNGO0lBQ0EsT0FBT0Q7QUFDVCIsImZpbGUiOiIocnNjKS8uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL3BpY2suanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/pick.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/process_response.js":
/*!********************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/process_response.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { STATUS_CODES } = __webpack_require__(/*! http */ \"http\");\nconst { format } = __webpack_require__(/*! util */ \"util\");\nconst { OPError } = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/openid-client/lib/errors.js\");\nconst parseWwwAuthenticate = __webpack_require__(/*! ./www_authenticate_parser */ \"(rsc)/./node_modules/openid-client/lib/helpers/www_authenticate_parser.js\");\nconst throwAuthenticateErrors = (response)=>{\n    const params = parseWwwAuthenticate(response.headers[\"www-authenticate\"]);\n    if (params.error) {\n        throw new OPError(params, response);\n    }\n};\nconst isStandardBodyError = (response)=>{\n    let result = false;\n    try {\n        let jsonbody;\n        if (typeof response.body !== \"object\" || Buffer.isBuffer(response.body)) {\n            jsonbody = JSON.parse(response.body);\n        } else {\n            jsonbody = response.body;\n        }\n        result = typeof jsonbody.error === \"string\" && jsonbody.error.length;\n        if (result) Object.defineProperty(response, \"body\", {\n            value: jsonbody,\n            configurable: true\n        });\n    } catch (err) {}\n    return result;\n};\nfunction processResponse(response, { statusCode = 200, body = true, bearer = false } = {}) {\n    if (response.statusCode !== statusCode) {\n        if (bearer) {\n            throwAuthenticateErrors(response);\n        }\n        if (isStandardBodyError(response)) {\n            throw new OPError(response.body, response);\n        }\n        throw new OPError({\n            error: format(\"expected %i %s, got: %i %s\", statusCode, STATUS_CODES[statusCode], response.statusCode, STATUS_CODES[response.statusCode])\n        }, response);\n    }\n    if (body && !response.body) {\n        throw new OPError({\n            error: format(\"expected %i %s with body but no body was returned\", statusCode, STATUS_CODES[statusCode])\n        }, response);\n    }\n    return response.body;\n}\nmodule.exports = processResponse;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9wcm9jZXNzX3Jlc3BvbnNlLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU0sRUFBRUEsWUFBWSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ2pDLE1BQU0sRUFBRUMsTUFBTSxFQUFFLEdBQUdELG1CQUFPQSxDQUFDO0FBRTNCLE1BQU0sRUFBRUUsT0FBTyxFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBQzVCLE1BQU1HLHVCQUF1QkgsbUJBQU9BLENBQUM7QUFFckMsTUFBTUksMEJBQTBCLENBQUNDO0lBQy9CLE1BQU1DLFNBQVNILHFCQUFxQkUsU0FBU0UsT0FBTyxDQUFDLG1CQUFtQjtJQUV4RSxJQUFJRCxPQUFPRSxLQUFLLEVBQUU7UUFDaEIsTUFBTSxJQUFJTixRQUFRSSxRQUFRRDtJQUM1QjtBQUNGO0FBRUEsTUFBTUksc0JBQXNCLENBQUNKO0lBQzNCLElBQUlLLFNBQVM7SUFDYixJQUFJO1FBQ0YsSUFBSUM7UUFDSixJQUFJLE9BQU9OLFNBQVNPLElBQUksS0FBSyxZQUFZQyxPQUFPQyxRQUFRLENBQUNULFNBQVNPLElBQUksR0FBRztZQUN2RUQsV0FBV0ksS0FBS0MsS0FBSyxDQUFDWCxTQUFTTyxJQUFJO1FBQ3JDLE9BQU87WUFDTEQsV0FBV04sU0FBU08sSUFBSTtRQUMxQjtRQUNBRixTQUFTLE9BQU9DLFNBQVNILEtBQUssS0FBSyxZQUFZRyxTQUFTSCxLQUFLLENBQUNTLE1BQU07UUFDcEUsSUFBSVAsUUFBUVEsT0FBT0MsY0FBYyxDQUFDZCxVQUFVLFFBQVE7WUFBRWUsT0FBT1Q7WUFBVVUsY0FBYztRQUFLO0lBQzVGLEVBQUUsT0FBT0MsS0FBSyxDQUFDO0lBRWYsT0FBT1o7QUFDVDtBQUVBLFNBQVNhLGdCQUFnQmxCLFFBQVEsRUFBRSxFQUFFbUIsYUFBYSxHQUFHLEVBQUVaLE9BQU8sSUFBSSxFQUFFYSxTQUFTLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztJQUN2RixJQUFJcEIsU0FBU21CLFVBQVUsS0FBS0EsWUFBWTtRQUN0QyxJQUFJQyxRQUFRO1lBQ1ZyQix3QkFBd0JDO1FBQzFCO1FBRUEsSUFBSUksb0JBQW9CSixXQUFXO1lBQ2pDLE1BQU0sSUFBSUgsUUFBUUcsU0FBU08sSUFBSSxFQUFFUDtRQUNuQztRQUVBLE1BQU0sSUFBSUgsUUFDUjtZQUNFTSxPQUFPUCxPQUNMLDhCQUNBdUIsWUFDQXpCLFlBQVksQ0FBQ3lCLFdBQVcsRUFDeEJuQixTQUFTbUIsVUFBVSxFQUNuQnpCLFlBQVksQ0FBQ00sU0FBU21CLFVBQVUsQ0FBQztRQUVyQyxHQUNBbkI7SUFFSjtJQUVBLElBQUlPLFFBQVEsQ0FBQ1AsU0FBU08sSUFBSSxFQUFFO1FBQzFCLE1BQU0sSUFBSVYsUUFDUjtZQUNFTSxPQUFPUCxPQUNMLHFEQUNBdUIsWUFDQXpCLFlBQVksQ0FBQ3lCLFdBQVc7UUFFNUIsR0FDQW5CO0lBRUo7SUFFQSxPQUFPQSxTQUFTTyxJQUFJO0FBQ3RCO0FBRUFjLE9BQU9DLE9BQU8sR0FBR0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL3Byb2Nlc3NfcmVzcG9uc2UuanM/N2RlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IFNUQVRVU19DT0RFUyB9ID0gcmVxdWlyZSgnaHR0cCcpO1xyXG5jb25zdCB7IGZvcm1hdCB9ID0gcmVxdWlyZSgndXRpbCcpO1xyXG5cclxuY29uc3QgeyBPUEVycm9yIH0gPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcclxuY29uc3QgcGFyc2VXd3dBdXRoZW50aWNhdGUgPSByZXF1aXJlKCcuL3d3d19hdXRoZW50aWNhdGVfcGFyc2VyJyk7XHJcblxyXG5jb25zdCB0aHJvd0F1dGhlbnRpY2F0ZUVycm9ycyA9IChyZXNwb25zZSkgPT4ge1xyXG4gIGNvbnN0IHBhcmFtcyA9IHBhcnNlV3d3QXV0aGVudGljYXRlKHJlc3BvbnNlLmhlYWRlcnNbJ3d3dy1hdXRoZW50aWNhdGUnXSk7XHJcblxyXG4gIGlmIChwYXJhbXMuZXJyb3IpIHtcclxuICAgIHRocm93IG5ldyBPUEVycm9yKHBhcmFtcywgcmVzcG9uc2UpO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGlzU3RhbmRhcmRCb2R5RXJyb3IgPSAocmVzcG9uc2UpID0+IHtcclxuICBsZXQgcmVzdWx0ID0gZmFsc2U7XHJcbiAgdHJ5IHtcclxuICAgIGxldCBqc29uYm9keTtcclxuICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuYm9keSAhPT0gJ29iamVjdCcgfHwgQnVmZmVyLmlzQnVmZmVyKHJlc3BvbnNlLmJvZHkpKSB7XHJcbiAgICAgIGpzb25ib2R5ID0gSlNPTi5wYXJzZShyZXNwb25zZS5ib2R5KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGpzb25ib2R5ID0gcmVzcG9uc2UuYm9keTtcclxuICAgIH1cclxuICAgIHJlc3VsdCA9IHR5cGVvZiBqc29uYm9keS5lcnJvciA9PT0gJ3N0cmluZycgJiYganNvbmJvZHkuZXJyb3IubGVuZ3RoO1xyXG4gICAgaWYgKHJlc3VsdCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3BvbnNlLCAnYm9keScsIHsgdmFsdWU6IGpzb25ib2R5LCBjb25maWd1cmFibGU6IHRydWUgfSk7XHJcbiAgfSBjYXRjaCAoZXJyKSB7fVxyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlLCB7IHN0YXR1c0NvZGUgPSAyMDAsIGJvZHkgPSB0cnVlLCBiZWFyZXIgPSBmYWxzZSB9ID0ge30pIHtcclxuICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSAhPT0gc3RhdHVzQ29kZSkge1xyXG4gICAgaWYgKGJlYXJlcikge1xyXG4gICAgICB0aHJvd0F1dGhlbnRpY2F0ZUVycm9ycyhyZXNwb25zZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzU3RhbmRhcmRCb2R5RXJyb3IocmVzcG9uc2UpKSB7XHJcbiAgICAgIHRocm93IG5ldyBPUEVycm9yKHJlc3BvbnNlLmJvZHksIHJlc3BvbnNlKTtcclxuICAgIH1cclxuXHJcbiAgICB0aHJvdyBuZXcgT1BFcnJvcihcclxuICAgICAge1xyXG4gICAgICAgIGVycm9yOiBmb3JtYXQoXHJcbiAgICAgICAgICAnZXhwZWN0ZWQgJWkgJXMsIGdvdDogJWkgJXMnLFxyXG4gICAgICAgICAgc3RhdHVzQ29kZSxcclxuICAgICAgICAgIFNUQVRVU19DT0RFU1tzdGF0dXNDb2RlXSxcclxuICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c0NvZGUsXHJcbiAgICAgICAgICBTVEFUVVNfQ09ERVNbcmVzcG9uc2Uuc3RhdHVzQ29kZV0sXHJcbiAgICAgICAgKSxcclxuICAgICAgfSxcclxuICAgICAgcmVzcG9uc2UsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgaWYgKGJvZHkgJiYgIXJlc3BvbnNlLmJvZHkpIHtcclxuICAgIHRocm93IG5ldyBPUEVycm9yKFxyXG4gICAgICB7XHJcbiAgICAgICAgZXJyb3I6IGZvcm1hdChcclxuICAgICAgICAgICdleHBlY3RlZCAlaSAlcyB3aXRoIGJvZHkgYnV0IG5vIGJvZHkgd2FzIHJldHVybmVkJyxcclxuICAgICAgICAgIHN0YXR1c0NvZGUsXHJcbiAgICAgICAgICBTVEFUVVNfQ09ERVNbc3RhdHVzQ29kZV0sXHJcbiAgICAgICAgKSxcclxuICAgICAgfSxcclxuICAgICAgcmVzcG9uc2UsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlc3BvbnNlLmJvZHk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcHJvY2Vzc1Jlc3BvbnNlO1xyXG4iXSwibmFtZXMiOlsiU1RBVFVTX0NPREVTIiwicmVxdWlyZSIsImZvcm1hdCIsIk9QRXJyb3IiLCJwYXJzZVd3d0F1dGhlbnRpY2F0ZSIsInRocm93QXV0aGVudGljYXRlRXJyb3JzIiwicmVzcG9uc2UiLCJwYXJhbXMiLCJoZWFkZXJzIiwiZXJyb3IiLCJpc1N0YW5kYXJkQm9keUVycm9yIiwicmVzdWx0IiwianNvbmJvZHkiLCJib2R5IiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJKU09OIiwicGFyc2UiLCJsZW5ndGgiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwiZXJyIiwicHJvY2Vzc1Jlc3BvbnNlIiwic3RhdHVzQ29kZSIsImJlYXJlciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/process_response.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/request.js":
/*!***********************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/request.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const assert = __webpack_require__(/*! assert */ \"assert\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst { once } = __webpack_require__(/*! events */ \"events\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\nconst LRU = __webpack_require__(/*! lru-cache */ \"(rsc)/./node_modules/lru-cache/index.js\");\nconst pkg = __webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/openid-client/package.json\");\nconst { RPError } = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/openid-client/lib/errors.js\");\nconst pick = __webpack_require__(/*! ./pick */ \"(rsc)/./node_modules/openid-client/lib/helpers/pick.js\");\nconst { deep: defaultsDeep } = __webpack_require__(/*! ./defaults */ \"(rsc)/./node_modules/openid-client/lib/helpers/defaults.js\");\nconst { HTTP_OPTIONS } = __webpack_require__(/*! ./consts */ \"(rsc)/./node_modules/openid-client/lib/helpers/consts.js\");\nlet DEFAULT_HTTP_OPTIONS;\nconst NQCHAR = /^[\\x21\\x23-\\x5B\\x5D-\\x7E]+$/;\nconst allowed = [\n    \"agent\",\n    \"ca\",\n    \"cert\",\n    \"crl\",\n    \"headers\",\n    \"key\",\n    \"lookup\",\n    \"passphrase\",\n    \"pfx\",\n    \"timeout\"\n];\nconst setDefaults = (props, options)=>{\n    DEFAULT_HTTP_OPTIONS = defaultsDeep({}, props.length ? pick(options, ...props) : options, DEFAULT_HTTP_OPTIONS);\n};\nsetDefaults([], {\n    headers: {\n        \"User-Agent\": `${pkg.name}/${pkg.version} (${pkg.homepage})`,\n        \"Accept-Encoding\": \"identity\"\n    },\n    timeout: 3500\n});\nfunction send(req, body, contentType) {\n    if (contentType) {\n        req.removeHeader(\"content-type\");\n        req.setHeader(\"content-type\", contentType);\n    }\n    if (body) {\n        req.removeHeader(\"content-length\");\n        req.setHeader(\"content-length\", Buffer.byteLength(body));\n        req.write(body);\n    }\n    req.end();\n}\nconst nonces = new LRU({\n    max: 100\n});\nmodule.exports = async function request(options, { accessToken, mTLS = false, DPoP } = {}) {\n    let url;\n    try {\n        url = new URL(options.url);\n        delete options.url;\n        assert(/^(https?:)$/.test(url.protocol));\n    } catch (err) {\n        throw new TypeError(\"only valid absolute URLs can be requested\");\n    }\n    const optsFn = this[HTTP_OPTIONS];\n    let opts = options;\n    const nonceKey = `${url.origin}${url.pathname}`;\n    if (DPoP && \"dpopProof\" in this) {\n        opts.headers = opts.headers || {};\n        opts.headers.DPoP = await this.dpopProof({\n            htu: `${url.origin}${url.pathname}`,\n            htm: options.method,\n            nonce: nonces.get(nonceKey)\n        }, DPoP, accessToken);\n    }\n    let userOptions;\n    if (optsFn) {\n        userOptions = pick(optsFn.call(this, url, defaultsDeep({}, opts, DEFAULT_HTTP_OPTIONS)), ...allowed);\n    }\n    opts = defaultsDeep({}, userOptions, opts, DEFAULT_HTTP_OPTIONS);\n    if (mTLS && !opts.pfx && !(opts.key && opts.cert)) {\n        throw new TypeError(\"mutual-TLS certificate and key not set\");\n    }\n    if (opts.searchParams) {\n        for (const [key, value] of Object.entries(opts.searchParams)){\n            url.searchParams.delete(key);\n            url.searchParams.set(key, value);\n        }\n    }\n    let responseType;\n    let form;\n    let json;\n    let body;\n    ({ form, responseType, json, body, ...opts } = opts);\n    for (const [key, value] of Object.entries(opts.headers || {})){\n        if (value === undefined) {\n            delete opts.headers[key];\n        }\n    }\n    let response;\n    const req = (url.protocol === \"https:\" ? https.request : http.request)(url.href, opts);\n    return (async ()=>{\n        if (json) {\n            send(req, JSON.stringify(json), \"application/json\");\n        } else if (form) {\n            send(req, querystring.stringify(form), \"application/x-www-form-urlencoded\");\n        } else if (body) {\n            send(req, body);\n        } else {\n            send(req);\n        }\n        [response] = await Promise.race([\n            once(req, \"response\"),\n            once(req, \"timeout\")\n        ]);\n        // timeout reached\n        if (!response) {\n            req.destroy();\n            throw new RPError(`outgoing request timed out after ${opts.timeout}ms`);\n        }\n        const parts = [];\n        for await (const part of response){\n            parts.push(part);\n        }\n        if (parts.length) {\n            switch(responseType){\n                case \"json\":\n                    {\n                        Object.defineProperty(response, \"body\", {\n                            get () {\n                                let value = Buffer.concat(parts);\n                                try {\n                                    value = JSON.parse(value);\n                                } catch (err) {\n                                    Object.defineProperty(err, \"response\", {\n                                        value: response\n                                    });\n                                    throw err;\n                                } finally{\n                                    Object.defineProperty(response, \"body\", {\n                                        value,\n                                        configurable: true\n                                    });\n                                }\n                                return value;\n                            },\n                            configurable: true\n                        });\n                        break;\n                    }\n                case undefined:\n                case \"buffer\":\n                    {\n                        Object.defineProperty(response, \"body\", {\n                            get () {\n                                const value = Buffer.concat(parts);\n                                Object.defineProperty(response, \"body\", {\n                                    value,\n                                    configurable: true\n                                });\n                                return value;\n                            },\n                            configurable: true\n                        });\n                        break;\n                    }\n                default:\n                    throw new TypeError(\"unsupported responseType request option\");\n            }\n        }\n        return response;\n    })().catch((err)=>{\n        if (response) Object.defineProperty(err, \"response\", {\n            value: response\n        });\n        throw err;\n    }).finally(()=>{\n        const dpopNonce = response && response.headers[\"dpop-nonce\"];\n        if (dpopNonce && NQCHAR.test(dpopNonce)) {\n            nonces.set(nonceKey, dpopNonce);\n        }\n    });\n};\nmodule.exports.setDefaults = setDefaults.bind(undefined, allowed);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9yZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDO0FBQzVCLE1BQU1FLE9BQU9GLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1HLFFBQVFILG1CQUFPQSxDQUFDO0FBQ3RCLE1BQU0sRUFBRUksSUFBSSxFQUFFLEdBQUdKLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU0sRUFBRUssR0FBRyxFQUFFLEdBQUdMLG1CQUFPQSxDQUFDO0FBRXhCLE1BQU1NLE1BQU1OLG1CQUFPQSxDQUFDO0FBRXBCLE1BQU1PLE1BQU1QLG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU0sRUFBRVEsT0FBTyxFQUFFLEdBQUdSLG1CQUFPQSxDQUFDO0FBRTVCLE1BQU1TLE9BQU9ULG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRVUsTUFBTUMsWUFBWSxFQUFFLEdBQUdYLG1CQUFPQSxDQUFDO0FBQ3ZDLE1BQU0sRUFBRVksWUFBWSxFQUFFLEdBQUdaLG1CQUFPQSxDQUFDO0FBRWpDLElBQUlhO0FBQ0osTUFBTUMsU0FBUztBQUVmLE1BQU1DLFVBQVU7SUFDZDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsTUFBTUMsY0FBYyxDQUFDQyxPQUFPQztJQUMxQkwsdUJBQXVCRixhQUNyQixDQUFDLEdBQ0RNLE1BQU1FLE1BQU0sR0FBR1YsS0FBS1MsWUFBWUQsU0FBU0MsU0FDekNMO0FBRUo7QUFFQUcsWUFBWSxFQUFFLEVBQUU7SUFDZEksU0FBUztRQUNQLGNBQWMsQ0FBQyxFQUFFYixJQUFJYyxJQUFJLENBQUMsQ0FBQyxFQUFFZCxJQUFJZSxPQUFPLENBQUMsRUFBRSxFQUFFZixJQUFJZ0IsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUM1RCxtQkFBbUI7SUFDckI7SUFDQUMsU0FB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d0NBQU9zQixjQUFjO29DQUFLO2dDQUN0RTtnQ0FDQSxPQUFPdEI7NEJBQ1Q7NEJBQ0FzQixjQUFjO3dCQUNoQjt3QkFDQTtvQkFDRjtnQkFDQSxLQUFLZDtnQkFDTCxLQUFLO29CQUFVO3dCQUNiUCxPQUFPa0IsY0FBYyxDQUFDVixVQUFVLFFBQVE7NEJBQ3RDaEI7Z0NBQ0UsTUFBTU8sUUFBUWxDLE9BQU9zRCxNQUFNLENBQUNKO2dDQUM1QmYsT0FBT2tCLGNBQWMsQ0FBQ1YsVUFBVSxRQUFRO29DQUFFVDtvQ0FBT3NCLGNBQWM7Z0NBQUs7Z0NBQ3BFLE9BQU90Qjs0QkFDVDs0QkFDQXNCLGNBQWM7d0JBQ2hCO3dCQUNBO29CQUNGO2dCQUNBO29CQUNFLE1BQU0sSUFBSXhDLFVBQVU7WUFDeEI7UUFDRjtRQUVBLE9BQU8yQjtJQUNULEtBQ0djLEtBQUssQ0FBQyxDQUFDMUM7UUFDTixJQUFJNEIsVUFBVVIsT0FBT2tCLGNBQWMsQ0FBQ3RDLEtBQUssWUFBWTtZQUFFbUIsT0FBT1M7UUFBUztRQUN2RSxNQUFNNUI7SUFDUixHQUNDMkMsT0FBTyxDQUFDO1FBQ1AsTUFBTUMsWUFBWWhCLFlBQVlBLFNBQVN0RCxPQUFPLENBQUMsYUFBYTtRQUM1RCxJQUFJc0UsYUFBYTVFLE9BQU84QixJQUFJLENBQUM4QyxZQUFZO1lBQ3ZDdkQsT0FBT2tDLEdBQUcsQ0FBQ25CLFVBQVV3QztRQUN2QjtJQUNGO0FBQ0o7QUFFQXJELDBCQUEwQixHQUFHckIsWUFBWTJFLElBQUksQ0FBQ2xCLFdBQVcxRCIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvcmVxdWVzdC5qcz9hYzg3Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xyXG5jb25zdCBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XHJcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XHJcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcclxuY29uc3QgeyBvbmNlIH0gPSByZXF1aXJlKCdldmVudHMnKTtcclxuY29uc3QgeyBVUkwgfSA9IHJlcXVpcmUoJ3VybCcpO1xyXG5cclxuY29uc3QgTFJVID0gcmVxdWlyZSgnbHJ1LWNhY2hlJyk7XHJcblxyXG5jb25zdCBwa2cgPSByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKTtcclxuY29uc3QgeyBSUEVycm9yIH0gPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcclxuXHJcbmNvbnN0IHBpY2sgPSByZXF1aXJlKCcuL3BpY2snKTtcclxuY29uc3QgeyBkZWVwOiBkZWZhdWx0c0RlZXAgfSA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcclxuY29uc3QgeyBIVFRQX09QVElPTlMgfSA9IHJlcXVpcmUoJy4vY29uc3RzJyk7XHJcblxyXG5sZXQgREVGQVVMVF9IVFRQX09QVElPTlM7XHJcbmNvbnN0IE5RQ0hBUiA9IC9eW1xceDIxXFx4MjMtXFx4NUJcXHg1RC1cXHg3RV0rJC87XHJcblxyXG5jb25zdCBhbGxvd2VkID0gW1xyXG4gICdhZ2VudCcsXHJcbiAgJ2NhJyxcclxuICAnY2VydCcsXHJcbiAgJ2NybCcsXHJcbiAgJ2hlYWRlcnMnLFxyXG4gICdrZXknLFxyXG4gICdsb29rdXAnLFxyXG4gICdwYXNzcGhyYXNlJyxcclxuICAncGZ4JyxcclxuICAndGltZW91dCcsXHJcbl07XHJcblxyXG5jb25zdCBzZXREZWZhdWx0cyA9IChwcm9wcywgb3B0aW9ucykgPT4ge1xyXG4gIERFRkFVTFRfSFRUUF9PUFRJT05TID0gZGVmYXVsdHNEZWVwKFxyXG4gICAge30sXHJcbiAgICBwcm9wcy5sZW5ndGggPyBwaWNrKG9wdGlvbnMsIC4uLnByb3BzKSA6IG9wdGlvbnMsXHJcbiAgICBERUZBVUxUX0hUVFBfT1BUSU9OUyxcclxuICApO1xyXG59O1xyXG5cclxuc2V0RGVmYXVsdHMoW10sIHtcclxuICBoZWFkZXJzOiB7XHJcbiAgICAnVXNlci1BZ2VudCc6IGAke3BrZy5uYW1lfS8ke3BrZy52ZXJzaW9ufSAoJHtwa2cuaG9tZXBhZ2V9KWAsXHJcbiAgICAnQWNjZXB0LUVuY29kaW5nJzogJ2lkZW50aXR5JyxcclxuICB9LFxyXG4gIHRpbWVvdXQ6IDM1MDAsXHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gc2VuZChyZXEsIGJvZHksIGNvbnRlbnRUeXBlKSB7XHJcbiAgaWYgKGNvbnRlbnRUeXBlKSB7XHJcbiAgICByZXEucmVtb3ZlSGVhZGVyKCdjb250ZW50LXR5cGUnKTtcclxuICAgIHJlcS5zZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScsIGNvbnRlbnRUeXBlKTtcclxuICB9XHJcbiAgaWYgKGJvZHkpIHtcclxuICAgIHJlcS5yZW1vdmVIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJyk7XHJcbiAgICByZXEuc2V0SGVhZGVyKCdjb250ZW50LWxlbmd0aCcsIEJ1ZmZlci5ieXRlTGVuZ3RoKGJvZHkpKTtcclxuICAgIHJlcS53cml0ZShib2R5KTtcclxuICB9XHJcbiAgcmVxLmVuZCgpO1xyXG59XHJcblxyXG5jb25zdCBub25jZXMgPSBuZXcgTFJVKHsgbWF4OiAxMDAgfSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGFzeW5jIGZ1bmN0aW9uIHJlcXVlc3Qob3B0aW9ucywgeyBhY2Nlc3NUb2tlbiwgbVRMUyA9IGZhbHNlLCBEUG9QIH0gPSB7fSkge1xyXG4gIGxldCB1cmw7XHJcbiAgdHJ5IHtcclxuICAgIHVybCA9IG5ldyBVUkwob3B0aW9ucy51cmwpO1xyXG4gICAgZGVsZXRlIG9wdGlvbnMudXJsO1xyXG4gICAgYXNzZXJ0KC9eKGh0dHBzPzopJC8udGVzdCh1cmwucHJvdG9jb2wpKTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29ubHkgdmFsaWQgYWJzb2x1dGUgVVJMcyBjYW4gYmUgcmVxdWVzdGVkJyk7XHJcbiAgfVxyXG4gIGNvbnN0IG9wdHNGbiA9IHRoaXNbSFRUUF9PUFRJT05TXTtcclxuICBsZXQgb3B0cyA9IG9wdGlvbnM7XHJcblxyXG4gIGNvbnN0IG5vbmNlS2V5ID0gYCR7dXJsLm9yaWdpbn0ke3VybC5wYXRobmFtZX1gO1xyXG4gIGlmIChEUG9QICYmICdkcG9wUHJvb2YnIGluIHRoaXMpIHtcclxuICAgIG9wdHMuaGVhZGVycyA9IG9wdHMuaGVhZGVycyB8fCB7fTtcclxuICAgIG9wdHMuaGVhZGVycy5EUG9QID0gYXdhaXQgdGhpcy5kcG9wUHJvb2YoXHJcbiAgICAgIHtcclxuICAgICAgICBodHU6IGAke3VybC5vcmlnaW59JHt1cmwucGF0aG5hbWV9YCxcclxuICAgICAgICBodG06IG9wdGlvbnMubWV0aG9kLFxyXG4gICAgICAgIG5vbmNlOiBub25jZXMuZ2V0KG5vbmNlS2V5KSxcclxuICAgICAgfSxcclxuICAgICAgRFBvUCxcclxuICAgICAgYWNjZXNzVG9rZW4sXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgbGV0IHVzZXJPcHRpb25zO1xyXG4gIGlmIChvcHRzRm4pIHtcclxuICAgIHVzZXJPcHRpb25zID0gcGljayhcclxuICAgICAgb3B0c0ZuLmNhbGwodGhpcywgdXJsLCBkZWZhdWx0c0RlZXAoe30sIG9wdHMsIERFRkFVTFRfSFRUUF9PUFRJT05TKSksXHJcbiAgICAgIC4uLmFsbG93ZWQsXHJcbiAgICApO1xyXG4gIH1cclxuICBvcHRzID0gZGVmYXVsdHNEZWVwKHt9LCB1c2VyT3B0aW9ucywgb3B0cywgREVGQVVMVF9IVFRQX09QVElPTlMpO1xyXG5cclxuICBpZiAobVRMUyAmJiAhb3B0cy5wZnggJiYgIShvcHRzLmtleSAmJiBvcHRzLmNlcnQpKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXR1YWwtVExTIGNlcnRpZmljYXRlIGFuZCBrZXkgbm90IHNldCcpO1xyXG4gIH1cclxuXHJcbiAgaWYgKG9wdHMuc2VhcmNoUGFyYW1zKSB7XHJcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRzLnNlYXJjaFBhcmFtcykpIHtcclxuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoa2V5KTtcclxuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBsZXQgcmVzcG9uc2VUeXBlO1xyXG4gIGxldCBmb3JtO1xyXG4gIGxldCBqc29uO1xyXG4gIGxldCBib2R5O1xyXG4gICh7IGZvcm0sIHJlc3BvbnNlVHlwZSwganNvbiwgYm9keSwgLi4ub3B0cyB9ID0gb3B0cyk7XHJcblxyXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdHMuaGVhZGVycyB8fCB7fSkpIHtcclxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnNba2V5XTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGxldCByZXNwb25zZTtcclxuICBjb25zdCByZXEgPSAodXJsLnByb3RvY29sID09PSAnaHR0cHM6JyA/IGh0dHBzLnJlcXVlc3QgOiBodHRwLnJlcXVlc3QpKHVybC5ocmVmLCBvcHRzKTtcclxuICByZXR1cm4gKGFzeW5jICgpID0+IHtcclxuICAgIGlmIChqc29uKSB7XHJcbiAgICAgIHNlbmQocmVxLCBKU09OLnN0cmluZ2lmeShqc29uKSwgJ2FwcGxpY2F0aW9uL2pzb24nKTtcclxuICAgIH0gZWxzZSBpZiAoZm9ybSkge1xyXG4gICAgICBzZW5kKHJlcSwgcXVlcnlzdHJpbmcuc3RyaW5naWZ5KGZvcm0pLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyk7XHJcbiAgICB9IGVsc2UgaWYgKGJvZHkpIHtcclxuICAgICAgc2VuZChyZXEsIGJvZHkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2VuZChyZXEpO1xyXG4gICAgfVxyXG5cclxuICAgIFtyZXNwb25zZV0gPSBhd2FpdCBQcm9taXNlLnJhY2UoW29uY2UocmVxLCAncmVzcG9uc2UnKSwgb25jZShyZXEsICd0aW1lb3V0JyldKTtcclxuXHJcbiAgICAvLyB0aW1lb3V0IHJlYWNoZWRcclxuICAgIGlmICghcmVzcG9uc2UpIHtcclxuICAgICAgcmVxLmRlc3Ryb3koKTtcclxuICAgICAgdGhyb3cgbmV3IFJQRXJyb3IoYG91dGdvaW5nIHJlcXVlc3QgdGltZWQgb3V0IGFmdGVyICR7b3B0cy50aW1lb3V0fW1zYCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcGFydHMgPSBbXTtcclxuXHJcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHBhcnQgb2YgcmVzcG9uc2UpIHtcclxuICAgICAgcGFydHMucHVzaChwYXJ0KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocGFydHMubGVuZ3RoKSB7XHJcbiAgICAgIHN3aXRjaCAocmVzcG9uc2VUeXBlKSB7XHJcbiAgICAgICAgY2FzZSAnanNvbic6IHtcclxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNwb25zZSwgJ2JvZHknLCB7XHJcbiAgICAgICAgICAgIGdldCgpIHtcclxuICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBCdWZmZXIuY29uY2F0KHBhcnRzKTtcclxuICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBKU09OLnBhcnNlKHZhbHVlKTtcclxuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsICdyZXNwb25zZScsIHsgdmFsdWU6IHJlc3BvbnNlIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzcG9uc2UsICdib2R5JywgeyB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxyXG4gICAgICAgIGNhc2UgJ2J1ZmZlcic6IHtcclxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNwb25zZSwgJ2JvZHknLCB7XHJcbiAgICAgICAgICAgIGdldCgpIHtcclxuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IEJ1ZmZlci5jb25jYXQocGFydHMpO1xyXG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNwb25zZSwgJ2JvZHknLCB7IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5zdXBwb3J0ZWQgcmVzcG9uc2VUeXBlIHJlcXVlc3Qgb3B0aW9uJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgfSkoKVxyXG4gICAgLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgaWYgKHJlc3BvbnNlKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCAncmVzcG9uc2UnLCB7IHZhbHVlOiByZXNwb25zZSB9KTtcclxuICAgICAgdGhyb3cgZXJyO1xyXG4gICAgfSlcclxuICAgIC5maW5hbGx5KCgpID0+IHtcclxuICAgICAgY29uc3QgZHBvcE5vbmNlID0gcmVzcG9uc2UgJiYgcmVzcG9uc2UuaGVhZGVyc1snZHBvcC1ub25jZSddO1xyXG4gICAgICBpZiAoZHBvcE5vbmNlICYmIE5RQ0hBUi50ZXN0KGRwb3BOb25jZSkpIHtcclxuICAgICAgICBub25jZXMuc2V0KG5vbmNlS2V5LCBkcG9wTm9uY2UpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLnNldERlZmF1bHRzID0gc2V0RGVmYXVsdHMuYmluZCh1bmRlZmluZWQsIGFsbG93ZWQpO1xyXG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsInF1ZXJ5c3RyaW5nIiwiaHR0cCIsImh0dHBzIiwib25jZSIsIlVSTCIsIkxSVSIsInBrZyIsIlJQRXJyb3IiLCJwaWNrIiwiZGVlcCIsImRlZmF1bHRzRGVlcCIsIkhUVFBfT1BUSU9OUyIsIkRFRkFVTFRfSFRUUF9PUFRJT05TIiwiTlFDSEFSIiwiYWxsb3dlZCIsInNldERlZmF1bHRzIiwicHJvcHMiLCJvcHRpb25zIiwibGVuZ3RoIiwiaGVhZGVycyIsIm5hbWUiLCJ2ZXJzaW9uIiwiaG9tZXBhZ2UiLCJ0aW1lb3V0Iiwic2VuZCIsInJlcSIsImJvZHkiLCJjb250ZW50VHlwZSIsInJlbW92ZUhlYWRlciIsInNldEhlYWRlciIsIkJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJ3cml0ZSIsImVuZCIsIm5vbmNlcyIsIm1heCIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1ZXN0IiwiYWNjZXNzVG9rZW4iLCJtVExTIiwiRFBvUCIsInVybCIsInRlc3QiLCJwcm90b2NvbCIsImVyciIsIlR5cGVFcnJvciIsIm9wdHNGbiIsIm9wdHMiLCJub25jZUtleSIsIm9yaWdpbiIsInBhdGhuYW1lIiwiZHBvcFByb29mIiwiaHR1IiwiaHRtIiwibWV0aG9kIiwibm9uY2UiLCJnZXQiLCJ1c2VyT3B0aW9ucyIsImNhbGwiLCJwZngiLCJrZXkiLCJjZXJ0Iiwic2VhcmNoUGFyYW1zIiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwiZGVsZXRlIiwic2V0IiwicmVzcG9uc2VUeXBlIiwiZm9ybSIsImpzb24iLCJ1bmRlZmluZWQiLCJyZXNwb25zZSIsImhyZWYiLCJKU09OIiwic3RyaW5naWZ5IiwiUHJvbWlzZSIsInJhY2UiLCJkZXN0cm95IiwicGFydHMiLCJwYXJ0IiwicHVzaCIsImRlZmluZVByb3BlcnR5IiwiY29uY2F0IiwicGFyc2UiLCJjb25maWd1cmFibGUiLCJjYXRjaCIsImZpbmFsbHkiLCJkcG9wTm9uY2UiLCJiaW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/request.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/unix_timestamp.js":
/*!******************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/unix_timestamp.js ***!
  \******************************************************************/
/***/ ((module) => {

eval("module.exports = ()=>Math.floor(Date.now() / 1000);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL3VuaXhfdGltZXN0YW1wLmpzPzRlN2YiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSAoKSA9PiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcclxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJNYXRoIiwiZmxvb3IiLCJEYXRlIiwibm93Il0sIm1hcHBpbmdzIjoiQUFBQUEsT0FBT0MsT0FBTyxHQUFHLElBQU1DLEtBQUtDLEtBQUssQ0FBQ0MsS0FBS0MsR0FBRyxLQUFLIiwiZmlsZSI6Iihyc2MpLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvdW5peF90aW1lc3RhbXAuanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/unix_timestamp.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/weak_cache.js":
/*!**************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/weak_cache.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("module.exports.keystores = new WeakMap();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy93ZWFrX2NhY2hlLmpzIiwibWFwcGluZ3MiOiJBQUFBQSx3QkFBd0IsR0FBRyxJQUFJRyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvd2Vha19jYWNoZS5qcz9jOTMwIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzLmtleXN0b3JlcyA9IG5ldyBXZWFrTWFwKCk7XHJcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwia2V5c3RvcmVzIiwiV2Vha01hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/weak_cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/webfinger_normalize.js":
/*!***********************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/webfinger_normalize.js ***!
  \***********************************************************************/
/***/ ((module) => {

eval("// Credit: https://github.com/rohe/pyoidc/blob/master/src/oic/utils/webfinger.py\n// -- Normalization --\n// A string of any other type is interpreted as a URI either the form of scheme\n// \"://\" authority path-abempty [ \"?\" query ] [ \"#\" fragment ] or authority\n// path-abempty [ \"?\" query ] [ \"#\" fragment ] per RFC 3986 [RFC3986] and is\n// normalized according to the following rules:\n//\n// If the user input Identifier does not have an RFC 3986 [RFC3986] scheme\n// portion, the string is interpreted as [userinfo \"@\"] host [\":\" port]\n// path-abempty [ \"?\" query ] [ \"#\" fragment ] per RFC 3986 [RFC3986].\n// If the userinfo component is present and all of the path component, query\n// component, and port component are empty, the acct scheme is assumed. In this\n// case, the normalized URI is formed by prefixing acct: to the string as the\n// scheme. Per the 'acct' URI Scheme [ID.ietfappsawgaccturi], if there is an\n// at-sign character ('@') in the userinfo component, it needs to be\n// percent-encoded as described in RFC 3986 [RFC3986].\n// For all other inputs without a scheme portion, the https scheme is assumed,\n// and the normalized URI is formed by prefixing https:// to the string as the\n// scheme.\n// If the resulting URI contains a fragment portion, it MUST be stripped off\n// together with the fragment delimiter character \"#\".\n// The WebFinger [ID.ietfappsawgwebfinger] Resource in this case is the\n// resulting URI, and the WebFinger Host is the authority component.\n//\n// Note: Since the definition of authority in RFC 3986 [RFC3986] is\n// [ userinfo \"@\" ] host [ \":\" port ], it is legal to have a user input\n// identifier like userinfo@host:port, e.g., alice@example.com:8080.\nconst PORT = /^\\d+$/;\nfunction hasScheme(input) {\n    if (input.includes(\"://\")) return true;\n    const authority = input.replace(/(\\/|\\?)/g, \"#\").split(\"#\")[0];\n    if (authority.includes(\":\")) {\n        const index = authority.indexOf(\":\");\n        const hostOrPort = authority.slice(index + 1);\n        if (!PORT.test(hostOrPort)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction acctSchemeAssumed(input) {\n    if (!input.includes(\"@\")) return false;\n    const parts = input.split(\"@\");\n    const host = parts[parts.length - 1];\n    return !(host.includes(\":\") || host.includes(\"/\") || host.includes(\"?\"));\n}\nfunction normalize(input) {\n    if (typeof input !== \"string\") {\n        throw new TypeError(\"input must be a string\");\n    }\n    let output;\n    if (hasScheme(input)) {\n        output = input;\n    } else if (acctSchemeAssumed(input)) {\n        output = `acct:${input}`;\n    } else {\n        output = `https://${input}`;\n    }\n    return output.split(\"#\")[0];\n}\nmodule.exports = normalize;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL3dlYmZpbmdlcl9ub3JtYWxpemUuanM/MzY2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDcmVkaXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9yb2hlL3B5b2lkYy9ibG9iL21hc3Rlci9zcmMvb2ljL3V0aWxzL3dlYmZpbmdlci5weVxyXG5cclxuLy8gLS0gTm9ybWFsaXphdGlvbiAtLVxyXG4vLyBBIHN0cmluZyBvZiBhbnkgb3RoZXIgdHlwZSBpcyBpbnRlcnByZXRlZCBhcyBhIFVSSSBlaXRoZXIgdGhlIGZvcm0gb2Ygc2NoZW1lXHJcbi8vIFwiOi8vXCIgYXV0aG9yaXR5IHBhdGgtYWJlbXB0eSBbIFwiP1wiIHF1ZXJ5IF0gWyBcIiNcIiBmcmFnbWVudCBdIG9yIGF1dGhvcml0eVxyXG4vLyBwYXRoLWFiZW1wdHkgWyBcIj9cIiBxdWVyeSBdIFsgXCIjXCIgZnJhZ21lbnQgXSBwZXIgUkZDIDM5ODYgW1JGQzM5ODZdIGFuZCBpc1xyXG4vLyBub3JtYWxpemVkIGFjY29yZGluZyB0byB0aGUgZm9sbG93aW5nIHJ1bGVzOlxyXG4vL1xyXG4vLyBJZiB0aGUgdXNlciBpbnB1dCBJZGVudGlmaWVyIGRvZXMgbm90IGhhdmUgYW4gUkZDIDM5ODYgW1JGQzM5ODZdIHNjaGVtZVxyXG4vLyBwb3J0aW9uLCB0aGUgc3RyaW5nIGlzIGludGVycHJldGVkIGFzIFt1c2VyaW5mbyBcIkBcIl0gaG9zdCBbXCI6XCIgcG9ydF1cclxuLy8gcGF0aC1hYmVtcHR5IFsgXCI/XCIgcXVlcnkgXSBbIFwiI1wiIGZyYWdtZW50IF0gcGVyIFJGQyAzOTg2IFtSRkMzOTg2XS5cclxuLy8gSWYgdGhlIHVzZXJpbmZvIGNvbXBvbmVudCBpcyBwcmVzZW50IGFuZCBhbGwgb2YgdGhlIHBhdGggY29tcG9uZW50LCBxdWVyeVxyXG4vLyBjb21wb25lbnQsIGFuZCBwb3J0IGNvbXBvbmVudCBhcmUgZW1wdHksIHRoZSBhY2N0IHNjaGVtZSBpcyBhc3N1bWVkLiBJbiB0aGlzXHJcbi8vIGNhc2UsIHRoZSBub3JtYWxpemVkIFVSSSBpcyBmb3JtZWQgYnkgcHJlZml4aW5nIGFjY3Q6IHRvIHRoZSBzdHJpbmcgYXMgdGhlXHJcbi8vIHNjaGVtZS4gUGVyIHRoZSAnYWNjdCcgVVJJIFNjaGVtZSBbSeKAkUQuaWV0ZuKAkWFwcHNhd2figJFhY2N04oCRdXJpXSwgaWYgdGhlcmUgaXMgYW5cclxuLy8gYXQtc2lnbiBjaGFyYWN0ZXIgKCdAJykgaW4gdGhlIHVzZXJpbmZvIGNvbXBvbmVudCwgaXQgbmVlZHMgdG8gYmVcclxuLy8gcGVyY2VudC1lbmNvZGVkIGFzIGRlc2NyaWJlZCBpbiBSRkMgMzk4NiBbUkZDMzk4Nl0uXHJcbi8vIEZvciBhbGwgb3RoZXIgaW5wdXRzIHdpdGhvdXQgYSBzY2hlbWUgcG9ydGlvbiwgdGhlIGh0dHBzIHNjaGVtZSBpcyBhc3N1bWVkLFxyXG4vLyBhbmQgdGhlIG5vcm1hbGl6ZWQgVVJJIGlzIGZvcm1lZCBieSBwcmVmaXhpbmcgaHR0cHM6Ly8gdG8gdGhlIHN0cmluZyBhcyB0aGVcclxuLy8gc2NoZW1lLlxyXG4vLyBJZiB0aGUgcmVzdWx0aW5nIFVSSSBjb250YWlucyBhIGZyYWdtZW50IHBvcnRpb24sIGl0IE1VU1QgYmUgc3RyaXBwZWQgb2ZmXHJcbi8vIHRvZ2V0aGVyIHdpdGggdGhlIGZyYWdtZW50IGRlbGltaXRlciBjaGFyYWN0ZXIgXCIjXCIuXHJcbi8vIFRoZSBXZWJGaW5nZXIgW0nigJFELmlldGbigJFhcHBzYXdn4oCRd2ViZmluZ2VyXSBSZXNvdXJjZSBpbiB0aGlzIGNhc2UgaXMgdGhlXHJcbi8vIHJlc3VsdGluZyBVUkksIGFuZCB0aGUgV2ViRmluZ2VyIEhvc3QgaXMgdGhlIGF1dGhvcml0eSBjb21wb25lbnQuXHJcbi8vXHJcbi8vIE5vdGU6IFNpbmNlIHRoZSBkZWZpbml0aW9uIG9mIGF1dGhvcml0eSBpbiBSRkMgMzk4NiBbUkZDMzk4Nl0gaXNcclxuLy8gWyB1c2VyaW5mbyBcIkBcIiBdIGhvc3QgWyBcIjpcIiBwb3J0IF0sIGl0IGlzIGxlZ2FsIHRvIGhhdmUgYSB1c2VyIGlucHV0XHJcbi8vIGlkZW50aWZpZXIgbGlrZSB1c2VyaW5mb0Bob3N0OnBvcnQsIGUuZy4sIGFsaWNlQGV4YW1wbGUuY29tOjgwODAuXHJcblxyXG5jb25zdCBQT1JUID0gL15cXGQrJC87XHJcblxyXG5mdW5jdGlvbiBoYXNTY2hlbWUoaW5wdXQpIHtcclxuICBpZiAoaW5wdXQuaW5jbHVkZXMoJzovLycpKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgY29uc3QgYXV0aG9yaXR5ID0gaW5wdXQucmVwbGFjZSgvKFxcL3xcXD8pL2csICcjJykuc3BsaXQoJyMnKVswXTtcclxuICBpZiAoYXV0aG9yaXR5LmluY2x1ZGVzKCc6JykpIHtcclxuICAgIGNvbnN0IGluZGV4ID0gYXV0aG9yaXR5LmluZGV4T2YoJzonKTtcclxuICAgIGNvbnN0IGhvc3RPclBvcnQgPSBhdXRob3JpdHkuc2xpY2UoaW5kZXggKyAxKTtcclxuICAgIGlmICghUE9SVC50ZXN0KGhvc3RPclBvcnQpKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhY2N0U2NoZW1lQXNzdW1lZChpbnB1dCkge1xyXG4gIGlmICghaW5wdXQuaW5jbHVkZXMoJ0AnKSkgcmV0dXJuIGZhbHNlO1xyXG4gIGNvbnN0IHBhcnRzID0gaW5wdXQuc3BsaXQoJ0AnKTtcclxuICBjb25zdCBob3N0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XHJcbiAgcmV0dXJuICEoaG9zdC5pbmNsdWRlcygnOicpIHx8IGhvc3QuaW5jbHVkZXMoJy8nKSB8fCBob3N0LmluY2x1ZGVzKCc/JykpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBub3JtYWxpemUoaW5wdXQpIHtcclxuICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5wdXQgbXVzdCBiZSBhIHN0cmluZycpO1xyXG4gIH1cclxuXHJcbiAgbGV0IG91dHB1dDtcclxuICBpZiAoaGFzU2NoZW1lKGlucHV0KSkge1xyXG4gICAgb3V0cHV0ID0gaW5wdXQ7XHJcbiAgfSBlbHNlIGlmIChhY2N0U2NoZW1lQXNzdW1lZChpbnB1dCkpIHtcclxuICAgIG91dHB1dCA9IGBhY2N0OiR7aW5wdXR9YDtcclxuICB9IGVsc2Uge1xyXG4gICAgb3V0cHV0ID0gYGh0dHBzOi8vJHtpbnB1dH1gO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG91dHB1dC5zcGxpdCgnIycpWzBdO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5vcm1hbGl6ZTtcclxuIl0sIm5hbWVzIjpbIlBPUlQiLCJoYXNTY2hlbWUiLCJpbnB1dCIsImluY2x1ZGVzIiwiYXV0aG9yaXR5IiwicmVwbGFjZSIsInNwbGl0IiwiaW5kZXgiLCJpbmRleE9mIiwiaG9zdE9yUG9ydCIsInNsaWNlIiwidGVzdCIsImFjY3RTY2hlbWVBc3N1bWVkIiwicGFydHMiLCJob3N0IiwibGVuZ3RoIiwibm9ybWFsaXplIiwiVHlwZUVycm9yIiwib3V0cHV0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUEsZ0ZBQWdGO0FBRWhGLHNCQUFzQjtBQUN0QiwrRUFBK0U7QUFDL0UsMkVBQTJFO0FBQzNFLDRFQUE0RTtBQUM1RSwrQ0FBK0M7QUFDL0MsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx1RUFBdUU7QUFDdkUsc0VBQXNFO0FBQ3RFLDRFQUE0RTtBQUM1RSwrRUFBK0U7QUFDL0UsNkVBQTZFO0FBQzdFLGdGQUFnRjtBQUNoRixvRUFBb0U7QUFDcEUsc0RBQXNEO0FBQ3RELDhFQUE4RTtBQUM5RSw4RUFBOEU7QUFDOUUsVUFBVTtBQUNWLDRFQUE0RTtBQUM1RSxzREFBc0Q7QUFDdEQsMEVBQTBFO0FBQzFFLG9FQUFvRTtBQUNwRSxFQUFFO0FBQ0YsbUVBQW1FO0FBQ25FLHVFQUF1RTtBQUN2RSxvRUFBb0U7QUFFcEUsTUFBTUEsT0FBTztBQUViLFNBQVNDLFVBQVVDLEtBQUs7SUFDdEIsSUFBSUEsTUFBTUMsUUFBUSxDQUFDLFFBQVEsT0FBTztJQUVsQyxNQUFNQyxZQUFZRixNQUFNRyxPQUFPLENBQUMsWUFBWSxLQUFLQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7SUFDOUQsSUFBSUYsVUFBVUQsUUFBUSxDQUFDLE1BQU07UUFDM0IsTUFBTUksUUFBUUgsVUFBVUksT0FBTyxDQUFDO1FBQ2hDLE1BQU1DLGFBQWFMLFVBQVVNLEtBQUssQ0FBQ0gsUUFBUTtRQUMzQyxJQUFJLENBQUNQLEtBQUtXLElBQUksQ0FBQ0YsYUFBYTtZQUMxQixPQUFPO1FBQ1Q7SUFDRjtJQUVBLE9BQU87QUFDVDtBQUVBLFNBQVNHLGtCQUFrQlYsS0FBSztJQUM5QixJQUFJLENBQUNBLE1BQU1DLFFBQVEsQ0FBQyxNQUFNLE9BQU87SUFDakMsTUFBTVUsUUFBUVgsTUFBTUksS0FBSyxDQUFDO0lBQzFCLE1BQU1RLE9BQU9ELEtBQUssQ0FBQ0EsTUFBTUUsTUFBTSxHQUFHLEVBQUU7SUFDcEMsT0FBTyxDQUFFRCxDQUFBQSxLQUFLWCxRQUFRLENBQUMsUUFBUVcsS0FBS1gsUUFBUSxDQUFDLFFBQVFXLEtBQUtYLFFBQVEsQ0FBQyxJQUFHO0FBQ3hFO0FBRUEsU0FBU2EsVUFBVWQsS0FBSztJQUN0QixJQUFJLE9BQU9BLFVBQVUsVUFBVTtRQUM3QixNQUFNLElBQUllLFVBQVU7SUFDdEI7SUFFQSxJQUFJQztJQUNKLElBQUlqQixVQUFVQyxRQUFRO1FBQ3BCZ0IsU0FBU2hCO0lBQ1gsT0FBTyxJQUFJVSxrQkFBa0JWLFFBQVE7UUFDbkNnQixTQUFTLENBQUMsS0FBSyxFQUFFaEIsTUFBTSxDQUFDO0lBQzFCLE9BQU87UUFDTGdCLFNBQVMsQ0FBQyxRQUFRLEVBQUVoQixNQUFNLENBQUM7SUFDN0I7SUFFQSxPQUFPZ0IsT0FBT1osS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQzdCO0FBRUFhLE9BQU9DLE9BQU8sR0FBR0oiLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy93ZWJmaW5nZXJfbm9ybWFsaXplLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/webfinger_normalize.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/helpers/www_authenticate_parser.js":
/*!***************************************************************************!*\
  !*** ./node_modules/openid-client/lib/helpers/www_authenticate_parser.js ***!
  \***************************************************************************/
/***/ ((module) => {

eval("const REGEXP = /(\\w+)=(\"[^\"]*\")/g;\nmodule.exports = (wwwAuthenticate)=>{\n    const params = {};\n    try {\n        while(REGEXP.exec(wwwAuthenticate) !== null){\n            if (RegExp.$1 && RegExp.$2) {\n                params[RegExp.$1] = RegExp.$2.slice(1, -1);\n            }\n        }\n    } catch (err) {}\n    return params;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL3d3d19hdXRoZW50aWNhdGVfcGFyc2VyLmpzP2YwMGQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUkVHRVhQID0gLyhcXHcrKT0oXCJbXlwiXSpcIikvZztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKHd3d0F1dGhlbnRpY2F0ZSkgPT4ge1xyXG4gIGNvbnN0IHBhcmFtcyA9IHt9O1xyXG4gIHRyeSB7XHJcbiAgICB3aGlsZSAoUkVHRVhQLmV4ZWMod3d3QXV0aGVudGljYXRlKSAhPT0gbnVsbCkge1xyXG4gICAgICBpZiAoUmVnRXhwLiQxICYmIFJlZ0V4cC4kMikge1xyXG4gICAgICAgIHBhcmFtc1tSZWdFeHAuJDFdID0gUmVnRXhwLiQyLnNsaWNlKDEsIC0xKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycikge31cclxuXHJcbiAgcmV0dXJuIHBhcmFtcztcclxufTtcclxuIl0sIm5hbWVzIjpbIlJFR0VYUCIsIm1vZHVsZSIsImV4cG9ydHMiLCJ3d3dBdXRoZW50aWNhdGUiLCJwYXJhbXMiLCJleGVjIiwiUmVnRXhwIiwiJDEiLCIkMiIsInNsaWNlIiwiZXJyIl0sIm1hcHBpbmdzIjoiQUFBQSxNQUFNQSxTQUFTO0FBRWZDLE9BQU9DLE9BQU8sR0FBRyxDQUFDQztJQUNoQixNQUFNQyxTQUFTLENBQUM7SUFDaEIsSUFBSTtRQUNGLE1BQU9KLE9BQU9LLElBQUksQ0FBQ0YscUJBQXFCLEtBQU07WUFDNUMsSUFBSUcsT0FBT0MsRUFBRSxJQUFJRCxPQUFPRSxFQUFFLEVBQUU7Z0JBQzFCSixNQUFNLENBQUNFLE9BQU9DLEVBQUUsQ0FBQyxHQUFHRCxPQUFPRSxFQUFFLENBQUNDLEtBQUssQ0FBQyxHQUFHLENBQUM7WUFDMUM7UUFDRjtJQUNGLEVBQUUsT0FBT0MsS0FBSyxDQUFDO0lBRWYsT0FBT047QUFDVCIsImZpbGUiOiIocnNjKS8uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL3d3d19hdXRoZW50aWNhdGVfcGFyc2VyLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/helpers/www_authenticate_parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/openid-client/lib/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Issuer = __webpack_require__(/*! ./issuer */ \"(rsc)/./node_modules/openid-client/lib/issuer.js\");\nconst { OPError, RPError } = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/openid-client/lib/errors.js\");\nconst Strategy = __webpack_require__(/*! ./passport_strategy */ \"(rsc)/./node_modules/openid-client/lib/passport_strategy.js\");\nconst TokenSet = __webpack_require__(/*! ./token_set */ \"(rsc)/./node_modules/openid-client/lib/token_set.js\");\nconst { CLOCK_TOLERANCE, HTTP_OPTIONS } = __webpack_require__(/*! ./helpers/consts */ \"(rsc)/./node_modules/openid-client/lib/helpers/consts.js\");\nconst generators = __webpack_require__(/*! ./helpers/generators */ \"(rsc)/./node_modules/openid-client/lib/helpers/generators.js\");\nconst { setDefaults } = __webpack_require__(/*! ./helpers/request */ \"(rsc)/./node_modules/openid-client/lib/helpers/request.js\");\nmodule.exports = {\n    Issuer,\n    Strategy,\n    TokenSet,\n    errors: {\n        OPError,\n        RPError\n    },\n    custom: {\n        setHttpOptionsDefaults: setDefaults,\n        http_options: HTTP_OPTIONS,\n        clock_tolerance: CLOCK_TOLERANCE\n    },\n    generators\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsTUFBTUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUNyQyxNQUFNRyxXQUFXSCxtQkFBT0EsQ0FBQztBQUN6QixNQUFNSSxXQUFXSixtQkFBT0EsQ0FBQztBQUN6QixNQUFNLEVBQUVLLGVBQWUsRUFBRUMsWUFBWSxFQUFFLEdBQUdOLG1CQUFPQSxDQUFDO0FBQ2xELE1BQU1PLGFBQWFQLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRVEsV0FBVyxFQUFFLEdBQUdSLG1CQUFPQSxDQUFDO0FBRWhDUyxPQUFPQyxPQUFPLEdBQUc7SUFDZlg7SUFDQUk7SUFDQUM7SUFDQU8sUUFBUTtRQUNOVjtRQUNBQztJQUNGO0lBQ0FVLFFBQVE7UUFDTkMsd0JBQXdCTDtRQUN4Qk0sY0FBY1I7UUFDZFMsaUJBQWlCVjtJQUNuQjtJQUNBRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaW5kZXguanM/Y2Y5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBJc3N1ZXIgPSByZXF1aXJlKCcuL2lzc3VlcicpO1xyXG5jb25zdCB7IE9QRXJyb3IsIFJQRXJyb3IgfSA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XHJcbmNvbnN0IFN0cmF0ZWd5ID0gcmVxdWlyZSgnLi9wYXNzcG9ydF9zdHJhdGVneScpO1xyXG5jb25zdCBUb2tlblNldCA9IHJlcXVpcmUoJy4vdG9rZW5fc2V0Jyk7XHJcbmNvbnN0IHsgQ0xPQ0tfVE9MRVJBTkNFLCBIVFRQX09QVElPTlMgfSA9IHJlcXVpcmUoJy4vaGVscGVycy9jb25zdHMnKTtcclxuY29uc3QgZ2VuZXJhdG9ycyA9IHJlcXVpcmUoJy4vaGVscGVycy9nZW5lcmF0b3JzJyk7XHJcbmNvbnN0IHsgc2V0RGVmYXVsdHMgfSA9IHJlcXVpcmUoJy4vaGVscGVycy9yZXF1ZXN0Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBJc3N1ZXIsXHJcbiAgU3RyYXRlZ3ksXHJcbiAgVG9rZW5TZXQsXHJcbiAgZXJyb3JzOiB7XHJcbiAgICBPUEVycm9yLFxyXG4gICAgUlBFcnJvcixcclxuICB9LFxyXG4gIGN1c3RvbToge1xyXG4gICAgc2V0SHR0cE9wdGlvbnNEZWZhdWx0czogc2V0RGVmYXVsdHMsXHJcbiAgICBodHRwX29wdGlvbnM6IEhUVFBfT1BUSU9OUyxcclxuICAgIGNsb2NrX3RvbGVyYW5jZTogQ0xPQ0tfVE9MRVJBTkNFLFxyXG4gIH0sXHJcbiAgZ2VuZXJhdG9ycyxcclxufTtcclxuIl0sIm5hbWVzIjpbIklzc3VlciIsInJlcXVpcmUiLCJPUEVycm9yIiwiUlBFcnJvciIsIlN0cmF0ZWd5IiwiVG9rZW5TZXQiLCJDTE9DS19UT0xFUkFOQ0UiLCJIVFRQX09QVElPTlMiLCJnZW5lcmF0b3JzIiwic2V0RGVmYXVsdHMiLCJtb2R1bGUiLCJleHBvcnRzIiwiZXJyb3JzIiwiY3VzdG9tIiwic2V0SHR0cE9wdGlvbnNEZWZhdWx0cyIsImh0dHBfb3B0aW9ucyIsImNsb2NrX3RvbGVyYW5jZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/issuer.js":
/*!**************************************************!*\
  !*** ./node_modules/openid-client/lib/issuer.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { inspect } = __webpack_require__(/*! util */ \"util\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst { RPError } = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/openid-client/lib/errors.js\");\nconst getClient = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/openid-client/lib/client.js\");\nconst registry = __webpack_require__(/*! ./issuer_registry */ \"(rsc)/./node_modules/openid-client/lib/issuer_registry.js\");\nconst processResponse = __webpack_require__(/*! ./helpers/process_response */ \"(rsc)/./node_modules/openid-client/lib/helpers/process_response.js\");\nconst webfingerNormalize = __webpack_require__(/*! ./helpers/webfinger_normalize */ \"(rsc)/./node_modules/openid-client/lib/helpers/webfinger_normalize.js\");\nconst request = __webpack_require__(/*! ./helpers/request */ \"(rsc)/./node_modules/openid-client/lib/helpers/request.js\");\nconst clone = __webpack_require__(/*! ./helpers/deep_clone */ \"(rsc)/./node_modules/openid-client/lib/helpers/deep_clone.js\");\nconst { keystore } = __webpack_require__(/*! ./helpers/issuer */ \"(rsc)/./node_modules/openid-client/lib/helpers/issuer.js\");\nconst AAD_MULTITENANT_DISCOVERY = [\n    \"https://login.microsoftonline.com/common/.well-known/openid-configuration\",\n    \"https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration\",\n    \"https://login.microsoftonline.com/organizations/v2.0/.well-known/openid-configuration\",\n    \"https://login.microsoftonline.com/consumers/v2.0/.well-known/openid-configuration\"\n];\nconst AAD_MULTITENANT = Symbol();\nconst ISSUER_DEFAULTS = {\n    claim_types_supported: [\n        \"normal\"\n    ],\n    claims_parameter_supported: false,\n    grant_types_supported: [\n        \"authorization_code\",\n        \"implicit\"\n    ],\n    request_parameter_supported: false,\n    request_uri_parameter_supported: true,\n    require_request_uri_registration: false,\n    response_modes_supported: [\n        \"query\",\n        \"fragment\"\n    ],\n    token_endpoint_auth_methods_supported: [\n        \"client_secret_basic\"\n    ]\n};\nclass Issuer {\n    #metadata;\n    constructor(meta = {}){\n        const aadIssValidation = meta[AAD_MULTITENANT];\n        delete meta[AAD_MULTITENANT];\n        [\n            \"introspection\",\n            \"revocation\"\n        ].forEach((endpoint)=>{\n            // if intro/revocation endpoint auth specific meta is missing use the token ones if they\n            // are defined\n            if (meta[`${endpoint}_endpoint`] && meta[`${endpoint}_endpoint_auth_methods_supported`] === undefined && meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] === undefined) {\n                if (meta.token_endpoint_auth_methods_supported) {\n                    meta[`${endpoint}_endpoint_auth_methods_supported`] = meta.token_endpoint_auth_methods_supported;\n                }\n                if (meta.token_endpoint_auth_signing_alg_values_supported) {\n                    meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] = meta.token_endpoint_auth_signing_alg_values_supported;\n                }\n            }\n        });\n        this.#metadata = new Map();\n        Object.entries(meta).forEach(([key, value])=>{\n            this.#metadata.set(key, value);\n            if (!this[key]) {\n                Object.defineProperty(this, key, {\n                    get () {\n                        return this.#metadata.get(key);\n                    },\n                    enumerable: true\n                });\n            }\n        });\n        registry.set(this.issuer, this);\n        const Client = getClient(this, aadIssValidation);\n        Object.defineProperties(this, {\n            Client: {\n                value: Client,\n                enumerable: true\n            },\n            FAPI1Client: {\n                value: class FAPI1Client extends Client {\n                },\n                enumerable: true\n            }\n        });\n    }\n    get metadata() {\n        return clone(Object.fromEntries(this.#metadata.entries()));\n    }\n    static async webfinger(input) {\n        const resource = webfingerNormalize(input);\n        const { host } = url.parse(resource);\n        const webfingerUrl = `https://${host}/.well-known/webfinger`;\n        const response = await request.call(this, {\n            method: \"GET\",\n            url: webfingerUrl,\n            responseType: \"json\",\n            searchParams: {\n                resource,\n                rel: \"http://openid.net/specs/connect/1.0/issuer\"\n            },\n            headers: {\n                Accept: \"application/json\"\n            }\n        });\n        const body = processResponse(response);\n        const location = Array.isArray(body.links) && body.links.find((link)=>typeof link === \"object\" && link.rel === \"http://openid.net/specs/connect/1.0/issuer\" && link.href);\n        if (!location) {\n            throw new RPError({\n                message: \"no issuer found in webfinger response\",\n                body\n            });\n        }\n        if (typeof location.href !== \"string\" || !location.href.startsWith(\"https://\")) {\n            throw new RPError({\n                printf: [\n                    \"invalid issuer location %s\",\n                    location.href\n                ],\n                body\n            });\n        }\n        const expectedIssuer = location.href;\n        if (registry.has(expectedIssuer)) {\n            return registry.get(expectedIssuer);\n        }\n        const issuer = await this.discover(expectedIssuer);\n        if (issuer.issuer !== expectedIssuer) {\n            registry.del(issuer.issuer);\n            throw new RPError(\"discovered issuer mismatch, expected %s, got: %s\", expectedIssuer, issuer.issuer);\n        }\n        return issuer;\n    }\n    static async discover(uri) {\n        const wellKnownUri = resolveWellKnownUri(uri);\n        const response = await request.call(this, {\n            method: \"GET\",\n            responseType: \"json\",\n            url: wellKnownUri,\n            headers: {\n                Accept: \"application/json\"\n            }\n        });\n        const body = processResponse(response);\n        return new Issuer({\n            ...ISSUER_DEFAULTS,\n            ...body,\n            [AAD_MULTITENANT]: !!AAD_MULTITENANT_DISCOVERY.find((discoveryURL)=>wellKnownUri.startsWith(discoveryURL))\n        });\n    }\n    async reloadJwksUri() {\n        await keystore.call(this, true);\n    }\n    /* istanbul ignore next */ [inspect.custom]() {\n        return `${this.constructor.name} ${inspect(this.metadata, {\n            depth: Infinity,\n            colors: process.stdout.isTTY,\n            compact: false,\n            sorted: true\n        })}`;\n    }\n}\nfunction resolveWellKnownUri(uri) {\n    const parsed = url.parse(uri);\n    if (parsed.pathname.includes(\"/.well-known/\")) {\n        return uri;\n    } else {\n        let pathname;\n        if (parsed.pathname.endsWith(\"/\")) {\n            pathname = `${parsed.pathname}.well-known/openid-configuration`;\n        } else {\n            pathname = `${parsed.pathname}/.well-known/openid-configuration`;\n        }\n        return url.format({\n            ...parsed,\n            pathname\n        });\n    }\n}\nmodule.exports = Issuer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaXNzdWVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU0sRUFBRUEsT0FBTyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzVCLE1BQU1DLE1BQU1ELG1CQUFPQSxDQUFDO0FBRXBCLE1BQU0sRUFBRUUsT0FBTyxFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBQzVCLE1BQU1HLFlBQVlILG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1JLFdBQVdKLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU1LLGtCQUFrQkwsbUJBQU9BLENBQUM7QUFDaEMsTUFBTU0scUJBQXFCTixtQkFBT0EsQ0FBQztBQUNuQyxNQUFNTyxVQUFVUCxtQkFBT0EsQ0FBQztBQUN4QixNQUFNUSxRQUFRUixtQkFBT0EsQ0FBQztBQUN0QixNQUFNLEVBQUVTLFFBQVEsRUFBRSxHQUFHVCxtQkFBT0EsQ0FBQztBQUU3QixNQUFNVSw0QkFBNEI7SUFDaEM7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUNELE1BQU1DLGtCQUFrQkM7QUFDeEIsTUFBTUMsa0JBQWtCO0lBQ3RCQyx1QkFBdUI7UUFBQztLQUFTO0lBQ2pDQyw0QkFBNEI7SUFDNUJDLHVCQUF1QjtRQUFDO1FBQXNCO0tBQVc7SUFDekRDLDZCQUE2QjtJQUM3QkMsaUNBQWlDO0lBQ2pDQyxrQ0FBa0M7SUFDbENDLDBCQUEwQjtRQUFDO1FBQVM7S0FBVztJQUMvQ0MsdUNBQXVDO1FBQUM7S0FBc0I7QUFDaEU7QUFFQSxNQUFNQztJQUNKLENBQUNDLFFBQVEsQ0FBQztJQUNWQyxZQUFZQyxPQUFPLENBQUMsQ0FBQyxDQUFFO1FBQ3JCLE1BQU1DLG1CQUFtQkQsSUFBSSxDQUFDZCxnQkFBZ0I7UUFDOUMsT0FBT2MsSUFBSSxDQUFDZCxnQkFBZ0I7UUFDNUI7WUFBQztZQUFpQjtTQUFhLENBQUNnQixPQUFPLENBQUMsQ0FBQ0M7WUFDdkMsd0ZBQXdGO1lBQ3hGLGNBQWM7WUFDZCxJQUNFSCxJQUFJ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QUFFQSxTQUFTWixvQkFBb0JGLEdBQUc7SUFDOUIsTUFBTWUsU0FBU3hGLElBQUlnRCxLQUFLLENBQUN5QjtJQUN6QixJQUFJZSxPQUFPQyxRQUFRLENBQUNDLFFBQVEsQ0FBQyxrQkFBa0I7UUFDN0MsT0FBT2pCO0lBQ1QsT0FBTztRQUNMLElBQUlnQjtRQUNKLElBQUlELE9BQU9DLFFBQVEsQ0FBQ0UsUUFBUSxDQUFDLE1BQU07WUFDakNGLFdBQVcsQ0FBQyxFQUFFRCxPQUFPQyxRQUFRLENBQUMsZ0NBQWdDLENBQUM7UUFDakUsT0FBTztZQUNMQSxXQUFXLENBQUMsRUFBRUQsT0FBT0MsUUFBUSxDQUFDLGlDQUFpQyxDQUFDO1FBQ2xFO1FBQ0EsT0FBT3pGLElBQUk0RixNQUFNLENBQUM7WUFBRSxHQUFHSixNQUFNO1lBQUVDO1FBQVM7SUFDMUM7QUFDRjtBQUVBSSxPQUFPQyxPQUFPLEdBQUd6RSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2lzc3Vlci5qcz9lZWRjIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgaW5zcGVjdCB9ID0gcmVxdWlyZSgndXRpbCcpO1xyXG5jb25zdCB1cmwgPSByZXF1aXJlKCd1cmwnKTtcclxuXHJcbmNvbnN0IHsgUlBFcnJvciB9ID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcclxuY29uc3QgZ2V0Q2xpZW50ID0gcmVxdWlyZSgnLi9jbGllbnQnKTtcclxuY29uc3QgcmVnaXN0cnkgPSByZXF1aXJlKCcuL2lzc3Vlcl9yZWdpc3RyeScpO1xyXG5jb25zdCBwcm9jZXNzUmVzcG9uc2UgPSByZXF1aXJlKCcuL2hlbHBlcnMvcHJvY2Vzc19yZXNwb25zZScpO1xyXG5jb25zdCB3ZWJmaW5nZXJOb3JtYWxpemUgPSByZXF1aXJlKCcuL2hlbHBlcnMvd2ViZmluZ2VyX25vcm1hbGl6ZScpO1xyXG5jb25zdCByZXF1ZXN0ID0gcmVxdWlyZSgnLi9oZWxwZXJzL3JlcXVlc3QnKTtcclxuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvZGVlcF9jbG9uZScpO1xyXG5jb25zdCB7IGtleXN0b3JlIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNzdWVyJyk7XHJcblxyXG5jb25zdCBBQURfTVVMVElURU5BTlRfRElTQ09WRVJZID0gW1xyXG4gICdodHRwczovL2xvZ2luLm1pY3Jvc29mdG9ubGluZS5jb20vY29tbW9uLy53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uJyxcclxuICAnaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tL2NvbW1vbi92Mi4wLy53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uJyxcclxuICAnaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tL29yZ2FuaXphdGlvbnMvdjIuMC8ud2VsbC1rbm93bi9vcGVuaWQtY29uZmlndXJhdGlvbicsXHJcbiAgJ2h0dHBzOi8vbG9naW4ubWljcm9zb2Z0b25saW5lLmNvbS9jb25zdW1lcnMvdjIuMC8ud2VsbC1rbm93bi9vcGVuaWQtY29uZmlndXJhdGlvbicsXHJcbl07XHJcbmNvbnN0IEFBRF9NVUxUSVRFTkFOVCA9IFN5bWJvbCgpO1xyXG5jb25zdCBJU1NVRVJfREVGQVVMVFMgPSB7XHJcbiAgY2xhaW1fdHlwZXNfc3VwcG9ydGVkOiBbJ25vcm1hbCddLFxyXG4gIGNsYWltc19wYXJhbWV0ZXJfc3VwcG9ydGVkOiBmYWxzZSxcclxuICBncmFudF90eXBlc19zdXBwb3J0ZWQ6IFsnYXV0aG9yaXphdGlvbl9jb2RlJywgJ2ltcGxpY2l0J10sXHJcbiAgcmVxdWVzdF9wYXJhbWV0ZXJfc3VwcG9ydGVkOiBmYWxzZSxcclxuICByZXF1ZXN0X3VyaV9wYXJhbWV0ZXJfc3VwcG9ydGVkOiB0cnVlLFxyXG4gIHJlcXVpcmVfcmVxdWVzdF91cmlfcmVnaXN0cmF0aW9uOiBmYWxzZSxcclxuICByZXNwb25zZV9tb2Rlc19zdXBwb3J0ZWQ6IFsncXVlcnknLCAnZnJhZ21lbnQnXSxcclxuICB0b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZHNfc3VwcG9ydGVkOiBbJ2NsaWVudF9zZWNyZXRfYmFzaWMnXSxcclxufTtcclxuXHJcbmNsYXNzIElzc3VlciB7XHJcbiAgI21ldGFkYXRhO1xyXG4gIGNvbnN0cnVjdG9yKG1ldGEgPSB7fSkge1xyXG4gICAgY29uc3QgYWFkSXNzVmFsaWRhdGlvbiA9IG1ldGFbQUFEX01VTFRJVEVOQU5UXTtcclxuICAgIGRlbGV0ZSBtZXRhW0FBRF9NVUxUSVRFTkFOVF07XHJcbiAgICBbJ2ludHJvc3BlY3Rpb24nLCAncmV2b2NhdGlvbiddLmZvckVhY2goKGVuZHBvaW50KSA9PiB7XHJcbiAgICAgIC8vIGlmIGludHJvL3Jldm9jYXRpb24gZW5kcG9pbnQgYXV0aCBzcGVjaWZpYyBtZXRhIGlzIG1pc3NpbmcgdXNlIHRoZSB0b2tlbiBvbmVzIGlmIHRoZXlcclxuICAgICAgLy8gYXJlIGRlZmluZWRcclxuICAgICAgaWYgKFxyXG4gICAgICAgIG1ldGFbYCR7ZW5kcG9pbnR9X2VuZHBvaW50YF0gJiZcclxuICAgICAgICBtZXRhW2Ake2VuZHBvaW50fV9lbmRwb2ludF9hdXRoX21ldGhvZHNfc3VwcG9ydGVkYF0gPT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgIG1ldGFbYCR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZGBdID09PSB1bmRlZmluZWRcclxuICAgICAgKSB7XHJcbiAgICAgICAgaWYgKG1ldGEudG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2RzX3N1cHBvcnRlZCkge1xyXG4gICAgICAgICAgbWV0YVtgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9tZXRob2RzX3N1cHBvcnRlZGBdID1cclxuICAgICAgICAgICAgbWV0YS50b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZHNfc3VwcG9ydGVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWV0YS50b2tlbl9lbmRwb2ludF9hdXRoX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQpIHtcclxuICAgICAgICAgIG1ldGFbYCR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZGBdID1cclxuICAgICAgICAgICAgbWV0YS50b2tlbl9lbmRwb2ludF9hdXRoX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLiNtZXRhZGF0YSA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICBPYmplY3QuZW50cmllcyhtZXRhKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcclxuICAgICAgdGhpcy4jbWV0YWRhdGEuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgICBpZiAoIXRoaXNba2V5XSkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcclxuICAgICAgICAgIGdldCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI21ldGFkYXRhLmdldChrZXkpO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJlZ2lzdHJ5LnNldCh0aGlzLmlzc3VlciwgdGhpcyk7XHJcblxyXG4gICAgY29uc3QgQ2xpZW50ID0gZ2V0Q2xpZW50KHRoaXMsIGFhZElzc1ZhbGlkYXRpb24pO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcclxuICAgICAgQ2xpZW50OiB7IHZhbHVlOiBDbGllbnQsIGVudW1lcmFibGU6IHRydWUgfSxcclxuICAgICAgRkFQSTFDbGllbnQ6IHsgdmFsdWU6IGNsYXNzIEZBUEkxQ2xpZW50IGV4dGVuZHMgQ2xpZW50IHt9LCBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGdldCBtZXRhZGF0YSgpIHtcclxuICAgIHJldHVybiBjbG9uZShPYmplY3QuZnJvbUVudHJpZXModGhpcy4jbWV0YWRhdGEuZW50cmllcygpKSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgYXN5bmMgd2ViZmluZ2VyKGlucHV0KSB7XHJcbiAgICBjb25zdCByZXNvdXJjZSA9IHdlYmZpbmdlck5vcm1hbGl6ZShpbnB1dCk7XHJcbiAgICBjb25zdCB7IGhvc3QgfSA9IHVybC5wYXJzZShyZXNvdXJjZSk7XHJcbiAgICBjb25zdCB3ZWJmaW5nZXJVcmwgPSBgaHR0cHM6Ly8ke2hvc3R9Ly53ZWxsLWtub3duL3dlYmZpbmdlcmA7XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0LmNhbGwodGhpcywge1xyXG4gICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICB1cmw6IHdlYmZpbmdlclVybCxcclxuICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXHJcbiAgICAgIHNlYXJjaFBhcmFtczogeyByZXNvdXJjZSwgcmVsOiAnaHR0cDovL29wZW5pZC5uZXQvc3BlY3MvY29ubmVjdC8xLjAvaXNzdWVyJyB9LFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGJvZHkgPSBwcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UpO1xyXG5cclxuICAgIGNvbnN0IGxvY2F0aW9uID1cclxuICAgICAgQXJyYXkuaXNBcnJheShib2R5LmxpbmtzKSAmJlxyXG4gICAgICBib2R5LmxpbmtzLmZpbmQoXHJcbiAgICAgICAgKGxpbmspID0+XHJcbiAgICAgICAgICB0eXBlb2YgbGluayA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAgIGxpbmsucmVsID09PSAnaHR0cDovL29wZW5pZC5uZXQvc3BlY3MvY29ubmVjdC8xLjAvaXNzdWVyJyAmJlxyXG4gICAgICAgICAgbGluay5ocmVmLFxyXG4gICAgICApO1xyXG5cclxuICAgIGlmICghbG9jYXRpb24pIHtcclxuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdubyBpc3N1ZXIgZm91bmQgaW4gd2ViZmluZ2VyIHJlc3BvbnNlJyxcclxuICAgICAgICBib2R5LFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIGxvY2F0aW9uLmhyZWYgIT09ICdzdHJpbmcnIHx8ICFsb2NhdGlvbi5ocmVmLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykpIHtcclxuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xyXG4gICAgICAgIHByaW50ZjogWydpbnZhbGlkIGlzc3VlciBsb2NhdGlvbiAlcycsIGxvY2F0aW9uLmhyZWZdLFxyXG4gICAgICAgIGJvZHksXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGV4cGVjdGVkSXNzdWVyID0gbG9jYXRpb24uaHJlZjtcclxuICAgIGlmIChyZWdpc3RyeS5oYXMoZXhwZWN0ZWRJc3N1ZXIpKSB7XHJcbiAgICAgIHJldHVybiByZWdpc3RyeS5nZXQoZXhwZWN0ZWRJc3N1ZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGlzc3VlciA9IGF3YWl0IHRoaXMuZGlzY292ZXIoZXhwZWN0ZWRJc3N1ZXIpO1xyXG5cclxuICAgIGlmIChpc3N1ZXIuaXNzdWVyICE9PSBleHBlY3RlZElzc3Vlcikge1xyXG4gICAgICByZWdpc3RyeS5kZWwoaXNzdWVyLmlzc3Vlcik7XHJcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKFxyXG4gICAgICAgICdkaXNjb3ZlcmVkIGlzc3VlciBtaXNtYXRjaCwgZXhwZWN0ZWQgJXMsIGdvdDogJXMnLFxyXG4gICAgICAgIGV4cGVjdGVkSXNzdWVyLFxyXG4gICAgICAgIGlzc3Vlci5pc3N1ZXIsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNzdWVyO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGFzeW5jIGRpc2NvdmVyKHVyaSkge1xyXG4gICAgY29uc3Qgd2VsbEtub3duVXJpID0gcmVzb2x2ZVdlbGxLbm93blVyaSh1cmkpO1xyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdC5jYWxsKHRoaXMsIHtcclxuICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXHJcbiAgICAgIHVybDogd2VsbEtub3duVXJpLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGJvZHkgPSBwcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gICAgcmV0dXJuIG5ldyBJc3N1ZXIoe1xyXG4gICAgICAuLi5JU1NVRVJfREVGQVVMVFMsXHJcbiAgICAgIC4uLmJvZHksXHJcbiAgICAgIFtBQURfTVVMVElURU5BTlRdOiAhIUFBRF9NVUxUSVRFTkFOVF9ESVNDT1ZFUlkuZmluZCgoZGlzY292ZXJ5VVJMKSA9PlxyXG4gICAgICAgIHdlbGxLbm93blVyaS5zdGFydHNXaXRoKGRpc2NvdmVyeVVSTCksXHJcbiAgICAgICksXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHJlbG9hZEp3a3NVcmkoKSB7XHJcbiAgICBhd2FpdCBrZXlzdG9yZS5jYWxsKHRoaXMsIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICBbaW5zcGVjdC5jdXN0b21dKCkge1xyXG4gICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gJHtpbnNwZWN0KHRoaXMubWV0YWRhdGEsIHtcclxuICAgICAgZGVwdGg6IEluZmluaXR5LFxyXG4gICAgICBjb2xvcnM6IHByb2Nlc3Muc3Rkb3V0LmlzVFRZLFxyXG4gICAgICBjb21wYWN0OiBmYWxzZSxcclxuICAgICAgc29ydGVkOiB0cnVlLFxyXG4gICAgfSl9YDtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVXZWxsS25vd25VcmkodXJpKSB7XHJcbiAgY29uc3QgcGFyc2VkID0gdXJsLnBhcnNlKHVyaSk7XHJcbiAgaWYgKHBhcnNlZC5wYXRobmFtZS5pbmNsdWRlcygnLy53ZWxsLWtub3duLycpKSB7XHJcbiAgICByZXR1cm4gdXJpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBsZXQgcGF0aG5hbWU7XHJcbiAgICBpZiAocGFyc2VkLnBhdGhuYW1lLmVuZHNXaXRoKCcvJykpIHtcclxuICAgICAgcGF0aG5hbWUgPSBgJHtwYXJzZWQucGF0aG5hbWV9LndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb25gO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcGF0aG5hbWUgPSBgJHtwYXJzZWQucGF0aG5hbWV9Ly53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uYDtcclxuICAgIH1cclxuICAgIHJldHVybiB1cmwuZm9ybWF0KHsgLi4ucGFyc2VkLCBwYXRobmFtZSB9KTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSXNzdWVyO1xyXG4iXSwibmFtZXMiOlsiaW5zcGVjdCIsInJlcXVpcmUiLCJ1cmwiLCJSUEVycm9yIiwiZ2V0Q2xpZW50IiwicmVnaXN0cnkiLCJwcm9jZXNzUmVzcG9uc2UiLCJ3ZWJmaW5nZXJOb3JtYWxpemUiLCJyZXF1ZXN0IiwiY2xvbmUiLCJrZXlzdG9yZSIsIkFBRF9NVUxUSVRFTkFOVF9ESVNDT1ZFUlkiLCJBQURfTVVMVElURU5BTlQiLCJTeW1ib2wiLCJJU1NVRVJfREVGQVVMVFMiLCJjbGFpbV90eXBlc19zdXBwb3J0ZWQiLCJjbGFpbXNfcGFyYW1ldGVyX3N1cHBvcnRlZCIsImdyYW50X3R5cGVzX3N1cHBvcnRlZCIsInJlcXVlc3RfcGFyYW1ldGVyX3N1cHBvcnRlZCIsInJlcXVlc3RfdXJpX3BhcmFtZXRlcl9zdXBwb3J0ZWQiLCJyZXF1aXJlX3JlcXVlc3RfdXJpX3JlZ2lzdHJhdGlvbiIsInJlc3BvbnNlX21vZGVzX3N1cHBvcnRlZCIsInRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kc19zdXBwb3J0ZWQiLCJJc3N1ZXIiLCJtZXRhZGF0YSIsImNvbnN0cnVjdG9yIiwibWV0YSIsImFhZElzc1ZhbGlkYXRpb24iLCJmb3JFYWNoIiwiZW5kcG9pbnQiLCJ1bmRlZmluZWQiLCJ0b2tlbl9lbmRwb2ludF9hdXRoX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQiLCJNYXAiLCJPYmplY3QiLCJlbnRyaWVzIiwia2V5IiwidmFsdWUiLCJzZXQiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImVudW1lcmFibGUiLCJpc3N1ZXIiLCJDbGllbnQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiRkFQSTFDbGllbnQiLCJmcm9tRW50cmllcyIsIndlYmZpbmdlciIsImlucHV0IiwicmVzb3VyY2UiLCJob3N0IiwicGFyc2UiLCJ3ZWJmaW5nZXJVcmwiLCJyZXNwb25zZSIsImNhbGwiLCJtZXRob2QiLCJyZXNwb25zZVR5cGUiLCJzZWFyY2hQYXJhbXMiLCJyZWwiLCJoZWFkZXJzIiwiQWNjZXB0IiwiYm9keSIsImxvY2F0aW9uIiwiQXJyYXkiLCJpc0FycmF5IiwibGlua3MiLCJmaW5kIiwibGluayIsImhyZWYiLCJtZXNzYWdlIiwic3RhcnRzV2l0aCIsInByaW50ZiIsImV4cGVjdGVkSXNzdWVyIiwiaGFzIiwiZGlzY292ZXIiLCJkZWwiLCJ1cmkiLCJ3ZWxsS25vd25VcmkiLCJyZXNvbHZlV2VsbEtub3duVXJpIiwiZGlzY292ZXJ5VVJMIiwicmVsb2FkSndrc1VyaSIsImN1c3RvbSIsIm5hbWUiLCJkZXB0aCIsIkluZmluaXR5IiwiY29sb3JzIiwicHJvY2VzcyIsInN0ZG91dCIsImlzVFRZIiwiY29tcGFjdCIsInNvcnRlZCIsInBhcnNlZCIsInBhdGhuYW1lIiwiaW5jbHVkZXMiLCJlbmRzV2l0aCIsImZvcm1hdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/issuer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/issuer_registry.js":
/*!***********************************************************!*\
  !*** ./node_modules/openid-client/lib/issuer_registry.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const LRU = __webpack_require__(/*! lru-cache */ \"(rsc)/./node_modules/lru-cache/index.js\");\nmodule.exports = new LRU({\n    max: 100\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaXNzdWVyX3JlZ2lzdHJ5LmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLE1BQU1DLG1CQUFPQSxDQUFDO0FBRXBCQyxPQUFPQyxPQUFPLEdBQUcsSUFBSUgsSUFBSTtJQUFFSSxLQUFLO0FBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9pc3N1ZXJfcmVnaXN0cnkuanM/YjA2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBMUlUgPSByZXF1aXJlKCdscnUtY2FjaGUnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbmV3IExSVSh7IG1heDogMTAwIH0pO1xyXG4iXSwibmFtZXMiOlsiTFJVIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJtYXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/issuer_registry.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/passport_strategy.js":
/*!*************************************************************!*\
  !*** ./node_modules/openid-client/lib/passport_strategy.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const url = __webpack_require__(/*! url */ \"url\");\nconst { format } = __webpack_require__(/*! util */ \"util\");\nconst cloneDeep = __webpack_require__(/*! ./helpers/deep_clone */ \"(rsc)/./node_modules/openid-client/lib/helpers/deep_clone.js\");\nconst { RPError, OPError } = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/openid-client/lib/errors.js\");\nconst { BaseClient } = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/openid-client/lib/client.js\");\nconst { random, codeChallenge } = __webpack_require__(/*! ./helpers/generators */ \"(rsc)/./node_modules/openid-client/lib/helpers/generators.js\");\nconst pick = __webpack_require__(/*! ./helpers/pick */ \"(rsc)/./node_modules/openid-client/lib/helpers/pick.js\");\nconst { resolveResponseType, resolveRedirectUri } = __webpack_require__(/*! ./helpers/client */ \"(rsc)/./node_modules/openid-client/lib/helpers/client.js\");\nfunction verified(err, user, info = {}) {\n    if (err) {\n        this.error(err);\n    } else if (!user) {\n        this.fail(info);\n    } else {\n        this.success(user, info);\n    }\n}\nfunction OpenIDConnectStrategy({ client, params = {}, passReqToCallback = false, sessionKey, usePKCE = true, extras = {} } = {}, verify) {\n    if (!(client instanceof BaseClient)) {\n        throw new TypeError(\"client must be an instance of openid-client Client\");\n    }\n    if (typeof verify !== \"function\") {\n        throw new TypeError(\"verify callback must be a function\");\n    }\n    if (!client.issuer || !client.issuer.issuer) {\n        throw new TypeError(\"client must have an issuer with an identifier\");\n    }\n    this._client = client;\n    this._issuer = client.issuer;\n    this._verify = verify;\n    this._passReqToCallback = passReqToCallback;\n    this._usePKCE = usePKCE;\n    this._key = sessionKey || `oidc:${url.parse(this._issuer.issuer).hostname}`;\n    this._params = cloneDeep(params);\n    // state and nonce are handled in authenticate()\n    delete this._params.state;\n    delete this._params.nonce;\n    this._extras = cloneDeep(extras);\n    if (!this._params.response_type) this._params.response_type = resolveResponseType.call(client);\n    if (!this._params.redirect_uri) this._params.redirect_uri = resolveRedirectUri.call(client);\n    if (!this._params.scope) this._params.scope = \"openid\";\n    if (this._usePKCE === true) {\n        const supportedMethods = Array.isArray(this._issuer.code_challenge_methods_supported) ? this._issuer.code_challenge_methods_supported : false;\n        if (supportedMethods && supportedMethods.includes(\"S256\")) {\n            this._usePKCE = \"S256\";\n        } else if (supportedMethods && supportedMethods.includes(\"plain\")) {\n            this._usePKCE = \"plain\";\n        } else if (supportedMethods) {\n            throw new TypeError(\"neither code_challenge_method supported by the client is supported by the issuer\");\n        } else {\n            this._usePKCE = \"S256\";\n        }\n    } else if (typeof this._usePKCE === \"string\" && ![\n        \"plain\",\n        \"S256\"\n    ].includes(this._usePKCE)) {\n        throw new TypeError(`${this._usePKCE} is not valid/implemented PKCE code_challenge_method`);\n    }\n    this.name = url.parse(client.issuer.issuer).hostname;\n}\nOpenIDConnectStrategy.prototype.authenticate = function authenticate(req, options) {\n    (async ()=>{\n        const client = this._client;\n        if (!req.session) {\n            throw new TypeError(\"authentication requires session support\");\n        }\n        const reqParams = client.callbackParams(req);\n        const sessionKey = this._key;\n        const { 0: parameter, length } = Object.keys(reqParams);\n        /**\r\n     * Start authentication request if this has no authorization response parameters or\r\n     * this might a login initiated from a third party as per\r\n     * https://openid.net/specs/openid-connect-core-1_0.html#ThirdPartyInitiatedLogin.\r\n     */ if (length === 0 || length === 1 && parameter === \"iss\") {\n            // provide options object with extra authentication parameters\n            const params = {\n                state: random(),\n                ...this._params,\n                ...options\n            };\n            if (!params.nonce && params.response_type.includes(\"id_token\")) {\n                params.nonce = random();\n            }\n            req.session[sessionKey] = pick(params, \"nonce\", \"state\", \"max_age\", \"response_type\");\n            if (this._usePKCE && params.response_type.includes(\"code\")) {\n                const verifier = random();\n                req.session[sessionKey].code_verifier = verifier;\n                switch(this._usePKCE){\n                    case \"S256\":\n                        params.code_challenge = codeChallenge(verifier);\n                        params.code_challenge_method = \"S256\";\n                        break;\n                    case \"plain\":\n                        params.code_challenge = verifier;\n                        break;\n                }\n            }\n            this.redirect(client.authorizationUrl(params));\n            return;\n        }\n        /* end authentication request */ /* start authentication response */ const session = req.session[sessionKey];\n        if (Object.keys(session || {}).length === 0) {\n            throw new Error(format('did not find expected authorization request details in session, req.session[\"%s\"] is %j', sessionKey, session));\n        }\n        const { state, nonce, max_age: maxAge, code_verifier: codeVerifier, response_type: responseType } = session;\n        try {\n            delete req.session[sessionKey];\n        } catch (err) {}\n        const opts = {\n            redirect_uri: this._params.redirect_uri,\n            ...options\n        };\n        const checks = {\n            state,\n            nonce,\n            max_age: maxAge,\n            code_verifier: codeVerifier,\n            response_type: responseType\n        };\n        const tokenset = await client.callback(opts.redirect_uri, reqParams, checks, this._extras);\n        const passReq = this._passReqToCallback;\n        const loadUserinfo = this._verify.length > (passReq ? 3 : 2) && client.issuer.userinfo_endpoint;\n        const args = [\n            tokenset,\n            verified.bind(this)\n        ];\n        if (loadUserinfo) {\n            if (!tokenset.access_token) {\n                throw new RPError({\n                    message: \"expected access_token to be returned when asking for userinfo in verify callback\",\n                    tokenset\n                });\n            }\n            const userinfo = await client.userinfo(tokenset);\n            args.splice(1, 0, userinfo);\n        }\n        if (passReq) {\n            args.unshift(req);\n        }\n        this._verify(...args);\n    /* end authentication response */ })().catch((error)=>{\n        if (error instanceof OPError && error.error !== \"server_error\" && !error.error.startsWith(\"invalid\") || error instanceof RPError) {\n            this.fail(error);\n        } else {\n            this.error(error);\n        }\n    });\n};\nmodule.exports = OpenIDConnectStrategy;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvcGFzc3BvcnRfc3RyYXRlZ3kuanMiLCJtYXBwaW5ncyI6IkFBQUEsTUFBTUEsTUFBTUMsbUJBQU9BLENBQUM7QUFDcEIsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFFM0IsTUFBTUUsWUFBWUYsbUJBQU9BLENBQUM7QUFDMUIsTUFBTSxFQUFFRyxPQUFPLEVBQUVDLE9BQU8sRUFBRSxHQUFHSixtQkFBT0EsQ0FBQztBQUNyQyxNQUFNLEVBQUVLLFVBQVUsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUMvQixNQUFNLEVBQUVNLE1BQU0sRUFBRUMsYUFBYSxFQUFFLEdBQUdQLG1CQUFPQSxDQUFDO0FBQzFDLE1BQU1RLE9BQU9SLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRVMsbUJBQW1CLEVBQUVDLGtCQUFrQixFQUFFLEdBQUdWLG1CQUFPQSxDQUFDO0FBRTVELFNBQVNXLFNBQVNDLEdBQUcsRUFBRUMsSUFBSSxFQUFFQyxPQUFPLENBQUMsQ0FBQztJQUNwQyxJQUFJRixLQUFLO1FBQ1AsSUFBSSxDQUFDRyxLQUFLLENBQUNIO0lBQ2IsT0FBTyxJQUFJLENBQUNDLE1BQU07UUFDaEIsSUFBSSxDQUFDRyxJQUFJLENBQUNGO0lBQ1osT0FBTztRQUNMLElBQUksQ0FBQ0csT0FBTyxDQUFDSixNQUFNQztJQUNyQjtBQUNGO0FBRUEsU0FBU0ksc0JBQ1AsRUFBRUMsTUFBTSxFQUFFQyxTQUFTLENBQUMsQ0FBQyxFQUFFQyxvQkFBb0IsS0FBSyxFQUFFQyxVQUFVLEVBQUVDLFVBQVUsSUFBSSxFQUFFQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQ2hHQyxNQUFNO0lBRU4sSUFBSSxDQUFFTixDQUFBQSxrQkFBa0JkLFVBQVMsR0FBSTtRQUNuQyxNQUFNLElBQUlxQixVQUFVO0lBQ3RCO0lBRUEsSUFBSSxPQUFPRCxXQUFXLFlBQVk7UUFDaEMs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LE1BQU1BLEtBQUssQ0FBQ3dFLFVBQVUsQ0FBQyxjQUMxQnhFLGlCQUFpQlosU0FDakI7WUFDQSxJQUFJLENBQUNhLElBQUksQ0FBQ0Q7UUFDWixPQUFPO1lBQ0wsSUFBSSxDQUFDQSxLQUFLLENBQUNBO1FBQ2I7SUFDRjtBQUNGO0FBRUF5RSxPQUFPQyxPQUFPLEdBQUd2RSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL3Bhc3Nwb3J0X3N0cmF0ZWd5LmpzPzJhZjgiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgdXJsID0gcmVxdWlyZSgndXJsJyk7XHJcbmNvbnN0IHsgZm9ybWF0IH0gPSByZXF1aXJlKCd1dGlsJyk7XHJcblxyXG5jb25zdCBjbG9uZURlZXAgPSByZXF1aXJlKCcuL2hlbHBlcnMvZGVlcF9jbG9uZScpO1xyXG5jb25zdCB7IFJQRXJyb3IsIE9QRXJyb3IgfSA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XHJcbmNvbnN0IHsgQmFzZUNsaWVudCB9ID0gcmVxdWlyZSgnLi9jbGllbnQnKTtcclxuY29uc3QgeyByYW5kb20sIGNvZGVDaGFsbGVuZ2UgfSA9IHJlcXVpcmUoJy4vaGVscGVycy9nZW5lcmF0b3JzJyk7XHJcbmNvbnN0IHBpY2sgPSByZXF1aXJlKCcuL2hlbHBlcnMvcGljaycpO1xyXG5jb25zdCB7IHJlc29sdmVSZXNwb25zZVR5cGUsIHJlc29sdmVSZWRpcmVjdFVyaSB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2NsaWVudCcpO1xyXG5cclxuZnVuY3Rpb24gdmVyaWZpZWQoZXJyLCB1c2VyLCBpbmZvID0ge30pIHtcclxuICBpZiAoZXJyKSB7XHJcbiAgICB0aGlzLmVycm9yKGVycik7XHJcbiAgfSBlbHNlIGlmICghdXNlcikge1xyXG4gICAgdGhpcy5mYWlsKGluZm8pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLnN1Y2Nlc3ModXNlciwgaW5mbyk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBPcGVuSURDb25uZWN0U3RyYXRlZ3koXHJcbiAgeyBjbGllbnQsIHBhcmFtcyA9IHt9LCBwYXNzUmVxVG9DYWxsYmFjayA9IGZhbHNlLCBzZXNzaW9uS2V5LCB1c2VQS0NFID0gdHJ1ZSwgZXh0cmFzID0ge30gfSA9IHt9LFxyXG4gIHZlcmlmeSxcclxuKSB7XHJcbiAgaWYgKCEoY2xpZW50IGluc3RhbmNlb2YgQmFzZUNsaWVudCkpIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NsaWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIG9wZW5pZC1jbGllbnQgQ2xpZW50Jyk7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHZlcmlmeSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmVyaWZ5IGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFjbGllbnQuaXNzdWVyIHx8ICFjbGllbnQuaXNzdWVyLmlzc3Vlcikge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2xpZW50IG11c3QgaGF2ZSBhbiBpc3N1ZXIgd2l0aCBhbiBpZGVudGlmaWVyJyk7XHJcbiAgfVxyXG5cclxuICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XHJcbiAgdGhpcy5faXNzdWVyID0gY2xpZW50Lmlzc3VlcjtcclxuICB0aGlzLl92ZXJpZnkgPSB2ZXJpZnk7XHJcbiAgdGhpcy5fcGFzc1JlcVRvQ2FsbGJhY2sgPSBwYXNzUmVxVG9DYWxsYmFjaztcclxuICB0aGlzLl91c2VQS0NFID0gdXNlUEtDRTtcclxuICB0aGlzLl9rZXkgPSBzZXNzaW9uS2V5IHx8IGBvaWRjOiR7dXJsLnBhcnNlKHRoaXMuX2lzc3Vlci5pc3N1ZXIpLmhvc3RuYW1lfWA7XHJcbiAgdGhpcy5fcGFyYW1zID0gY2xvbmVEZWVwKHBhcmFtcyk7XHJcblxyXG4gIC8vIHN0YXRlIGFuZCBub25jZSBhcmUgaGFuZGxlZCBpbiBhdXRoZW50aWNhdGUoKVxyXG4gIGRlbGV0ZSB0aGlzLl9wYXJhbXMuc3RhdGU7XHJcbiAgZGVsZXRlIHRoaXMuX3BhcmFtcy5ub25jZTtcclxuXHJcbiAgdGhpcy5fZXh0cmFzID0gY2xvbmVEZWVwKGV4dHJhcyk7XHJcblxyXG4gIGlmICghdGhpcy5fcGFyYW1zLnJlc3BvbnNlX3R5cGUpIHRoaXMuX3BhcmFtcy5yZXNwb25zZV90eXBlID0gcmVzb2x2ZVJlc3BvbnNlVHlwZS5jYWxsKGNsaWVudCk7XHJcbiAgaWYgKCF0aGlzLl9wYXJhbXMucmVkaXJlY3RfdXJpKSB0aGlzLl9wYXJhbXMucmVkaXJlY3RfdXJpID0gcmVzb2x2ZVJlZGlyZWN0VXJpLmNhbGwoY2xpZW50KTtcclxuICBpZiAoIXRoaXMuX3BhcmFtcy5zY29wZSkgdGhpcy5fcGFyYW1zLnNjb3BlID0gJ29wZW5pZCc7XHJcblxyXG4gIGlmICh0aGlzLl91c2VQS0NFID09PSB0cnVlKSB7XHJcbiAgICBjb25zdCBzdXBwb3J0ZWRNZXRob2RzID0gQXJyYXkuaXNBcnJheSh0aGlzLl9pc3N1ZXIuY29kZV9jaGFsbGVuZ2VfbWV0aG9kc19zdXBwb3J0ZWQpXHJcbiAgICAgID8gdGhpcy5faXNzdWVyLmNvZGVfY2hhbGxlbmdlX21ldGhvZHNfc3VwcG9ydGVkXHJcbiAgICAgIDogZmFsc2U7XHJcblxyXG4gICAgaWYgKHN1cHBvcnRlZE1ldGhvZHMgJiYgc3VwcG9ydGVkTWV0aG9kcy5pbmNsdWRlcygnUzI1NicpKSB7XHJcbiAgICAgIHRoaXMuX3VzZVBLQ0UgPSAnUzI1Nic7XHJcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnRlZE1ldGhvZHMgJiYgc3VwcG9ydGVkTWV0aG9kcy5pbmNsdWRlcygncGxhaW4nKSkge1xyXG4gICAgICB0aGlzLl91c2VQS0NFID0gJ3BsYWluJztcclxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydGVkTWV0aG9kcykge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxyXG4gICAgICAgICduZWl0aGVyIGNvZGVfY2hhbGxlbmdlX21ldGhvZCBzdXBwb3J0ZWQgYnkgdGhlIGNsaWVudCBpcyBzdXBwb3J0ZWQgYnkgdGhlIGlzc3VlcicsXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl91c2VQS0NFID0gJ1MyNTYnO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX3VzZVBLQ0UgPT09ICdzdHJpbmcnICYmICFbJ3BsYWluJywgJ1MyNTYnXS5pbmNsdWRlcyh0aGlzLl91c2VQS0NFKSkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt0aGlzLl91c2VQS0NFfSBpcyBub3QgdmFsaWQvaW1wbGVtZW50ZWQgUEtDRSBjb2RlX2NoYWxsZW5nZV9tZXRob2RgKTtcclxuICB9XHJcblxyXG4gIHRoaXMubmFtZSA9IHVybC5wYXJzZShjbGllbnQuaXNzdWVyLmlzc3VlcikuaG9zdG5hbWU7XHJcbn1cclxuXHJcbk9wZW5JRENvbm5lY3RTdHJhdGVneS5wcm90b3R5cGUuYXV0aGVudGljYXRlID0gZnVuY3Rpb24gYXV0aGVudGljYXRlKHJlcSwgb3B0aW9ucykge1xyXG4gIChhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLl9jbGllbnQ7XHJcbiAgICBpZiAoIXJlcS5zZXNzaW9uKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F1dGhlbnRpY2F0aW9uIHJlcXVpcmVzIHNlc3Npb24gc3VwcG9ydCcpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVxUGFyYW1zID0gY2xpZW50LmNhbGxiYWNrUGFyYW1zKHJlcSk7XHJcbiAgICBjb25zdCBzZXNzaW9uS2V5ID0gdGhpcy5fa2V5O1xyXG5cclxuICAgIGNvbnN0IHsgMDogcGFyYW1ldGVyLCBsZW5ndGggfSA9IE9iamVjdC5rZXlzKHJlcVBhcmFtcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydCBhdXRoZW50aWNhdGlvbiByZXF1ZXN0IGlmIHRoaXMgaGFzIG5vIGF1dGhvcml6YXRpb24gcmVzcG9uc2UgcGFyYW1ldGVycyBvclxyXG4gICAgICogdGhpcyBtaWdodCBhIGxvZ2luIGluaXRpYXRlZCBmcm9tIGEgdGhpcmQgcGFydHkgYXMgcGVyXHJcbiAgICAgKiBodHRwczovL29wZW5pZC5uZXQvc3BlY3Mvb3BlbmlkLWNvbm5lY3QtY29yZS0xXzAuaHRtbCNUaGlyZFBhcnR5SW5pdGlhdGVkTG9naW4uXHJcbiAgICAgKi9cclxuICAgIGlmIChsZW5ndGggPT09IDAgfHwgKGxlbmd0aCA9PT0gMSAmJiBwYXJhbWV0ZXIgPT09ICdpc3MnKSkge1xyXG4gICAgICAvLyBwcm92aWRlIG9wdGlvbnMgb2JqZWN0IHdpdGggZXh0cmEgYXV0aGVudGljYXRpb24gcGFyYW1ldGVyc1xyXG4gICAgICBjb25zdCBwYXJhbXMgPSB7XHJcbiAgICAgICAgc3RhdGU6IHJhbmRvbSgpLFxyXG4gICAgICAgIC4uLnRoaXMuX3BhcmFtcyxcclxuICAgICAgICAuLi5vcHRpb25zLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgaWYgKCFwYXJhbXMubm9uY2UgJiYgcGFyYW1zLnJlc3BvbnNlX3R5cGUuaW5jbHVkZXMoJ2lkX3Rva2VuJykpIHtcclxuICAgICAgICBwYXJhbXMubm9uY2UgPSByYW5kb20oKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmVxLnNlc3Npb25bc2Vzc2lvbktleV0gPSBwaWNrKHBhcmFtcywgJ25vbmNlJywgJ3N0YXRlJywgJ21heF9hZ2UnLCAncmVzcG9uc2VfdHlwZScpO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX3VzZVBLQ0UgJiYgcGFyYW1zLnJlc3BvbnNlX3R5cGUuaW5jbHVkZXMoJ2NvZGUnKSkge1xyXG4gICAgICAgIGNvbnN0IHZlcmlmaWVyID0gcmFuZG9tKCk7XHJcbiAgICAgICAgcmVxLnNlc3Npb25bc2Vzc2lvbktleV0uY29kZV92ZXJpZmllciA9IHZlcmlmaWVyO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKHRoaXMuX3VzZVBLQ0UpIHtcclxuICAgICAgICAgIGNhc2UgJ1MyNTYnOlxyXG4gICAgICAgICAgICBwYXJhbXMuY29kZV9jaGFsbGVuZ2UgPSBjb2RlQ2hhbGxlbmdlKHZlcmlmaWVyKTtcclxuICAgICAgICAgICAgcGFyYW1zLmNvZGVfY2hhbGxlbmdlX21ldGhvZCA9ICdTMjU2JztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdwbGFpbic6XHJcbiAgICAgICAgICAgIHBhcmFtcy5jb2RlX2NoYWxsZW5nZSA9IHZlcmlmaWVyO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMucmVkaXJlY3QoY2xpZW50LmF1dGhvcml6YXRpb25VcmwocGFyYW1zKSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8qIGVuZCBhdXRoZW50aWNhdGlvbiByZXF1ZXN0ICovXHJcblxyXG4gICAgLyogc3RhcnQgYXV0aGVudGljYXRpb24gcmVzcG9uc2UgKi9cclxuXHJcbiAgICBjb25zdCBzZXNzaW9uID0gcmVxLnNlc3Npb25bc2Vzc2lvbktleV07XHJcbiAgICBpZiAoT2JqZWN0LmtleXMoc2Vzc2lvbiB8fCB7fSkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBmb3JtYXQoXHJcbiAgICAgICAgICAnZGlkIG5vdCBmaW5kIGV4cGVjdGVkIGF1dGhvcml6YXRpb24gcmVxdWVzdCBkZXRhaWxzIGluIHNlc3Npb24sIHJlcS5zZXNzaW9uW1wiJXNcIl0gaXMgJWonLFxyXG4gICAgICAgICAgc2Vzc2lvbktleSxcclxuICAgICAgICAgIHNlc3Npb24sXHJcbiAgICAgICAgKSxcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHN0YXRlLFxyXG4gICAgICBub25jZSxcclxuICAgICAgbWF4X2FnZTogbWF4QWdlLFxyXG4gICAgICBjb2RlX3ZlcmlmaWVyOiBjb2RlVmVyaWZpZXIsXHJcbiAgICAgIHJlc3BvbnNlX3R5cGU6IHJlc3BvbnNlVHlwZSxcclxuICAgIH0gPSBzZXNzaW9uO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGRlbGV0ZSByZXEuc2Vzc2lvbltzZXNzaW9uS2V5XTtcclxuICAgIH0gY2F0Y2ggKGVycikge31cclxuXHJcbiAgICBjb25zdCBvcHRzID0ge1xyXG4gICAgICByZWRpcmVjdF91cmk6IHRoaXMuX3BhcmFtcy5yZWRpcmVjdF91cmksXHJcbiAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGNoZWNrcyA9IHtcclxuICAgICAgc3RhdGUsXHJcbiAgICAgIG5vbmNlLFxyXG4gICAgICBtYXhfYWdlOiBtYXhBZ2UsXHJcbiAgICAgIGNvZGVfdmVyaWZpZXI6IGNvZGVWZXJpZmllcixcclxuICAgICAgcmVzcG9uc2VfdHlwZTogcmVzcG9uc2VUeXBlLFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCB0b2tlbnNldCA9IGF3YWl0IGNsaWVudC5jYWxsYmFjayhvcHRzLnJlZGlyZWN0X3VyaSwgcmVxUGFyYW1zLCBjaGVja3MsIHRoaXMuX2V4dHJhcyk7XHJcblxyXG4gICAgY29uc3QgcGFzc1JlcSA9IHRoaXMuX3Bhc3NSZXFUb0NhbGxiYWNrO1xyXG4gICAgY29uc3QgbG9hZFVzZXJpbmZvID0gdGhpcy5fdmVyaWZ5Lmxlbmd0aCA+IChwYXNzUmVxID8gMyA6IDIpICYmIGNsaWVudC5pc3N1ZXIudXNlcmluZm9fZW5kcG9pbnQ7XHJcblxyXG4gICAgY29uc3QgYXJncyA9IFt0b2tlbnNldCwgdmVyaWZpZWQuYmluZCh0aGlzKV07XHJcblxyXG4gICAgaWYgKGxvYWRVc2VyaW5mbykge1xyXG4gICAgICBpZiAoIXRva2Vuc2V0LmFjY2Vzc190b2tlbikge1xyXG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcclxuICAgICAgICAgIG1lc3NhZ2U6XHJcbiAgICAgICAgICAgICdleHBlY3RlZCBhY2Nlc3NfdG9rZW4gdG8gYmUgcmV0dXJuZWQgd2hlbiBhc2tpbmcgZm9yIHVzZXJpbmZvIGluIHZlcmlmeSBjYWxsYmFjaycsXHJcbiAgICAgICAgICB0b2tlbnNldCxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCB1c2VyaW5mbyA9IGF3YWl0IGNsaWVudC51c2VyaW5mbyh0b2tlbnNldCk7XHJcbiAgICAgIGFyZ3Muc3BsaWNlKDEsIDAsIHVzZXJpbmZvKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocGFzc1JlcSkge1xyXG4gICAgICBhcmdzLnVuc2hpZnQocmVxKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl92ZXJpZnkoLi4uYXJncyk7XHJcbiAgICAvKiBlbmQgYXV0aGVudGljYXRpb24gcmVzcG9uc2UgKi9cclxuICB9KSgpLmNhdGNoKChlcnJvcikgPT4ge1xyXG4gICAgaWYgKFxyXG4gICAgICAoZXJyb3IgaW5zdGFuY2VvZiBPUEVycm9yICYmXHJcbiAgICAgICAgZXJyb3IuZXJyb3IgIT09ICdzZXJ2ZXJfZXJyb3InICYmXHJcbiAgICAgICAgIWVycm9yLmVycm9yLnN0YXJ0c1dpdGgoJ2ludmFsaWQnKSkgfHxcclxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBSUEVycm9yXHJcbiAgICApIHtcclxuICAgICAgdGhpcy5mYWlsKGVycm9yKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuZXJyb3IoZXJyb3IpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPcGVuSURDb25uZWN0U3RyYXRlZ3k7XHJcbiJdLCJuYW1lcyI6WyJ1cmwiLCJyZXF1aXJlIiwiZm9ybWF0IiwiY2xvbmVEZWVwIiwiUlBFcnJvciIsIk9QRXJyb3IiLCJCYXNlQ2xpZW50IiwicmFuZG9tIiwiY29kZUNoYWxsZW5nZSIsInBpY2siLCJyZXNvbHZlUmVzcG9uc2VUeXBlIiwicmVzb2x2ZVJlZGlyZWN0VXJpIiwidmVyaWZpZWQiLCJlcnIiLCJ1c2VyIiwiaW5mbyIsImVycm9yIiwiZmFpbCIsInN1Y2Nlc3MiLCJPcGVuSURDb25uZWN0U3RyYXRlZ3kiLCJjbGllbnQiLCJwYXJhbXMiLCJwYXNzUmVxVG9DYWxsYmFjayIsInNlc3Npb25LZXkiLCJ1c2VQS0NFIiwiZXh0cmFzIiwidmVyaWZ5IiwiVHlwZUVycm9yIiwiaXNzdWVyIiwiX2NsaWVudCIsIl9pc3N1ZXIiLCJfdmVyaWZ5IiwiX3Bhc3NSZXFUb0NhbGxiYWNrIiwiX3VzZVBLQ0UiLCJfa2V5IiwicGFyc2UiLCJob3N0bmFtZSIsIl9wYXJhbXMiLCJzdGF0ZSIsIm5vbmNlIiwiX2V4dHJhcyIsInJlc3BvbnNlX3R5cGUiLCJjYWxsIiwicmVkaXJlY3RfdXJpIiwic2NvcGUiLCJzdXBwb3J0ZWRNZXRob2RzIiwiQXJyYXkiLCJpc0FycmF5IiwiY29kZV9jaGFsbGVuZ2VfbWV0aG9kc19zdXBwb3J0ZWQiLCJpbmNsdWRlcyIsIm5hbWUiLCJwcm90b3R5cGUiLCJhdXRoZW50aWNhdGUiLCJyZXEiLCJvcHRpb25zIiwic2Vzc2lvbiIsInJlcVBhcmFtcyIsImNhbGxiYWNrUGFyYW1zIiwicGFyYW1ldGVyIiwibGVuZ3RoIiwiT2JqZWN0Iiwia2V5cyIsInZlcmlmaWVyIiwiY29kZV92ZXJpZmllciIsImNvZGVfY2hhbGxlbmdlIiwiY29kZV9jaGFsbGVuZ2VfbWV0aG9kIiwicmVkaXJlY3QiLCJhdXRob3JpemF0aW9uVXJsIiwiRXJyb3IiLCJtYXhfYWdlIiwibWF4QWdlIiwiY29kZVZlcmlmaWVyIiwicmVzcG9uc2VUeXBlIiwib3B0cyIsImNoZWNrcyIsInRva2Vuc2V0IiwiY2FsbGJhY2siLCJwYXNzUmVxIiwibG9hZFVzZXJpbmZvIiwidXNlcmluZm9fZW5kcG9pbnQiLCJhcmdzIiwiYmluZCIsImFjY2Vzc190b2tlbiIsIm1lc3NhZ2UiLCJ1c2VyaW5mbyIsInNwbGljZSIsInVuc2hpZnQiLCJjYXRjaCIsInN0YXJ0c1dpdGgiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/passport_strategy.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/lib/token_set.js":
/*!*****************************************************!*\
  !*** ./node_modules/openid-client/lib/token_set.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const base64url = __webpack_require__(/*! ./helpers/base64url */ \"(rsc)/./node_modules/openid-client/lib/helpers/base64url.js\");\nconst now = __webpack_require__(/*! ./helpers/unix_timestamp */ \"(rsc)/./node_modules/openid-client/lib/helpers/unix_timestamp.js\");\nclass TokenSet {\n    constructor(values){\n        Object.assign(this, values);\n        const { constructor, ...properties } = Object.getOwnPropertyDescriptors(this.constructor.prototype);\n        Object.defineProperties(this, properties);\n    }\n    set expires_in(value) {\n        this.expires_at = now() + Number(value);\n    }\n    get expires_in() {\n        return Math.max.apply(null, [\n            this.expires_at - now(),\n            0\n        ]);\n    }\n    expired() {\n        return this.expires_in === 0;\n    }\n    claims() {\n        if (!this.id_token) {\n            throw new TypeError(\"id_token not present in TokenSet\");\n        }\n        return JSON.parse(base64url.decode(this.id_token.split(\".\")[1]));\n    }\n}\nmodule.exports = TokenSet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvdG9rZW5fc2V0LmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLFlBQVlDLG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1DLE1BQU1ELG1CQUFPQSxDQUFDO0FBRXBCLE1BQU1FO0lBQ0pDLFlBQVlDLE1BQU0sQ0FBRTtRQUNsQkMsT0FBT0MsTUFBTSxDQUFDLElBQUksRUFBRUY7UUFDcEIsTUFBTSxFQUFFRCxXQUFXLEVBQUUsR0FBR0ksWUFBWSxHQUFHRixPQUFPRyx5QkFBeUIsQ0FDckUsSUFBSSxDQUFDTCxXQUFXLENBQUNNLFNBQVM7UUFHNUJKLE9BQU9LLGdCQUFnQixDQUFDLElBQUksRUFBRUg7SUFDaEM7SUFFQSxJQUFJSSxXQUFXQyxLQUFLLEVBQUU7UUFDcEIsSUFBSSxDQUFDQyxVQUFVLEdBQUdaLFFBQVFhLE9BQU9GO0lBQ25DO0lBRUEsSUFBSUQsYUFBYTtRQUNmLE9BQU9JLEtBQUtDLEdBQUcsQ0FBQ0MsS0FBSyxDQUFDLE1BQU07WUFBQyxJQUFJLENBQUNKLFVBQVUsR0FBR1o7WUFBTztTQUFFO0lBQzFEO0lBRUFpQixVQUFVO1FBQ1IsT0FBTyxJQUFJLENBQUNQLFVBQVUsS0FBSztJQUM3QjtJQUVBUSxTQUFTO1FBQ1AsSUFBSSxDQUFDLElBQUksQ0FBQ0MsUUFBUSxFQUFFO1lBQ2xCLE1BQU0sSUFBSUMsVUFBVTtRQUN0QjtRQUVBLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ3hCLFVBQVV5QixNQUFNLENBQUMsSUFBSSxDQUFDSixRQUFRLENBQUNLLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtJQUNoRTtBQUNGO0FBRUFDLE9BQU9DLE9BQU8sR0FBR3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvdG9rZW5fc2V0LmpzPzI4M2IiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYmFzZTY0dXJsID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Jhc2U2NHVybCcpO1xyXG5jb25zdCBub3cgPSByZXF1aXJlKCcuL2hlbHBlcnMvdW5peF90aW1lc3RhbXAnKTtcclxuXHJcbmNsYXNzIFRva2VuU2V0IHtcclxuICBjb25zdHJ1Y3Rvcih2YWx1ZXMpIHtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgdmFsdWVzKTtcclxuICAgIGNvbnN0IHsgY29uc3RydWN0b3IsIC4uLnByb3BlcnRpZXMgfSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKFxyXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSxcclxuICAgICk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywgcHJvcGVydGllcyk7XHJcbiAgfVxyXG5cclxuICBzZXQgZXhwaXJlc19pbih2YWx1ZSkge1xyXG4gICAgdGhpcy5leHBpcmVzX2F0ID0gbm93KCkgKyBOdW1iZXIodmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGV4cGlyZXNfaW4oKSB7XHJcbiAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgW3RoaXMuZXhwaXJlc19hdCAtIG5vdygpLCAwXSk7XHJcbiAgfVxyXG5cclxuICBleHBpcmVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZXhwaXJlc19pbiA9PT0gMDtcclxuICB9XHJcblxyXG4gIGNsYWltcygpIHtcclxuICAgIGlmICghdGhpcy5pZF90b2tlbikge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpZF90b2tlbiBub3QgcHJlc2VudCBpbiBUb2tlblNldCcpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBKU09OLnBhcnNlKGJhc2U2NHVybC5kZWNvZGUodGhpcy5pZF90b2tlbi5zcGxpdCgnLicpWzFdKSk7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRva2VuU2V0O1xyXG4iXSwibmFtZXMiOlsiYmFzZTY0dXJsIiwicmVxdWlyZSIsIm5vdyIsIlRva2VuU2V0IiwiY29uc3RydWN0b3IiLCJ2YWx1ZXMiLCJPYmplY3QiLCJhc3NpZ24iLCJwcm9wZXJ0aWVzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsInByb3RvdHlwZSIsImRlZmluZVByb3BlcnRpZXMiLCJleHBpcmVzX2luIiwidmFsdWUiLCJleHBpcmVzX2F0IiwiTnVtYmVyIiwiTWF0aCIsIm1heCIsImFwcGx5IiwiZXhwaXJlZCIsImNsYWltcyIsImlkX3Rva2VuIiwiVHlwZUVycm9yIiwiSlNPTiIsInBhcnNlIiwiZGVjb2RlIiwic3BsaXQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/lib/token_set.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/node_modules/object-hash/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/openid-client/node_modules/object-hash/index.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\n/**\r\n * Exported function\r\n *\r\n * Options:\r\n *\r\n *  - `algorithm` hash algo to be used by this instance: *'sha1', 'md5'\r\n *  - `excludeValues` {true|*false} hash object keys, values ignored\r\n *  - `encoding` hash encoding, supports 'buffer', '*hex', 'binary', 'base64'\r\n *  - `ignoreUnknown` {true|*false} ignore unknown object types\r\n *  - `replacer` optional function that replaces values before hashing\r\n *  - `respectFunctionProperties` {*true|false} consider function properties when hashing\r\n *  - `respectFunctionNames` {*true|false} consider 'name' property of functions for hashing\r\n *  - `respectType` {*true|false} Respect special properties (prototype, constructor)\r\n *    when hashing to distinguish between types\r\n *  - `unorderedArrays` {true|*false} Sort all arrays before hashing\r\n *  - `unorderedSets` {*true|false} Sort `Set` and `Map` instances before hashing\r\n *  * = default\r\n *\r\n * @param {object} object value to hash\r\n * @param {object} options hashing options\r\n * @return {string} hash value\r\n * @api public\r\n */ exports = module.exports = objectHash;\nfunction objectHash(object, options) {\n    options = applyDefaults(object, options);\n    return hash(object, options);\n}\n/**\r\n * Exported sugar methods\r\n *\r\n * @param {object} object value to hash\r\n * @return {string} hash value\r\n * @api public\r\n */ exports.sha1 = function(object) {\n    return objectHash(object);\n};\nexports.keys = function(object) {\n    return objectHash(object, {\n        excludeValues: true,\n        algorithm: \"sha1\",\n        encoding: \"hex\"\n    });\n};\nexports.MD5 = function(object) {\n    return objectHash(object, {\n        algorithm: \"md5\",\n        encoding: \"hex\"\n    });\n};\nexports.keysMD5 = function(object) {\n    return objectHash(object, {\n        algorithm: \"md5\",\n        encoding: \"hex\",\n        excludeValues: true\n    });\n};\n// Internals\nvar hashes = crypto.getHashes ? crypto.getHashes().slice() : [\n    \"sha1\",\n    \"md5\"\n];\nhashes.push(\"passthrough\");\nvar encodings = [\n    \"buffer\",\n    \"hex\",\n    \"binary\",\n    \"base64\"\n];\nfunction applyDefaults(object, sourceOptions) {\n    sourceOptions = sourceOptions || {};\n    // create a copy rather than mutating\n    var options = {};\n    options.algorithm = sourceOptions.algorithm || \"sha1\";\n    options.encoding = sourceOptions.encoding || \"hex\";\n    options.excludeValues = sourceOptions.excludeValues ? true : false;\n    options.algorithm = options.algorithm.toLowerCase();\n    options.encoding = options.encoding.toLowerCase();\n    options.ignoreUnknown = sourceOptions.ignoreUnknown !== true ? false : true; // default to false\n    options.respectType = sourceOptions.respectType === false ? false : true; // default to true\n    options.respectFunctionNames = sourceOptions.respectFunctionNames === false ? false : true;\n    options.respectFunctionProperties = sourceOptions.respectFunctionProperties === false ? false : true;\n    options.unorderedArrays = sourceOptions.unorderedArrays !== true ? false : true; // default to false\n    options.unorderedSets = sourceOptions.unorderedSets === false ? false : true; // default to false\n    options.unorderedObjects = sourceOptions.unorderedObjects === false ? false : true; // default to true\n    options.replacer = sourceOptions.replacer || undefined;\n    options.excludeKeys = sourceOptions.excludeKeys || undefined;\n    if (typeof object === \"undefined\") {\n        throw new Error(\"Object argument required.\");\n    }\n    // if there is a case-insensitive match in the hashes list, accept it\n    // (i.e. SHA256 for sha256)\n    for(var i = 0; i < hashes.length; ++i){\n        if (hashes[i].toLowerCase() === options.algorithm.toLowerCase()) {\n            options.algorithm = hashes[i];\n        }\n    }\n    if (hashes.indexOf(options.algorithm) === -1) {\n        throw new Error('Algorithm \"' + options.algorithm + '\"  not supported. ' + \"supported values: \" + hashes.join(\", \"));\n    }\n    if (encodings.indexOf(options.encoding) === -1 && options.algorithm !== \"passthrough\") {\n        throw new Error('Encoding \"' + options.encoding + '\"  not supported. ' + \"supported values: \" + encodings.join(\", \"));\n    }\n    return options;\n}\n/** Check if the given function is a native function */ function isNativeFunction(f) {\n    if (typeof f !== \"function\") {\n        return false;\n    }\n    var exp = /^function\\s+\\w*\\s*\\(\\s*\\)\\s*{\\s+\\[native code\\]\\s+}$/i;\n    return exp.exec(Function.prototype.toString.call(f)) != null;\n}\nfunction hash(object, options) {\n    var hashingStream;\n    if (options.algorithm !== \"passthrough\") {\n        hashingStream = crypto.createHash(options.algorithm);\n    } else {\n        hashingStream = new PassThrough();\n    }\n    if (typeof hashingStream.write === \"undefined\") {\n        hashingStream.write = hashingStream.update;\n        hashingStream.end = hashingStream.update;\n    }\n    var hasher = typeHasher(options, hashingStream);\n    hasher.dispatch(object);\n    if (!hashingStream.update) {\n        hashingStream.end(\"\");\n    }\n    if (hashingStream.digest) {\n        return hashingStream.digest(options.encoding === \"buffer\" ? undefined : options.encoding);\n    }\n    var buf = hashingStream.read();\n    if (options.encoding === \"buffer\") {\n        return buf;\n    }\n    return buf.toString(options.encoding);\n}\n/**\r\n * Expose streaming API\r\n *\r\n * @param {object} object  Value to serialize\r\n * @param {object} options  Options, as for hash()\r\n * @param {object} stream  A stream to write the serializiation to\r\n * @api public\r\n */ exports.writeToStream = function(object, options, stream) {\n    if (typeof stream === \"undefined\") {\n        stream = options;\n        options = {};\n    }\n    options = applyDefaults(object, options);\n    return typeHasher(options, stream).dispatch(object);\n};\nfunction typeHasher(options, writeTo, context) {\n    context = context || [];\n    var write = function(str) {\n        if (writeTo.update) {\n            return writeTo.update(str, \"utf8\");\n        } else {\n            return writeTo.write(str, \"utf8\");\n        }\n    };\n    return {\n        dispatch: function(value) {\n            if (options.replacer) {\n                value = options.replacer(value);\n            }\n            var type = typeof value;\n            if (value === null) {\n                type = \"null\";\n            }\n            //console.log(\"[DEBUG] Dispatch: \", value, \"->\", type, \" -> \", \"_\" + type);\n            return this[\"_\" + type](value);\n        },\n        _object: function(object) {\n            var pattern = /\\[object (.*)\\]/i;\n            var objString = Object.prototype.toString.call(object);\n            var objType = pattern.exec(objString);\n            if (!objType) {\n                objType = \"unknown:[\" + objString + \"]\";\n            } else {\n                objType = objType[1]; // take only the class name\n            }\n            objType = objType.toLowerCase();\n            var objectNumber = null;\n            if ((objectNumber = context.indexOf(object)) >= 0) {\n                return this.dispatch(\"[CIRCULAR:\" + objectNumber + \"]\");\n            } else {\n                context.push(object);\n            }\n            if (typeof Buffer !== \"undefined\" && Buffer.isBuffer && Buffer.isBuffer(object)) {\n                write(\"buffer:\");\n                return write(object);\n            }\n            if (objType !== \"object\" && objType !== \"function\" && objType !== \"asyncfunction\") {\n                if (this[\"_\" + objType]) {\n                    this[\"_\" + objType](object);\n                } else if (options.ignoreUnknown) {\n                    return write(\"[\" + objType + \"]\");\n                } else {\n                    throw new Error('Unknown object type \"' + objType + '\"');\n                }\n            } else {\n                var keys = Object.keys(object);\n                if (options.unorderedObjects) {\n                    keys = keys.sort();\n                }\n                // Make sure to incorporate special properties, so\n                // Types with different prototypes will produce\n                // a different hash and objects derived from\n                // different functions (`new Foo`, `new Bar`) will\n                // produce different hashes.\n                // We never do this for native functions since some\n                // seem to break because of that.\n                if (options.respectType !== false && !isNativeFunction(object)) {\n                    keys.splice(0, 0, \"prototype\", \"__proto__\", \"constructor\");\n                }\n                if (options.excludeKeys) {\n                    keys = keys.filter(function(key) {\n                        return !options.excludeKeys(key);\n                    });\n                }\n                write(\"object:\" + keys.length + \":\");\n                var self = this;\n                return keys.forEach(function(key) {\n                    self.dispatch(key);\n                    write(\":\");\n                    if (!options.excludeValues) {\n                        self.dispatch(object[key]);\n                    }\n                    write(\",\");\n                });\n            }\n        },\n        _array: function(arr, unordered) {\n            unordered = typeof unordered !== \"undefined\" ? unordered : options.unorderedArrays !== false; // default to options.unorderedArrays\n            var self = this;\n            write(\"array:\" + arr.length + \":\");\n            if (!unordered || arr.length <= 1) {\n                return arr.forEach(function(entry) {\n                    return self.dispatch(entry);\n                });\n            }\n            // the unordered case is a little more complicated:\n            // since there is no canonical ordering on objects,\n            // i.e. {a:1} < {a:2} and {a:1} > {a:2} are both false,\n            // we first serialize each entry using a PassThrough stream\n            // before sorting.\n            // also: we cant use the same context array for all entries\n            // since the order of hashing should *not* matter. instead,\n            // we keep track of the additions to a copy of the context array\n            // and add all of them to the global context array when were done\n            var contextAdditions = [];\n            var entries = arr.map(function(entry) {\n                var strm = new PassThrough();\n                var localContext = context.slice(); // make copy\n                var hasher = typeHasher(options, strm, localContext);\n                hasher.dispatch(entry);\n                // take only what was added to localContext and append it to contextAdditions\n                contextAdditions = contextAdditions.concat(localContext.slice(context.length));\n                return strm.read().toString();\n            });\n            context = context.concat(contextAdditions);\n            entries.sort();\n            return this._array(entries, false);\n        },\n        _date: function(date) {\n            return write(\"date:\" + date.toJSON());\n        },\n        _symbol: function(sym) {\n            return write(\"symbol:\" + sym.toString());\n        },\n        _error: function(err) {\n            return write(\"error:\" + err.toString());\n        },\n        _boolean: function(bool) {\n            return write(\"bool:\" + bool.toString());\n        },\n        _string: function(string) {\n            write(\"string:\" + string.length + \":\");\n            write(string.toString());\n        },\n        _function: function(fn) {\n            write(\"fn:\");\n            if (isNativeFunction(fn)) {\n                this.dispatch(\"[native]\");\n            } else {\n                this.dispatch(fn.toString());\n            }\n            if (options.respectFunctionNames !== false) {\n                // Make sure we can still distinguish native functions\n                // by their name, otherwise String and Function will\n                // have the same hash\n                this.dispatch(\"function-name:\" + String(fn.name));\n            }\n            if (options.respectFunctionProperties) {\n                this._object(fn);\n            }\n        },\n        _number: function(number) {\n            return write(\"number:\" + number.toString());\n        },\n        _xml: function(xml) {\n            return write(\"xml:\" + xml.toString());\n        },\n        _null: function() {\n            return write(\"Null\");\n        },\n        _undefined: function() {\n            return write(\"Undefined\");\n        },\n        _regexp: function(regex) {\n            return write(\"regex:\" + regex.toString());\n        },\n        _uint8array: function(arr) {\n            write(\"uint8array:\");\n            return this.dispatch(Array.prototype.slice.call(arr));\n        },\n        _uint8clampedarray: function(arr) {\n            write(\"uint8clampedarray:\");\n            return this.dispatch(Array.prototype.slice.call(arr));\n        },\n        _int8array: function(arr) {\n            write(\"uint8array:\");\n            return this.dispatch(Array.prototype.slice.call(arr));\n        },\n        _uint16array: function(arr) {\n            write(\"uint16array:\");\n            return this.dispatch(Array.prototype.slice.call(arr));\n        },\n        _int16array: function(arr) {\n            write(\"uint16array:\");\n            return this.dispatch(Array.prototype.slice.call(arr));\n        },\n        _uint32array: function(arr) {\n            write(\"uint32array:\");\n            return this.dispatch(Array.prototype.slice.call(arr));\n        },\n        _int32array: function(arr) {\n            write(\"uint32array:\");\n            return this.dispatch(Array.prototype.slice.call(arr));\n        },\n        _float32array: function(arr) {\n            write(\"float32array:\");\n            return this.dispatch(Array.prototype.slice.call(arr));\n        },\n        _float64array: function(arr) {\n            write(\"float64array:\");\n            return this.dispatch(Array.prototype.slice.call(arr));\n        },\n        _arraybuffer: function(arr) {\n            write(\"arraybuffer:\");\n            return this.dispatch(new Uint8Array(arr));\n        },\n        _url: function(url) {\n            return write(\"url:\" + url.toString(), \"utf8\");\n        },\n        _map: function(map) {\n            write(\"map:\");\n            var arr = Array.from(map);\n            return this._array(arr, options.unorderedSets !== false);\n        },\n        _set: function(set) {\n            write(\"set:\");\n            var arr = Array.from(set);\n            return this._array(arr, options.unorderedSets !== false);\n        },\n        _file: function(file) {\n            write(\"file:\");\n            return this.dispatch([\n                file.name,\n                file.size,\n                file.type,\n                file.lastModfied\n            ]);\n        },\n        _blob: function() {\n            if (options.ignoreUnknown) {\n                return write(\"[blob]\");\n            }\n            throw Error(\"Hashing Blob objects is currently not supported\\n\" + \"(see https://github.com/puleos/object-hash/issues/26)\\n\" + 'Use \"options.replacer\" or \"options.ignoreUnknown\"\\n');\n        },\n        _domwindow: function() {\n            return write(\"domwindow\");\n        },\n        _bigint: function(number) {\n            return write(\"bigint:\" + number.toString());\n        },\n        /* Node.js standard native objects */ _process: function() {\n            return write(\"process\");\n        },\n        _timer: function() {\n            return write(\"timer\");\n        },\n        _pipe: function() {\n            return write(\"pipe\");\n        },\n        _tcp: function() {\n            return write(\"tcp\");\n        },\n        _udp: function() {\n            return write(\"udp\");\n        },\n        _tty: function() {\n            return write(\"tty\");\n        },\n        _statwatcher: function() {\n            return write(\"statwatcher\");\n        },\n        _securecontext: function() {\n            return write(\"securecontext\");\n        },\n        _connection: function() {\n            return write(\"connection\");\n        },\n        _zlib: function() {\n            return write(\"zlib\");\n        },\n        _context: function() {\n            return write(\"context\");\n        },\n        _nodescript: function() {\n            return write(\"nodescript\");\n        },\n        _httpparser: function() {\n            return write(\"httpparser\");\n        },\n        _dataview: function() {\n            return write(\"dataview\");\n        },\n        _signal: function() {\n            return write(\"signal\");\n        },\n        _fsevent: function() {\n            return write(\"fsevent\");\n        },\n        _tlswrap: function() {\n            return write(\"tlswrap\");\n        }\n    };\n}\n// Mini-implementation of stream.PassThrough\n// We are far from having need for the full implementation, and we can\n// make assumptions like \"many writes, then only one final read\"\n// and we can ignore encoding specifics\nfunction PassThrough() {\n    return {\n        buf: \"\",\n        write: function(b) {\n            this.buf += b;\n        },\n        end: function(b) {\n            this.buf += b;\n        },\n        read: function() {\n            return this.buf;\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9ub2RlX21vZHVsZXMvb2JqZWN0LWhhc2gvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUVyQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQyxHQUNEQyxVQUFVQyxPQUFPRCxPQUFPLEdBQUdFO0FBRTNCLFNBQVNBLFdBQVdDLE1BQU0sRUFBRUMsT0FBTztJQUNqQ0EsVUFBVUMsY0FBY0YsUUFBUUM7SUFFaEMsT0FBT0UsS0FBS0gsUUFBUUM7QUFDdEI7QUFFQTs7Ozs7O0NBTUMsR0FDREosWUFBWSxHQUFHLFNBQVNHLE1BQU07SUFDNUIsT0FBT0QsV0FBV0M7QUFDcEI7QUFDQUgsWUFBWSxHQUFHLFNBQVNHLE1BQU07SUFDNUIsT0FBT0QsV0FBV0MsUUFBUTtRQUFDTSxlQUFlO1FBQU1DLFdBQVc7UUFBUUMsVUFBVTtJQUFLO0FBQ3BGO0FBQ0FYLFdBQVcsR0FBRyxTQUFTRyxNQUFNO0lBQzNCLE9BQU9ELFdBQVdDLFFBQVE7UUFBQ08sV0FBVztRQUFPQyxVQUFVO0lBQUs7QUFDOUQ7QUFDQVgsZUFBZSxHQUFHLFNBQVNHLE1BQU07SUFDL0IsT0FBT0QsV0FBV0MsUUFBUTtRQUFDTyxXQUFXO1FBQU9DLFVBQVU7UUFBT0YsZUFBZTtJQUFJO0FBQ25GO0FBRUEsWUFBWTtBQUNaLElBQUlLLFNBQVNoQixPQUFPaUIsU0FBUyxHQUFHakIsT0FBT2lCLFNBQVMsR0FBR0MsS0FBSyxLQUFLO0lBQUM7SUFBUTtDQUFNO0FBQzVFRixPQUFPRyxJQUFJLENBQUM7QUFDWixJQUFJQyxZQUFZO0lBQUM7SUFBVTtJQUFPO0lBQVU7Q0FBUztBQUVyRCxTQUFTYixjQUFjRixNQUFNLEVBQUVnQixhQUFhO0lBQzFDQSxnQkFBZ0JBLGlCQUFpQixDQUFDO0lBRWxDLHFDQUFxQztJQUNyQyxJQUFJZixVQUFVLENBQUM7SUFDZkEsUUFBUU0sU0FBUyxHQUFHUyxj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QUFNO1FBQVE7UUFDeEM4RixjQUFjO1lBQWEsT0FBTzlGLE1BQU07UUFBZ0I7UUFDeEQrRixnQkFBZ0I7WUFBYSxPQUFPL0YsTUFBTTtRQUFrQjtRQUM1RGdHLGFBQWE7WUFBYSxPQUFPaEcsTUFBTTtRQUFlO1FBQ3REaUcsT0FBTztZQUFhLE9BQU9qRyxNQUFNO1FBQVM7UUFDMUNrRyxVQUFVO1lBQWEsT0FBT2xHLE1BQU07UUFBWTtRQUNoRG1HLGFBQWE7WUFBYSxPQUFPbkcsTUFBTTtRQUFlO1FBQ3REb0csYUFBYTtZQUFhLE9BQU9wRyxNQUFNO1FBQWU7UUFDdERxRyxXQUFXO1lBQWEsT0FBT3JHLE1BQU07UUFBYTtRQUNsRHNHLFNBQVM7WUFBYSxPQUFPdEcsTUFBTTtRQUFXO1FBQzlDdUcsVUFBVTtZQUFhLE9BQU92RyxNQUFNO1FBQVk7UUFDaER3RyxVQUFVO1lBQWEsT0FBT3hHLE1BQU07UUFBWTtJQUNsRDtBQUNGO0FBRUEsNENBQTRDO0FBQzVDLHNFQUFzRTtBQUN0RSxnRUFBZ0U7QUFDaEUsdUNBQXVDO0FBQ3ZDLFNBQVNEO0lBQ1AsT0FBTztRQUNMUSxLQUFLO1FBRUxQLE9BQU8sU0FBU3lHLENBQUM7WUFDZixJQUFJLENBQUNsRyxHQUFHLElBQUlrRztRQUNkO1FBRUF2RyxLQUFLLFNBQVN1RyxDQUFDO1lBQ2IsSUFBSSxDQUFDbEcsR0FBRyxJQUFJa0c7UUFDZDtRQUVBakcsTUFBTTtZQUNKLE9BQU8sSUFBSSxDQUFDRCxHQUFHO1FBQ2pCO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbm9kZV9tb2R1bGVzL29iamVjdC1oYXNoL2luZGV4LmpzP2FkMTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xyXG5cclxuLyoqXHJcbiAqIEV4cG9ydGVkIGZ1bmN0aW9uXHJcbiAqXHJcbiAqIE9wdGlvbnM6XHJcbiAqXHJcbiAqICAtIGBhbGdvcml0aG1gIGhhc2ggYWxnbyB0byBiZSB1c2VkIGJ5IHRoaXMgaW5zdGFuY2U6IConc2hhMScsICdtZDUnXHJcbiAqICAtIGBleGNsdWRlVmFsdWVzYCB7dHJ1ZXwqZmFsc2V9IGhhc2ggb2JqZWN0IGtleXMsIHZhbHVlcyBpZ25vcmVkXHJcbiAqICAtIGBlbmNvZGluZ2AgaGFzaCBlbmNvZGluZywgc3VwcG9ydHMgJ2J1ZmZlcicsICcqaGV4JywgJ2JpbmFyeScsICdiYXNlNjQnXHJcbiAqICAtIGBpZ25vcmVVbmtub3duYCB7dHJ1ZXwqZmFsc2V9IGlnbm9yZSB1bmtub3duIG9iamVjdCB0eXBlc1xyXG4gKiAgLSBgcmVwbGFjZXJgIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgcmVwbGFjZXMgdmFsdWVzIGJlZm9yZSBoYXNoaW5nXHJcbiAqICAtIGByZXNwZWN0RnVuY3Rpb25Qcm9wZXJ0aWVzYCB7KnRydWV8ZmFsc2V9IGNvbnNpZGVyIGZ1bmN0aW9uIHByb3BlcnRpZXMgd2hlbiBoYXNoaW5nXHJcbiAqICAtIGByZXNwZWN0RnVuY3Rpb25OYW1lc2Ageyp0cnVlfGZhbHNlfSBjb25zaWRlciAnbmFtZScgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGZvciBoYXNoaW5nXHJcbiAqICAtIGByZXNwZWN0VHlwZWAgeyp0cnVlfGZhbHNlfSBSZXNwZWN0IHNwZWNpYWwgcHJvcGVydGllcyAocHJvdG90eXBlLCBjb25zdHJ1Y3RvcilcclxuICogICAgd2hlbiBoYXNoaW5nIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gdHlwZXNcclxuICogIC0gYHVub3JkZXJlZEFycmF5c2Age3RydWV8KmZhbHNlfSBTb3J0IGFsbCBhcnJheXMgYmVmb3JlIGhhc2hpbmdcclxuICogIC0gYHVub3JkZXJlZFNldHNgIHsqdHJ1ZXxmYWxzZX0gU29ydCBgU2V0YCBhbmQgYE1hcGAgaW5zdGFuY2VzIGJlZm9yZSBoYXNoaW5nXHJcbiAqICAqID0gZGVmYXVsdFxyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0IHZhbHVlIHRvIGhhc2hcclxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgaGFzaGluZyBvcHRpb25zXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gaGFzaCB2YWx1ZVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gb2JqZWN0SGFzaDtcclxuXHJcbmZ1bmN0aW9uIG9iamVjdEhhc2gob2JqZWN0LCBvcHRpb25zKXtcclxuICBvcHRpb25zID0gYXBwbHlEZWZhdWx0cyhvYmplY3QsIG9wdGlvbnMpO1xyXG5cclxuICByZXR1cm4gaGFzaChvYmplY3QsIG9wdGlvbnMpO1xyXG59XHJcblxyXG4vKipcclxuICogRXhwb3J0ZWQgc3VnYXIgbWV0aG9kc1xyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0IHZhbHVlIHRvIGhhc2hcclxuICogQHJldHVybiB7c3RyaW5nfSBoYXNoIHZhbHVlXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5leHBvcnRzLnNoYTEgPSBmdW5jdGlvbihvYmplY3Qpe1xyXG4gIHJldHVybiBvYmplY3RIYXNoKG9iamVjdCk7XHJcbn07XHJcbmV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCl7XHJcbiAgcmV0dXJuIG9iamVjdEhhc2gob2JqZWN0LCB7ZXhjbHVkZVZhbHVlczogdHJ1ZSwgYWxnb3JpdGhtOiAnc2hhMScsIGVuY29kaW5nOiAnaGV4J30pO1xyXG59O1xyXG5leHBvcnRzLk1ENSA9IGZ1bmN0aW9uKG9iamVjdCl7XHJcbiAgcmV0dXJuIG9iamVjdEhhc2gob2JqZWN0LCB7YWxnb3JpdGhtOiAnbWQ1JywgZW5jb2Rpbmc6ICdoZXgnfSk7XHJcbn07XHJcbmV4cG9ydHMua2V5c01ENSA9IGZ1bmN0aW9uKG9iamVjdCl7XHJcbiAgcmV0dXJuIG9iamVjdEhhc2gob2JqZWN0LCB7YWxnb3JpdGhtOiAnbWQ1JywgZW5jb2Rpbmc6ICdoZXgnLCBleGNsdWRlVmFsdWVzOiB0cnVlfSk7XHJcbn07XHJcblxyXG4vLyBJbnRlcm5hbHNcclxudmFyIGhhc2hlcyA9IGNyeXB0by5nZXRIYXNoZXMgPyBjcnlwdG8uZ2V0SGFzaGVzKCkuc2xpY2UoKSA6IFsnc2hhMScsICdtZDUnXTtcclxuaGFzaGVzLnB1c2goJ3Bhc3N0aHJvdWdoJyk7XHJcbnZhciBlbmNvZGluZ3MgPSBbJ2J1ZmZlcicsICdoZXgnLCAnYmluYXJ5JywgJ2Jhc2U2NCddO1xyXG5cclxuZnVuY3Rpb24gYXBwbHlEZWZhdWx0cyhvYmplY3QsIHNvdXJjZU9wdGlvbnMpe1xyXG4gIHNvdXJjZU9wdGlvbnMgPSBzb3VyY2VPcHRpb25zIHx8IHt9O1xyXG5cclxuICAvLyBjcmVhdGUgYSBjb3B5IHJhdGhlciB0aGFuIG11dGF0aW5nXHJcbiAgdmFyIG9wdGlvbnMgPSB7fTtcclxuICBvcHRpb25zLmFsZ29yaXRobSA9IHNvdXJjZU9wdGlvbnMuYWxnb3JpdGhtIHx8ICdzaGExJztcclxuICBvcHRpb25zLmVuY29kaW5nID0gc291cmNlT3B0aW9ucy5lbmNvZGluZyB8fCAnaGV4JztcclxuICBvcHRpb25zLmV4Y2x1ZGVWYWx1ZXMgPSBzb3VyY2VPcHRpb25zLmV4Y2x1ZGVWYWx1ZXMgPyB0cnVlIDogZmFsc2U7XHJcbiAgb3B0aW9ucy5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobS50b0xvd2VyQ2FzZSgpO1xyXG4gIG9wdGlvbnMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XHJcbiAgb3B0aW9ucy5pZ25vcmVVbmtub3duID0gc291cmNlT3B0aW9ucy5pZ25vcmVVbmtub3duICE9PSB0cnVlID8gZmFsc2UgOiB0cnVlOyAvLyBkZWZhdWx0IHRvIGZhbHNlXHJcbiAgb3B0aW9ucy5yZXNwZWN0VHlwZSA9IHNvdXJjZU9wdGlvbnMucmVzcGVjdFR5cGUgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlOyAvLyBkZWZhdWx0IHRvIHRydWVcclxuICBvcHRpb25zLnJlc3BlY3RGdW5jdGlvbk5hbWVzID0gc291cmNlT3B0aW9ucy5yZXNwZWN0RnVuY3Rpb25OYW1lcyA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWU7XHJcbiAgb3B0aW9ucy5yZXNwZWN0RnVuY3Rpb25Qcm9wZXJ0aWVzID0gc291cmNlT3B0aW9ucy5yZXNwZWN0RnVuY3Rpb25Qcm9wZXJ0aWVzID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTtcclxuICBvcHRpb25zLnVub3JkZXJlZEFycmF5cyA9IHNvdXJjZU9wdGlvbnMudW5vcmRlcmVkQXJyYXlzICE9PSB0cnVlID8gZmFsc2UgOiB0cnVlOyAvLyBkZWZhdWx0IHRvIGZhbHNlXHJcbiAgb3B0aW9ucy51bm9yZGVyZWRTZXRzID0gc291cmNlT3B0aW9ucy51bm9yZGVyZWRTZXRzID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTsgLy8gZGVmYXVsdCB0byBmYWxzZVxyXG4gIG9wdGlvbnMudW5vcmRlcmVkT2JqZWN0cyA9IHNvdXJjZU9wdGlvbnMudW5vcmRlcmVkT2JqZWN0cyA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWU7IC8vIGRlZmF1bHQgdG8gdHJ1ZVxyXG4gIG9wdGlvbnMucmVwbGFjZXIgPSBzb3VyY2VPcHRpb25zLnJlcGxhY2VyIHx8IHVuZGVmaW5lZDtcclxuICBvcHRpb25zLmV4Y2x1ZGVLZXlzID0gc291cmNlT3B0aW9ucy5leGNsdWRlS2V5cyB8fCB1bmRlZmluZWQ7XHJcblxyXG4gIGlmKHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdCBhcmd1bWVudCByZXF1aXJlZC4nKTtcclxuICB9XHJcblxyXG4gIC8vIGlmIHRoZXJlIGlzIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBpbiB0aGUgaGFzaGVzIGxpc3QsIGFjY2VwdCBpdFxyXG4gIC8vIChpLmUuIFNIQTI1NiBmb3Igc2hhMjU2KVxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGFzaGVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICBpZiAoaGFzaGVzW2ldLnRvTG93ZXJDYXNlKCkgPT09IG9wdGlvbnMuYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgb3B0aW9ucy5hbGdvcml0aG0gPSBoYXNoZXNbaV07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZihoYXNoZXMuaW5kZXhPZihvcHRpb25zLmFsZ29yaXRobSkgPT09IC0xKXtcclxuICAgIHRocm93IG5ldyBFcnJvcignQWxnb3JpdGhtIFwiJyArIG9wdGlvbnMuYWxnb3JpdGhtICsgJ1wiICBub3Qgc3VwcG9ydGVkLiAnICtcclxuICAgICAgJ3N1cHBvcnRlZCB2YWx1ZXM6ICcgKyBoYXNoZXMuam9pbignLCAnKSk7XHJcbiAgfVxyXG5cclxuICBpZihlbmNvZGluZ3MuaW5kZXhPZihvcHRpb25zLmVuY29kaW5nKSA9PT0gLTEgJiZcclxuICAgICBvcHRpb25zLmFsZ29yaXRobSAhPT0gJ3Bhc3N0aHJvdWdoJyl7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY29kaW5nIFwiJyArIG9wdGlvbnMuZW5jb2RpbmcgKyAnXCIgIG5vdCBzdXBwb3J0ZWQuICcgK1xyXG4gICAgICAnc3VwcG9ydGVkIHZhbHVlczogJyArIGVuY29kaW5ncy5qb2luKCcsICcpKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBvcHRpb25zO1xyXG59XHJcblxyXG4vKiogQ2hlY2sgaWYgdGhlIGdpdmVuIGZ1bmN0aW9uIGlzIGEgbmF0aXZlIGZ1bmN0aW9uICovXHJcbmZ1bmN0aW9uIGlzTmF0aXZlRnVuY3Rpb24oZikge1xyXG4gIGlmICgodHlwZW9mIGYpICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHZhciBleHAgPSAvXmZ1bmN0aW9uXFxzK1xcdypcXHMqXFwoXFxzKlxcKVxccyp7XFxzK1xcW25hdGl2ZSBjb2RlXFxdXFxzK30kL2k7XHJcbiAgcmV0dXJuIGV4cC5leGVjKEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGYpKSAhPSBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoYXNoKG9iamVjdCwgb3B0aW9ucykge1xyXG4gIHZhciBoYXNoaW5nU3RyZWFtO1xyXG5cclxuICBpZiAob3B0aW9ucy5hbGdvcml0aG0gIT09ICdwYXNzdGhyb3VnaCcpIHtcclxuICAgIGhhc2hpbmdTdHJlYW0gPSBjcnlwdG8uY3JlYXRlSGFzaChvcHRpb25zLmFsZ29yaXRobSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGhhc2hpbmdTdHJlYW0gPSBuZXcgUGFzc1Rocm91Z2goKTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgaGFzaGluZ1N0cmVhbS53cml0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGhhc2hpbmdTdHJlYW0ud3JpdGUgPSBoYXNoaW5nU3RyZWFtLnVwZGF0ZTtcclxuICAgIGhhc2hpbmdTdHJlYW0uZW5kICAgPSBoYXNoaW5nU3RyZWFtLnVwZGF0ZTtcclxuICB9XHJcblxyXG4gIHZhciBoYXNoZXIgPSB0eXBlSGFzaGVyKG9wdGlvbnMsIGhhc2hpbmdTdHJlYW0pO1xyXG4gIGhhc2hlci5kaXNwYXRjaChvYmplY3QpO1xyXG4gIGlmICghaGFzaGluZ1N0cmVhbS51cGRhdGUpIHtcclxuICAgIGhhc2hpbmdTdHJlYW0uZW5kKCcnKTtcclxuICB9XHJcblxyXG4gIGlmIChoYXNoaW5nU3RyZWFtLmRpZ2VzdCkge1xyXG4gICAgcmV0dXJuIGhhc2hpbmdTdHJlYW0uZGlnZXN0KG9wdGlvbnMuZW5jb2RpbmcgPT09ICdidWZmZXInID8gdW5kZWZpbmVkIDogb3B0aW9ucy5lbmNvZGluZyk7XHJcbiAgfVxyXG5cclxuICB2YXIgYnVmID0gaGFzaGluZ1N0cmVhbS5yZWFkKCk7XHJcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcgPT09ICdidWZmZXInKSB7XHJcbiAgICByZXR1cm4gYnVmO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyhvcHRpb25zLmVuY29kaW5nKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEV4cG9zZSBzdHJlYW1pbmcgQVBJXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgIFZhbHVlIHRvIHNlcmlhbGl6ZVxyXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgT3B0aW9ucywgYXMgZm9yIGhhc2goKVxyXG4gKiBAcGFyYW0ge29iamVjdH0gc3RyZWFtICBBIHN0cmVhbSB0byB3cml0ZSB0aGUgc2VyaWFsaXppYXRpb24gdG9cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcbmV4cG9ydHMud3JpdGVUb1N0cmVhbSA9IGZ1bmN0aW9uKG9iamVjdCwgb3B0aW9ucywgc3RyZWFtKSB7XHJcbiAgaWYgKHR5cGVvZiBzdHJlYW0gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBzdHJlYW0gPSBvcHRpb25zO1xyXG4gICAgb3B0aW9ucyA9IHt9O1xyXG4gIH1cclxuXHJcbiAgb3B0aW9ucyA9IGFwcGx5RGVmYXVsdHMob2JqZWN0LCBvcHRpb25zKTtcclxuXHJcbiAgcmV0dXJuIHR5cGVIYXNoZXIob3B0aW9ucywgc3RyZWFtKS5kaXNwYXRjaChvYmplY3QpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gdHlwZUhhc2hlcihvcHRpb25zLCB3cml0ZVRvLCBjb250ZXh0KXtcclxuICBjb250ZXh0ID0gY29udGV4dCB8fCBbXTtcclxuICB2YXIgd3JpdGUgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgIGlmICh3cml0ZVRvLnVwZGF0ZSkge1xyXG4gICAgICByZXR1cm4gd3JpdGVUby51cGRhdGUoc3RyLCAndXRmOCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHdyaXRlVG8ud3JpdGUoc3RyLCAndXRmOCcpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBkaXNwYXRjaDogZnVuY3Rpb24odmFsdWUpe1xyXG4gICAgICBpZiAob3B0aW9ucy5yZXBsYWNlcikge1xyXG4gICAgICAgIHZhbHVlID0gb3B0aW9ucy5yZXBsYWNlcih2YWx1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xyXG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICB0eXBlID0gJ251bGwnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvL2NvbnNvbGUubG9nKFwiW0RFQlVHXSBEaXNwYXRjaDogXCIsIHZhbHVlLCBcIi0+XCIsIHR5cGUsIFwiIC0+IFwiLCBcIl9cIiArIHR5cGUpO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXNbJ18nICsgdHlwZV0odmFsdWUpO1xyXG4gICAgfSxcclxuICAgIF9vYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCkge1xyXG4gICAgICB2YXIgcGF0dGVybiA9ICgvXFxbb2JqZWN0ICguKilcXF0vaSk7XHJcbiAgICAgIHZhciBvYmpTdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KTtcclxuICAgICAgdmFyIG9ialR5cGUgPSBwYXR0ZXJuLmV4ZWMob2JqU3RyaW5nKTtcclxuICAgICAgaWYgKCFvYmpUeXBlKSB7IC8vIG9iamVjdCB0eXBlIGRpZCBub3QgbWF0Y2ggW29iamVjdCAuLi5dXHJcbiAgICAgICAgb2JqVHlwZSA9ICd1bmtub3duOlsnICsgb2JqU3RyaW5nICsgJ10nO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG9ialR5cGUgPSBvYmpUeXBlWzFdOyAvLyB0YWtlIG9ubHkgdGhlIGNsYXNzIG5hbWVcclxuICAgICAgfVxyXG5cclxuICAgICAgb2JqVHlwZSA9IG9ialR5cGUudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAgIHZhciBvYmplY3ROdW1iZXIgPSBudWxsO1xyXG5cclxuICAgICAgaWYgKChvYmplY3ROdW1iZXIgPSBjb250ZXh0LmluZGV4T2Yob2JqZWN0KSkgPj0gMCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKCdbQ0lSQ1VMQVI6JyArIG9iamVjdE51bWJlciArICddJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29udGV4dC5wdXNoKG9iamVjdCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBCdWZmZXIuaXNCdWZmZXIgJiYgQnVmZmVyLmlzQnVmZmVyKG9iamVjdCkpIHtcclxuICAgICAgICB3cml0ZSgnYnVmZmVyOicpO1xyXG4gICAgICAgIHJldHVybiB3cml0ZShvYmplY3QpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZihvYmpUeXBlICE9PSAnb2JqZWN0JyAmJiBvYmpUeXBlICE9PSAnZnVuY3Rpb24nICYmIG9ialR5cGUgIT09ICdhc3luY2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGlmKHRoaXNbJ18nICsgb2JqVHlwZV0pIHtcclxuICAgICAgICAgIHRoaXNbJ18nICsgb2JqVHlwZV0ob2JqZWN0KTtcclxuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaWdub3JlVW5rbm93bikge1xyXG4gICAgICAgICAgcmV0dXJuIHdyaXRlKCdbJyArIG9ialR5cGUgKyAnXScpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gb2JqZWN0IHR5cGUgXCInICsgb2JqVHlwZSArICdcIicpO1xyXG4gICAgICAgIH1cclxuICAgICAgfWVsc2V7XHJcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xyXG4gICAgICAgIGlmIChvcHRpb25zLnVub3JkZXJlZE9iamVjdHMpIHtcclxuICAgICAgICAgIGtleXMgPSBrZXlzLnNvcnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRvIGluY29ycG9yYXRlIHNwZWNpYWwgcHJvcGVydGllcywgc29cclxuICAgICAgICAvLyBUeXBlcyB3aXRoIGRpZmZlcmVudCBwcm90b3R5cGVzIHdpbGwgcHJvZHVjZVxyXG4gICAgICAgIC8vIGEgZGlmZmVyZW50IGhhc2ggYW5kIG9iamVjdHMgZGVyaXZlZCBmcm9tXHJcbiAgICAgICAgLy8gZGlmZmVyZW50IGZ1bmN0aW9ucyAoYG5ldyBGb29gLCBgbmV3IEJhcmApIHdpbGxcclxuICAgICAgICAvLyBwcm9kdWNlIGRpZmZlcmVudCBoYXNoZXMuXHJcbiAgICAgICAgLy8gV2UgbmV2ZXIgZG8gdGhpcyBmb3IgbmF0aXZlIGZ1bmN0aW9ucyBzaW5jZSBzb21lXHJcbiAgICAgICAgLy8gc2VlbSB0byBicmVhayBiZWNhdXNlIG9mIHRoYXQuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMucmVzcGVjdFR5cGUgIT09IGZhbHNlICYmICFpc05hdGl2ZUZ1bmN0aW9uKG9iamVjdCkpIHtcclxuICAgICAgICAgIGtleXMuc3BsaWNlKDAsIDAsICdwcm90b3R5cGUnLCAnX19wcm90b19fJywgJ2NvbnN0cnVjdG9yJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5leGNsdWRlS2V5cykge1xyXG4gICAgICAgICAga2V5cyA9IGtleXMuZmlsdGVyKGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gIW9wdGlvbnMuZXhjbHVkZUtleXMoa2V5KTsgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3cml0ZSgnb2JqZWN0OicgKyBrZXlzLmxlbmd0aCArICc6Jyk7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KXtcclxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2goa2V5KTtcclxuICAgICAgICAgIHdyaXRlKCc6Jyk7XHJcbiAgICAgICAgICBpZighb3B0aW9ucy5leGNsdWRlVmFsdWVzKSB7XHJcbiAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2gob2JqZWN0W2tleV0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgd3JpdGUoJywnKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9hcnJheTogZnVuY3Rpb24oYXJyLCB1bm9yZGVyZWQpe1xyXG4gICAgICB1bm9yZGVyZWQgPSB0eXBlb2YgdW5vcmRlcmVkICE9PSAndW5kZWZpbmVkJyA/IHVub3JkZXJlZCA6XHJcbiAgICAgICAgb3B0aW9ucy51bm9yZGVyZWRBcnJheXMgIT09IGZhbHNlOyAvLyBkZWZhdWx0IHRvIG9wdGlvbnMudW5vcmRlcmVkQXJyYXlzXHJcblxyXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgIHdyaXRlKCdhcnJheTonICsgYXJyLmxlbmd0aCArICc6Jyk7XHJcbiAgICAgIGlmICghdW5vcmRlcmVkIHx8IGFyci5sZW5ndGggPD0gMSkge1xyXG4gICAgICAgIHJldHVybiBhcnIuZm9yRWFjaChmdW5jdGlvbihlbnRyeSkge1xyXG4gICAgICAgICAgcmV0dXJuIHNlbGYuZGlzcGF0Y2goZW50cnkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB0aGUgdW5vcmRlcmVkIGNhc2UgaXMgYSBsaXR0bGUgbW9yZSBjb21wbGljYXRlZDpcclxuICAgICAgLy8gc2luY2UgdGhlcmUgaXMgbm8gY2Fub25pY2FsIG9yZGVyaW5nIG9uIG9iamVjdHMsXHJcbiAgICAgIC8vIGkuZS4ge2E6MX0gPCB7YToyfSBhbmQge2E6MX0gPiB7YToyfSBhcmUgYm90aCBmYWxzZSxcclxuICAgICAgLy8gd2UgZmlyc3Qgc2VyaWFsaXplIGVhY2ggZW50cnkgdXNpbmcgYSBQYXNzVGhyb3VnaCBzdHJlYW1cclxuICAgICAgLy8gYmVmb3JlIHNvcnRpbmcuXHJcbiAgICAgIC8vIGFsc286IHdlIGNhbuKAmXQgdXNlIHRoZSBzYW1lIGNvbnRleHQgYXJyYXkgZm9yIGFsbCBlbnRyaWVzXHJcbiAgICAgIC8vIHNpbmNlIHRoZSBvcmRlciBvZiBoYXNoaW5nIHNob3VsZCAqbm90KiBtYXR0ZXIuIGluc3RlYWQsXHJcbiAgICAgIC8vIHdlIGtlZXAgdHJhY2sgb2YgdGhlIGFkZGl0aW9ucyB0byBhIGNvcHkgb2YgdGhlIGNvbnRleHQgYXJyYXlcclxuICAgICAgLy8gYW5kIGFkZCBhbGwgb2YgdGhlbSB0byB0aGUgZ2xvYmFsIGNvbnRleHQgYXJyYXkgd2hlbiB3ZeKAmXJlIGRvbmVcclxuICAgICAgdmFyIGNvbnRleHRBZGRpdGlvbnMgPSBbXTtcclxuICAgICAgdmFyIGVudHJpZXMgPSBhcnIubWFwKGZ1bmN0aW9uKGVudHJ5KSB7XHJcbiAgICAgICAgdmFyIHN0cm0gPSBuZXcgUGFzc1Rocm91Z2goKTtcclxuICAgICAgICB2YXIgbG9jYWxDb250ZXh0ID0gY29udGV4dC5zbGljZSgpOyAvLyBtYWtlIGNvcHlcclxuICAgICAgICB2YXIgaGFzaGVyID0gdHlwZUhhc2hlcihvcHRpb25zLCBzdHJtLCBsb2NhbENvbnRleHQpO1xyXG4gICAgICAgIGhhc2hlci5kaXNwYXRjaChlbnRyeSk7XHJcbiAgICAgICAgLy8gdGFrZSBvbmx5IHdoYXQgd2FzIGFkZGVkIHRvIGxvY2FsQ29udGV4dCBhbmQgYXBwZW5kIGl0IHRvIGNvbnRleHRBZGRpdGlvbnNcclxuICAgICAgICBjb250ZXh0QWRkaXRpb25zID0gY29udGV4dEFkZGl0aW9ucy5jb25jYXQobG9jYWxDb250ZXh0LnNsaWNlKGNvbnRleHQubGVuZ3RoKSk7XHJcbiAgICAgICAgcmV0dXJuIHN0cm0ucmVhZCgpLnRvU3RyaW5nKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBjb250ZXh0ID0gY29udGV4dC5jb25jYXQoY29udGV4dEFkZGl0aW9ucyk7XHJcbiAgICAgIGVudHJpZXMuc29ydCgpO1xyXG4gICAgICByZXR1cm4gdGhpcy5fYXJyYXkoZW50cmllcywgZmFsc2UpO1xyXG4gICAgfSxcclxuICAgIF9kYXRlOiBmdW5jdGlvbihkYXRlKXtcclxuICAgICAgcmV0dXJuIHdyaXRlKCdkYXRlOicgKyBkYXRlLnRvSlNPTigpKTtcclxuICAgIH0sXHJcbiAgICBfc3ltYm9sOiBmdW5jdGlvbihzeW0pe1xyXG4gICAgICByZXR1cm4gd3JpdGUoJ3N5bWJvbDonICsgc3ltLnRvU3RyaW5nKCkpO1xyXG4gICAgfSxcclxuICAgIF9lcnJvcjogZnVuY3Rpb24oZXJyKXtcclxuICAgICAgcmV0dXJuIHdyaXRlKCdlcnJvcjonICsgZXJyLnRvU3RyaW5nKCkpO1xyXG4gICAgfSxcclxuICAgIF9ib29sZWFuOiBmdW5jdGlvbihib29sKXtcclxuICAgICAgcmV0dXJuIHdyaXRlKCdib29sOicgKyBib29sLnRvU3RyaW5nKCkpO1xyXG4gICAgfSxcclxuICAgIF9zdHJpbmc6IGZ1bmN0aW9uKHN0cmluZyl7XHJcbiAgICAgIHdyaXRlKCdzdHJpbmc6JyArIHN0cmluZy5sZW5ndGggKyAnOicpO1xyXG4gICAgICB3cml0ZShzdHJpbmcudG9TdHJpbmcoKSk7XHJcbiAgICB9LFxyXG4gICAgX2Z1bmN0aW9uOiBmdW5jdGlvbihmbil7XHJcbiAgICAgIHdyaXRlKCdmbjonKTtcclxuICAgICAgaWYgKGlzTmF0aXZlRnVuY3Rpb24oZm4pKSB7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaCgnW25hdGl2ZV0nKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoKGZuLnRvU3RyaW5nKCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAob3B0aW9ucy5yZXNwZWN0RnVuY3Rpb25OYW1lcyAhPT0gZmFsc2UpIHtcclxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgY2FuIHN0aWxsIGRpc3Rpbmd1aXNoIG5hdGl2ZSBmdW5jdGlvbnNcclxuICAgICAgICAvLyBieSB0aGVpciBuYW1lLCBvdGhlcndpc2UgU3RyaW5nIGFuZCBGdW5jdGlvbiB3aWxsXHJcbiAgICAgICAgLy8gaGF2ZSB0aGUgc2FtZSBoYXNoXHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaChcImZ1bmN0aW9uLW5hbWU6XCIgKyBTdHJpbmcoZm4ubmFtZSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAob3B0aW9ucy5yZXNwZWN0RnVuY3Rpb25Qcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgdGhpcy5fb2JqZWN0KGZuKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9udW1iZXI6IGZ1bmN0aW9uKG51bWJlcil7XHJcbiAgICAgIHJldHVybiB3cml0ZSgnbnVtYmVyOicgKyBudW1iZXIudG9TdHJpbmcoKSk7XHJcbiAgICB9LFxyXG4gICAgX3htbDogZnVuY3Rpb24oeG1sKXtcclxuICAgICAgcmV0dXJuIHdyaXRlKCd4bWw6JyArIHhtbC50b1N0cmluZygpKTtcclxuICAgIH0sXHJcbiAgICBfbnVsbDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB3cml0ZSgnTnVsbCcpO1xyXG4gICAgfSxcclxuICAgIF91bmRlZmluZWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gd3JpdGUoJ1VuZGVmaW5lZCcpO1xyXG4gICAgfSxcclxuICAgIF9yZWdleHA6IGZ1bmN0aW9uKHJlZ2V4KXtcclxuICAgICAgcmV0dXJuIHdyaXRlKCdyZWdleDonICsgcmVnZXgudG9TdHJpbmcoKSk7XHJcbiAgICB9LFxyXG4gICAgX3VpbnQ4YXJyYXk6IGZ1bmN0aW9uKGFycil7XHJcbiAgICAgIHdyaXRlKCd1aW50OGFycmF5OicpO1xyXG4gICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIpKTtcclxuICAgIH0sXHJcbiAgICBfdWludDhjbGFtcGVkYXJyYXk6IGZ1bmN0aW9uKGFycil7XHJcbiAgICAgIHdyaXRlKCd1aW50OGNsYW1wZWRhcnJheTonKTtcclxuICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKSk7XHJcbiAgICB9LFxyXG4gICAgX2ludDhhcnJheTogZnVuY3Rpb24oYXJyKXtcclxuICAgICAgd3JpdGUoJ3VpbnQ4YXJyYXk6Jyk7XHJcbiAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycikpO1xyXG4gICAgfSxcclxuICAgIF91aW50MTZhcnJheTogZnVuY3Rpb24oYXJyKXtcclxuICAgICAgd3JpdGUoJ3VpbnQxNmFycmF5OicpO1xyXG4gICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIpKTtcclxuICAgIH0sXHJcbiAgICBfaW50MTZhcnJheTogZnVuY3Rpb24oYXJyKXtcclxuICAgICAgd3JpdGUoJ3VpbnQxNmFycmF5OicpO1xyXG4gICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIpKTtcclxuICAgIH0sXHJcbiAgICBfdWludDMyYXJyYXk6IGZ1bmN0aW9uKGFycil7XHJcbiAgICAgIHdyaXRlKCd1aW50MzJhcnJheTonKTtcclxuICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKSk7XHJcbiAgICB9LFxyXG4gICAgX2ludDMyYXJyYXk6IGZ1bmN0aW9uKGFycil7XHJcbiAgICAgIHdyaXRlKCd1aW50MzJhcnJheTonKTtcclxuICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKSk7XHJcbiAgICB9LFxyXG4gICAgX2Zsb2F0MzJhcnJheTogZnVuY3Rpb24oYXJyKXtcclxuICAgICAgd3JpdGUoJ2Zsb2F0MzJhcnJheTonKTtcclxuICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKSk7XHJcbiAgICB9LFxyXG4gICAgX2Zsb2F0NjRhcnJheTogZnVuY3Rpb24oYXJyKXtcclxuICAgICAgd3JpdGUoJ2Zsb2F0NjRhcnJheTonKTtcclxuICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKSk7XHJcbiAgICB9LFxyXG4gICAgX2FycmF5YnVmZmVyOiBmdW5jdGlvbihhcnIpe1xyXG4gICAgICB3cml0ZSgnYXJyYXlidWZmZXI6Jyk7XHJcbiAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKG5ldyBVaW50OEFycmF5KGFycikpO1xyXG4gICAgfSxcclxuICAgIF91cmw6IGZ1bmN0aW9uKHVybCkge1xyXG4gICAgICByZXR1cm4gd3JpdGUoJ3VybDonICsgdXJsLnRvU3RyaW5nKCksICd1dGY4Jyk7XHJcbiAgICB9LFxyXG4gICAgX21hcDogZnVuY3Rpb24obWFwKSB7XHJcbiAgICAgIHdyaXRlKCdtYXA6Jyk7XHJcbiAgICAgIHZhciBhcnIgPSBBcnJheS5mcm9tKG1hcCk7XHJcbiAgICAgIHJldHVybiB0aGlzLl9hcnJheShhcnIsIG9wdGlvbnMudW5vcmRlcmVkU2V0cyAhPT0gZmFsc2UpO1xyXG4gICAgfSxcclxuICAgIF9zZXQ6IGZ1bmN0aW9uKHNldCkge1xyXG4gICAgICB3cml0ZSgnc2V0OicpO1xyXG4gICAgICB2YXIgYXJyID0gQXJyYXkuZnJvbShzZXQpO1xyXG4gICAgICByZXR1cm4gdGhpcy5fYXJyYXkoYXJyLCBvcHRpb25zLnVub3JkZXJlZFNldHMgIT09IGZhbHNlKTtcclxuICAgIH0sXHJcbiAgICBfZmlsZTogZnVuY3Rpb24oZmlsZSkge1xyXG4gICAgICB3cml0ZSgnZmlsZTonKTtcclxuICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goW2ZpbGUubmFtZSwgZmlsZS5zaXplLCBmaWxlLnR5cGUsIGZpbGUubGFzdE1vZGZpZWRdKTtcclxuICAgIH0sXHJcbiAgICBfYmxvYjogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmIChvcHRpb25zLmlnbm9yZVVua25vd24pIHtcclxuICAgICAgICByZXR1cm4gd3JpdGUoJ1tibG9iXScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aHJvdyBFcnJvcignSGFzaGluZyBCbG9iIG9iamVjdHMgaXMgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcXG4nICtcclxuICAgICAgICAnKHNlZSBodHRwczovL2dpdGh1Yi5jb20vcHVsZW9zL29iamVjdC1oYXNoL2lzc3Vlcy8yNilcXG4nICtcclxuICAgICAgICAnVXNlIFwib3B0aW9ucy5yZXBsYWNlclwiIG9yIFwib3B0aW9ucy5pZ25vcmVVbmtub3duXCJcXG4nKTtcclxuICAgIH0sXHJcbiAgICBfZG9td2luZG93OiBmdW5jdGlvbigpIHsgcmV0dXJuIHdyaXRlKCdkb213aW5kb3cnKTsgfSxcclxuICAgIF9iaWdpbnQ6IGZ1bmN0aW9uKG51bWJlcil7XHJcbiAgICAgIHJldHVybiB3cml0ZSgnYmlnaW50OicgKyBudW1iZXIudG9TdHJpbmcoKSk7XHJcbiAgICB9LFxyXG4gICAgLyogTm9kZS5qcyBzdGFuZGFyZCBuYXRpdmUgb2JqZWN0cyAqL1xyXG4gICAgX3Byb2Nlc3M6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd3JpdGUoJ3Byb2Nlc3MnKTsgfSxcclxuICAgIF90aW1lcjogZnVuY3Rpb24oKSB7IHJldHVybiB3cml0ZSgndGltZXInKTsgfSxcclxuICAgIF9waXBlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHdyaXRlKCdwaXBlJyk7IH0sXHJcbiAgICBfdGNwOiBmdW5jdGlvbigpIHsgcmV0dXJuIHdyaXRlKCd0Y3AnKTsgfSxcclxuICAgIF91ZHA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd3JpdGUoJ3VkcCcpOyB9LFxyXG4gICAgX3R0eTogZnVuY3Rpb24oKSB7IHJldHVybiB3cml0ZSgndHR5Jyk7IH0sXHJcbiAgICBfc3RhdHdhdGNoZXI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd3JpdGUoJ3N0YXR3YXRjaGVyJyk7IH0sXHJcbiAgICBfc2VjdXJlY29udGV4dDogZnVuY3Rpb24oKSB7IHJldHVybiB3cml0ZSgnc2VjdXJlY29udGV4dCcpOyB9LFxyXG4gICAgX2Nvbm5lY3Rpb246IGZ1bmN0aW9uKCkgeyByZXR1cm4gd3JpdGUoJ2Nvbm5lY3Rpb24nKTsgfSxcclxuICAgIF96bGliOiBmdW5jdGlvbigpIHsgcmV0dXJuIHdyaXRlKCd6bGliJyk7IH0sXHJcbiAgICBfY29udGV4dDogZnVuY3Rpb24oKSB7IHJldHVybiB3cml0ZSgnY29udGV4dCcpOyB9LFxyXG4gICAgX25vZGVzY3JpcHQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd3JpdGUoJ25vZGVzY3JpcHQnKTsgfSxcclxuICAgIF9odHRwcGFyc2VyOiBmdW5jdGlvbigpIHsgcmV0dXJuIHdyaXRlKCdodHRwcGFyc2VyJyk7IH0sXHJcbiAgICBfZGF0YXZpZXc6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd3JpdGUoJ2RhdGF2aWV3Jyk7IH0sXHJcbiAgICBfc2lnbmFsOiBmdW5jdGlvbigpIHsgcmV0dXJuIHdyaXRlKCdzaWduYWwnKTsgfSxcclxuICAgIF9mc2V2ZW50OiBmdW5jdGlvbigpIHsgcmV0dXJuIHdyaXRlKCdmc2V2ZW50Jyk7IH0sXHJcbiAgICBfdGxzd3JhcDogZnVuY3Rpb24oKSB7IHJldHVybiB3cml0ZSgndGxzd3JhcCcpOyB9LFxyXG4gIH07XHJcbn1cclxuXHJcbi8vIE1pbmktaW1wbGVtZW50YXRpb24gb2Ygc3RyZWFtLlBhc3NUaHJvdWdoXHJcbi8vIFdlIGFyZSBmYXIgZnJvbSBoYXZpbmcgbmVlZCBmb3IgdGhlIGZ1bGwgaW1wbGVtZW50YXRpb24sIGFuZCB3ZSBjYW5cclxuLy8gbWFrZSBhc3N1bXB0aW9ucyBsaWtlIFwibWFueSB3cml0ZXMsIHRoZW4gb25seSBvbmUgZmluYWwgcmVhZFwiXHJcbi8vIGFuZCB3ZSBjYW4gaWdub3JlIGVuY29kaW5nIHNwZWNpZmljc1xyXG5mdW5jdGlvbiBQYXNzVGhyb3VnaCgpIHtcclxuICByZXR1cm4ge1xyXG4gICAgYnVmOiAnJyxcclxuXHJcbiAgICB3cml0ZTogZnVuY3Rpb24oYikge1xyXG4gICAgICB0aGlzLmJ1ZiArPSBiO1xyXG4gICAgfSxcclxuXHJcbiAgICBlbmQ6IGZ1bmN0aW9uKGIpIHtcclxuICAgICAgdGhpcy5idWYgKz0gYjtcclxuICAgIH0sXHJcblxyXG4gICAgcmVhZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmJ1ZjtcclxuICAgIH1cclxuICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJjcnlwdG8iLCJyZXF1aXJlIiwiZXhwb3J0cyIsIm1vZHVsZSIsIm9iamVjdEhhc2giLCJvYmplY3QiLCJvcHRpb25zIiwiYXBwbHlEZWZhdWx0cyIsImhhc2giLCJzaGExIiwia2V5cyIsImV4Y2x1ZGVWYWx1ZXMiLCJhbGdvcml0aG0iLCJlbmNvZGluZyIsIk1ENSIsImtleXNNRDUiLCJoYXNoZXMiLCJnZXRIYXNoZXMiLCJzbGljZSIsInB1c2giLCJlbmNvZGluZ3MiLCJzb3VyY2VPcHRpb25zIiwidG9Mb3dlckNhc2UiLCJpZ25vcmVVbmtub3duIiwicmVzcGVjdFR5cGUiLCJyZXNwZWN0RnVuY3Rpb25OYW1lcyIsInJlc3BlY3RGdW5jdGlvblByb3BlcnRpZXMiLCJ1bm9yZGVyZWRBcnJheXMiLCJ1bm9yZGVyZWRTZXRzIiwidW5vcmRlcmVkT2JqZWN0cyIsInJlcGxhY2VyIiwidW5kZWZpbmVkIiwiZXhjbHVkZUtleXMiLCJFcnJvciIsImkiLCJsZW5ndGgiLCJpbmRleE9mIiwiam9pbiIsImlzTmF0aXZlRnVuY3Rpb24iLCJmIiwiZXhwIiwiZXhlYyIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiaGFzaGluZ1N0cmVhbSIsImNyZWF0ZUhhc2giLCJQYXNzVGhyb3VnaCIsIndyaXRlIiwidXBkYXRlIiwiZW5kIiwiaGFzaGVyIiwidHlwZUhhc2hlciIsImRpc3BhdGNoIiwiZGlnZXN0IiwiYnVmIiwicmVhZCIsIndyaXRlVG9TdHJlYW0iLCJzdHJlYW0iLCJ3cml0ZVRvIiwiY29udGV4dCIsInN0ciIsInZhbHVlIiwidHlwZSIsIl9vYmplY3QiLCJwYXR0ZXJuIiwib2JqU3RyaW5nIiwiT2JqZWN0Iiwib2JqVHlwZSIsIm9iamVjdE51bWJlciIsIkJ1ZmZlciIsImlzQnVmZmVyIiwic29ydCIsInNwbGljZSIsImZpbHRlciIsImtleSIsInNlbGYiLCJmb3JFYWNoIiwiX2FycmF5IiwiYXJyIiwidW5vcmRlcmVkIiwiZW50cnkiLCJjb250ZXh0QWRkaXRpb25zIiwiZW50cmllcyIsIm1hcCIsInN0cm0iLCJsb2NhbENvbnRleHQiLCJjb25jYXQiLCJfZGF0ZSIsImRhdGUiLCJ0b0pTT04iLCJfc3ltYm9sIiwic3ltIiwiX2Vycm9yIiwiZXJyIiwiX2Jvb2xlYW4iLCJib29sIiwiX3N0cmluZyIsInN0cmluZyIsIl9mdW5jdGlvbiIsImZuIiwiU3RyaW5nIiwibmFtZSIsIl9udW1iZXIiLCJudW1iZXIiLCJfeG1sIiwieG1sIiwiX251bGwiLCJfdW5kZWZpbmVkIiwiX3JlZ2V4cCIsInJlZ2V4IiwiX3VpbnQ4YXJyYXkiLCJBcnJheSIsIl91aW50OGNsYW1wZWRhcnJheSIsIl9pbnQ4YXJyYXkiLCJfdWludDE2YXJyYXkiLCJfaW50MTZhcnJheSIsIl91aW50MzJhcnJheSIsIl9pbnQzMmFycmF5IiwiX2Zsb2F0MzJhcnJheSIsIl9mbG9hdDY0YXJyYXkiLCJfYXJyYXlidWZmZXIiLCJVaW50OEFycmF5IiwiX3VybCIsInVybCIsIl9tYXAiLCJmcm9tIiwiX3NldCIsInNldCIsIl9maWxlIiwiZmlsZSIsInNpemUiLCJsYXN0TW9kZmllZCIsIl9ibG9iIiwiX2RvbXdpbmRvdyIsIl9iaWdpbnQiLCJfcHJvY2VzcyIsIl90aW1lciIsIl9waXBlIiwiX3RjcCIsIl91ZHAiLCJfdHR5IiwiX3N0YXR3YXRjaGVyIiwiX3NlY3VyZWNvbnRleHQiLCJfY29ubmVjdGlvbiIsIl96bGliIiwiX2NvbnRleHQiLCJfbm9kZXNjcmlwdCIsIl9odHRwcGFyc2VyIiwiX2RhdGF2aWV3IiwiX3NpZ25hbCIsIl9mc2V2ZW50IiwiX3Rsc3dyYXAiLCJiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/node_modules/object-hash/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openid-client/package.json":
/*!*************************************************!*\
  !*** ./node_modules/openid-client/package.json ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"openid-client","version":"5.6.2","description":"OpenID Connect Relying Party (RP, Client) implementation for Node.js runtime, supports passportjs","keywords":["auth","authentication","basic","certified","client","connect","dynamic","electron","hybrid","identity","implicit","oauth","oauth2","oidc","openid","passport","relying party","strategy"],"homepage":"https://github.com/panva/node-openid-client","repository":"panva/node-openid-client","funding":{"url":"https://github.com/sponsors/panva"},"license":"MIT","author":"Filip Skokan <panva.ip@gmail.com>","exports":{"types":"./types/index.d.ts","import":"./lib/index.mjs","require":"./lib/index.js"},"main":"./lib/index.js","types":"./types/index.d.ts","files":["lib","types/index.d.ts"],"scripts":{"format":"npx prettier --loglevel silent --write ./lib ./test ./certification ./types","test":"mocha test/**/*.test.js"},"dependencies":{"jose":"^4.15.4","lru-cache":"^6.0.0","object-hash":"^2.2.0","oidc-token-hash":"^5.0.3"},"devDependencies":{"@types/node":"^16.18.59","@types/passport":"^1.0.14","base64url":"^3.0.1","chai":"^4.3.10","mocha":"^10.2.0","nock":"^13.3.6","prettier":"^2.8.8","readable-mock-req":"^0.2.2","sinon":"^9.2.4","timekeeper":"^2.3.1"},"standard-version":{"scripts":{"postchangelog":"sed -i \'\' -e \'s/### \\\\[/## [/g\' CHANGELOG.md"},"types":[{"type":"feat","section":"Features"},{"type":"fix","section":"Fixes"},{"type":"chore","hidden":true},{"type":"docs","hidden":true},{"type":"style","hidden":true},{"type":"refactor","section":"Refactor","hidden":false},{"type":"perf","section":"Performance","hidden":false},{"type":"test","hidden":true}]}}');

/***/ })

};
;